<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 LPWAN Architecture">
<link href="#rfc.section.3" rel="Chapter" title="3 Terminology">
<link href="#rfc.section.4" rel="Chapter" title="4 SCHC overview">
<link href="#rfc.section.5" rel="Chapter" title="5 Rule ID">
<link href="#rfc.section.6" rel="Chapter" title="6 Static Context Header Compression">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 SCHC C/D Rules">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Rule ID for SCHC C/D">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Packet processing">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Matching operators">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Compression Decompression Actions (CDA)">
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 not-sent CDA">
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 value-sent CDA">
<link href="#rfc.section.6.5.3" rel="Chapter" title="6.5.3 mapping-sent CDA">
<link href="#rfc.section.6.5.4" rel="Chapter" title="6.5.4 LSB CDA">
<link href="#rfc.section.6.5.5" rel="Chapter" title="6.5.5 DEViid, APPiid CDA">
<link href="#rfc.section.6.5.6" rel="Chapter" title="6.5.6 Compute-*">
<link href="#rfc.section.7" rel="Chapter" title="7 Fragmentation">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Overview">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Fragmentation Tools">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Reliability modes">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Fragmentation Formats">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Fragment format">
<link href="#rfc.section.7.4.2" rel="Chapter" title="7.4.2 All-1 and All-0 formats">
<link href="#rfc.section.7.4.3" rel="Chapter" title="7.4.3 SCHC ACK format">
<link href="#rfc.section.7.4.4" rel="Chapter" title="7.4.4 Abort formats">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Baseline mechanism">
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 No-ACK">
<link href="#rfc.section.7.5.2" rel="Chapter" title="7.5.2 ACK-Always">
<link href="#rfc.section.7.5.3" rel="Chapter" title="7.5.3 ACK-on-Error">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 Supporting multiple window sizes">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Downlink SCHC Fragment transmission">
<link href="#rfc.section.8" rel="Chapter" title="8 Padding management">
<link href="#rfc.section.9" rel="Chapter" title="9 SCHC Compression for IPv6 and UDP headers">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 IPv6 version field">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 IPv6 Traffic class field">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Flow label field">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Payload Length field">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Next Header field">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Hop Limit field">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 IPv6 addresses fields">
<link href="#rfc.section.9.7.1" rel="Chapter" title="9.7.1 IPv6 source and destination prefixes">
<link href="#rfc.section.9.7.2" rel="Chapter" title="9.7.2 IPv6 source and destination IID">
<link href="#rfc.section.9.8" rel="Chapter" title="9.8 IPv6 extensions">
<link href="#rfc.section.9.9" rel="Chapter" title="9.9 UDP source and destination port">
<link href="#rfc.section.9.10" rel="Chapter" title="9.10 UDP length field">
<link href="#rfc.section.9.11" rel="Chapter" title="9.11 UDP Checksum field">
<link href="#rfc.section.10" rel="Chapter" title="10 Security considerations">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Security considerations for header compression">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Security considerations for SCHC Fragmentation/Reassembly">
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="12 References">
<link href="#rfc.references.1" rel="Chapter" title="12.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="12.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A SCHC Compression Examples">
<link href="#rfc.appendix.B" rel="Chapter" title="B Fragmentation Examples">
<link href="#rfc.appendix.C" rel="Chapter" title="C Fragmentation State Machines">
<link href="#rfc.appendix.D" rel="Chapter" title="D SCHC Parameters - Ticket #15">
<link href="#rfc.appendix.E" rel="Chapter" title="E Note">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.9.6 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Minaburo, A., Toutain, L., Gomez, C., and D. Barthel" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-lpwan-ipv6-static-context-hc-13" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-05-29" />
  <meta name="dct.abstract" content="This document defines the Static Context Header Compression (SCHC) framework, which provides header compression and fragmentation functionality. SCHC has been tailored for Low Power Wide Area Networks (LPWAN)." />
  <meta name="description" content="This document defines the Static Context Header Compression (SCHC) framework, which provides header compression and fragmentation functionality. SCHC has been tailored for Low Power Wide Area Networks (LPWAN)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">lpwan Working Group</td>
<td class="right">A. Minaburo</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Acklio</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">L. Toutain</td>
</tr>
<tr>
<td class="left">Expires: November 30, 2018</td>
<td class="right">IMT-Atlantique</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Gomez</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Universitat Polit&#232;cnica de Catalunya</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">D. Barthel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Orange Labs</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">May 29, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP<br />
  <span class="filename">draft-ietf-lpwan-ipv6-static-context-hc-13</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the Static Context Header Compression (SCHC) framework, which provides header compression and fragmentation functionality. SCHC has been tailored for Low Power Wide Area Networks (LPWAN).</p>
<p>SCHC compression is based on a common static context stored in both LPWAN devices and in the network sides. This document defines SCHC header compression mechanism and its deployment for IPv6/UDP headers. This document also specifies a fragmentation and reassembly mechanism that is used to support the IPv6 MTU requirement over the LPWAN technologies. The Fragmentation is needed for IPv6 datagrams that, after SCHC compression or when it has not been possible to apply such compression, still exceed the layer two maximum payload size.</p>
<p>The SCHC header compression mechanism is independent of the specific LPWAN technology over which it will be used. Note that this document defines generic functionalities and advisedly offers flexibility with regard to parameters settings and mechanism choices, that are expected to be made in other technology-specific documents.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on November 30, 2018.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">LPWAN Architecture</a>
</li>
<li>3.   <a href="#rfc.section.3">Terminology</a>
</li>
<li>4.   <a href="#rfc.section.4">SCHC overview</a>
</li>
<li>5.   <a href="#rfc.section.5">Rule ID</a>
</li>
<li>6.   <a href="#rfc.section.6">Static Context Header Compression</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">SCHC C/D Rules</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Rule ID for SCHC C/D</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Packet processing</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Matching operators</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Compression Decompression Actions (CDA)</a>
</li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">not-sent CDA</a>
</li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">value-sent CDA</a>
</li>
<li>6.5.3.   <a href="#rfc.section.6.5.3">mapping-sent CDA</a>
</li>
<li>6.5.4.   <a href="#rfc.section.6.5.4">LSB CDA</a>
</li>
<li>6.5.5.   <a href="#rfc.section.6.5.5">DEViid, APPiid CDA</a>
</li>
<li>6.5.6.   <a href="#rfc.section.6.5.6">Compute-*</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">Fragmentation</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Overview</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Fragmentation Tools</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Reliability modes</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Fragmentation Formats</a>
</li>
<ul><li>7.4.1.   <a href="#rfc.section.7.4.1">Fragment format</a>
</li>
<li>7.4.2.   <a href="#rfc.section.7.4.2">All-1 and All-0 formats</a>
</li>
<li>7.4.3.   <a href="#rfc.section.7.4.3">SCHC ACK format</a>
</li>
<li>7.4.4.   <a href="#rfc.section.7.4.4">Abort formats</a>
</li>
</ul><li>7.5.   <a href="#rfc.section.7.5">Baseline mechanism</a>
</li>
<ul><li>7.5.1.   <a href="#rfc.section.7.5.1">No-ACK</a>
</li>
<li>7.5.2.   <a href="#rfc.section.7.5.2">ACK-Always</a>
</li>
<li>7.5.3.   <a href="#rfc.section.7.5.3">ACK-on-Error</a>
</li>
</ul><li>7.6.   <a href="#rfc.section.7.6">Supporting multiple window sizes</a>
</li>
<li>7.7.   <a href="#rfc.section.7.7">Downlink SCHC Fragment transmission</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Padding management</a>
</li>
<li>9.   <a href="#rfc.section.9">SCHC Compression for IPv6 and UDP headers</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">IPv6 version field</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">IPv6 Traffic class field</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Flow label field</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Payload Length field</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Next Header field</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">Hop Limit field</a>
</li>
<li>9.7.   <a href="#rfc.section.9.7">IPv6 addresses fields</a>
</li>
<ul><li>9.7.1.   <a href="#rfc.section.9.7.1">IPv6 source and destination prefixes</a>
</li>
<li>9.7.2.   <a href="#rfc.section.9.7.2">IPv6 source and destination IID</a>
</li>
</ul><li>9.8.   <a href="#rfc.section.9.8">IPv6 extensions</a>
</li>
<li>9.9.   <a href="#rfc.section.9.9">UDP source and destination port</a>
</li>
<li>9.10.   <a href="#rfc.section.9.10">UDP length field</a>
</li>
<li>9.11.   <a href="#rfc.section.9.11">UDP Checksum field</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">Security considerations</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Security considerations for header compression</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">Security considerations for SCHC Fragmentation/Reassembly</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">Acknowledgements</a>
</li>
<li>12.   <a href="#rfc.references">References</a>
</li>
<ul><li>12.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>12.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">SCHC Compression Examples</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Fragmentation Examples</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Fragmentation State Machines</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">SCHC Parameters - Ticket #15</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Note</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This document defines a header compression scheme and fragmentation functionality, both specially tailored for Low Power Wide Area Networks (LPWAN).</p>
<p id="rfc.section.1.p.2">Header compression is needed to efficiently bring Internet connectivity to the node within an LPWAN network. Some LPWAN networks properties can be exploited to get an efficient header compression:</p>
<p></p>

<ul>
<li>The topology is star-oriented which means that all packets follow the same path. For the necessity of this draft, the architecture is simple and is described as Devices (Dev) exchanging information with LPWAN Application Servers (App) through Network Gateways (NGW).</li>
<li>The traffic flows can be known in advance since devices embed built-in applications. New applications cannot be easily installed in LPWAN devices, as they would in computers or smartphones.</li>
</ul>
<p id="rfc.section.1.p.4">The Static Context Header Compression (SCHC) is defined for this environment. SCHC uses a context, where header information is kept in the header format order. This context is static: the values of the header fields do not change over time. This avoids complex resynchronization mechanisms, that would be incompatible with LPWAN characteristics. In most cases, a small context identifier is enough to represent the full IPv6/UDP headers. The SCHC header compression mechanism is independent of the specific LPWAN technology over which it is used.</p>
<p id="rfc.section.1.p.5">LPWAN technologies impose some strict limitations on traffic. For instance, devices are sleeping most of the time and MAY receive data during short periods of time after transmission to preserve battery. LPWAN technologies are also characterized, among others, by a very reduced data unit and/or payload size <a href="#I-D.ietf-lpwan-overview" class="xref">[I-D.ietf-lpwan-overview]</a>.  However, some of these technologies do not provide fragmentation functionality, therefore the only option for them to support the IPv6 MTU requirement of 1280bytes <a href="#RFC2460" class="xref">[RFC2460]</a> is to use a fragmentation protocol at the adaptation layer, below IPv6.  In response to this need, this document also defines a fragmentation/reassembly mechanism, which supports the IPv6 MTU requirement over LPWAN technologies. Such functionality has been designed under the assumption that data unit out-of-sequence delivery will not happen between the entity performing fragmentation and the entity performing reassembly.</p>
<p id="rfc.section.1.p.6">Note that this document defines generic functionality and purposefully offers flexibility with regard to parameter settings and mechanism choices, that are expected to be made in other, technology-specific documents.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#LPWAN-Archi" id="LPWAN-Archi">LPWAN Architecture</a>
</h1>
<p id="rfc.section.2.p.1">LPWAN technologies have similar network architectures but different terminology. We can identify different types of entities in a typical LPWAN network, see <a href="#Fig-LPWANarchi" class="xref">Figure 1</a>:</p>
<p id="rfc.section.2.p.2">o  Devices (Dev) are the end-devices or hosts (e.g. sensors, actuators, etc.). There can be a very high density of devices per radio gateway.</p>
<p id="rfc.section.2.p.3">o  The Radio Gateway (RGW), which is the end point of the constrained link.</p>
<p id="rfc.section.2.p.4">o  The Network Gateway (NGW) is the interconnection node between the Radio Gateway and the Internet.</p>
<p id="rfc.section.2.p.5">o  LPWAN-AAA Server, which controls the user authentication and the applications.</p>
<p id="rfc.section.2.p.6">o  Application Server (App)</p>
<div id="rfc.figure.1"></div>
<div id="Fig-LPWANarchi"></div>
<pre>
                                           +------+
 ()   ()   ()       |                      |LPWAN-|
  ()  () () ()     / \       +---------+   | AAA  |
() () () () () () /   \======|    ^    |===|Server|  +-----------+
 ()  ()   ()     |           | &lt;--|--&gt; |   +------+  |APPLICATION|
()  ()  ()  ()  / \==========|    v    |=============|   (App)   |
  ()  ()  ()   /   \         +---------+             +-----------+
 Dev        Radio Gateways         NGW

</pre>
<p class="figure">Figure 1: LPWAN Architecture</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.3.p.1">This section defines the terminology and acronyms used in this document.</p>
<p></p>

<ul>
<li>Abort. A SCHC Fragment format to signal the other end-point that the on-going fragment transmission is stopped and finished.</li>
<li>All-0. The SCHC Fragment format for the last frame of a window that is not the last one of a packet (see Window in this glossary).</li>
<li>All-1. The SCHC Fragment format for the last frame of the packet.</li>
<li>All-0 empty. An All-0 SCHC Fragment without payload. It is used to request the SCHC ACK with the encoded Bitmap when the Retransmission Timer expires, in a window that is not the last one of a packet.</li>
<li>All-1 empty. An All-1 SCHC Fragment without payload. It is used to request the SCHC ACK with the encoded Bitmap when the Retransmission Timer expires in the last window of a packet.</li>
<li>App: LPWAN Application. An application sending/receiving IPv6 packets to/from the Device.</li>
<li>APP-IID: Application Interface Identifier. Second part of the IPv6 address that identifies the application server interface.</li>
<li>Bi: Bidirectional, a rule entry that applies to headers of packets travelling in both directions (Up and Dw).</li>
<li>Bitmap: a field of bits in an acknowledgment message that tells the sender which SCHC Fragments of a window were correctl received.</li>
<li>C: Checked bit. Used in an acknowledgment (SCHC ACK) header to determine if the MIC locally computed by the receiver matches (1) the received MIC or not (0).</li>
<li>CDA: Compression/Decompression Action. Describes the reciprocal pair of actions that are performed at the compressor to compress a header field and at the decompressor to recover the original header field value.</li>
<li>Compression Residue. The bits that need to be sent after applying the SCHC compression over each header field</li>
<li>Context: A set of rules used to compress/decompress headers.</li>
<li>Dev: Device. A node connected to the LPWAN. A Dev SHOULD implement SCHC.</li>
<li>Dev-IID: Device Interface Identifier. Second part of the IPv6 address that identifies the device interface.</li>
<li>DI: Direction Indicator. This field tells which direction of packet travel (Up, Dw or Bi) a rule applies to. This allows for assymmetric processing.</li>
<li>DTag: Datagram Tag. This SCHC F/R header field is set to the same value for all SCHC Fragments carrying the same IPv6 datagram.</li>
<li>Dw: Downlink direction for compression/decompression in both sides, from SCHC C/D in the network to SCHC C/D in the Dev.</li>
<li>FCN: Fragment Compressed Number. This SCHC F/R header field carries an efficient representation of a larger-sized fragment number.</li>
<li>Field Description. A line in the Rule Table.</li>
<li>FID: Field Identifier. This is an index to describe the header fields in a Rule.</li>
<li>FL: Field Length is the length of the field in bits for fixed values or a type (variable, token length, &#8230;) for length unknown at the rule creation. The length of a header field is defined in the specific protocol standard.</li>
<li>FP: Field Position is a value that is used to identify the position where each instance of a field appears in the header.</li>
<li>IID: Interface Identifier. See the IPv6 addressing architecture <a href="#RFC7136" class="xref">[RFC7136]</a>
</li>
<li>Inactivity Timer. A timer used after receiving a SCHC Fragment to detect when there is an error and there is no possibility to continue an on-going SCHC Fragmented packet transmission.</li>
<li>L2: Layer two. The immediate lower layer SCHC interfaces with. It is provided by an underlying LPWAN technology.</li>
<li>MIC: Message Integrity Check.  A SCHC F/R header field computed over an IPv6 packet before fragmentation, used for error detection after IPv6 packet reassembly.</li>
<li>MO: Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.</li>
<li>Retransmission Timer. A timer used by the SCHC Fragment sender during an on-going SCHC Fragmented packet transmission to detect possible link errors when waiting for a possible incoming SCHC ACK.</li>
<li>Rule: A set of header field values.</li>
<li>Rule entry: A column in the rule that describes a parameter of the header field.</li>
<li>Rule ID: An identifier for a rule, SCHC C/D in both sides share the same Rule ID for a specific packet. A set of Rule IDs are used to support SCHC F/R functionality.</li>
<li>SCHC ACK: A SCHC acknowledgement for fragmentation, this format used to report the success or unsuccess reception of a set of SCHC Fragments. See <a href="#Frag" class="xref">Section 7</a> for more details.</li>
<li>SCHC C/D: Static Context Header Compression Compressor/Decompressor. A mechanism used in both sides, at the Dev and at the network to achieve Compression/Decompression of headers. SCHC C/D uses SCHC rules to perform compression and decompression.</li>
<li>SCHC F/R: Static Context Header Compression Fragmentation/Reassembly. A protocol used in both sides, at the Dev and at the network to achieve Fragmentation/Reassembly of fragments. SCHC F/R has three reliability modes.</li>
<li>SCHC Fragment: A data unit that carries a subset of a SCHC Packet. SCHC F/R is needed when the size of a SCHC packet exceeds the available payload size of the underlying L2 technology data unit. See <a href="#Frag" class="xref">Section 7</a>.</li>
<li>SCHC Packet: A packet (e.g. an IPv6 packet) whose header has been compressed as per the header compression mechanism defined in this document. If the header compression process is unable to actually compress the packet header, the packet with the uncompressed header is still called a SCHC Packet (in this case, a Rule ID is used to indicate that the packet header has not been compressed). See <a href="#SCHComp" class="xref">Section 6</a> for more details.</li>
<li>TV: Target value. A value contained in the Rule that will be matched with the value of a header field.</li>
<li>Up: Uplink direction for compression/decompression in both sides, from the Dev SCHC C/D to the network SCHC C/D.</li>
<li>W: Window bit. A SCHC Fragment header field used in Window mode <a href="#Frag" class="xref">Section 7</a>, which carries the same value for all SCHC Fragments of a window.</li>
<li>Window: A subset of the SCHC Fragments needed to carry a packet <a href="#Frag" class="xref">Section 7</a>.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#schc-overview" id="schc-overview">SCHC overview</a>
</h1>
<p id="rfc.section.4.p.1">SCHC can be abstracted as an adaptation layer between IPv6 and the underlying LPWAN technology. SCHC comprises two sublayers (i.e. the Compression sublayer and the Fragmentation sublayer), as shown in <a href="#Fig-IntroLayers" class="xref">Figure 2</a>.</p>
<div id="rfc.figure.2"></div>
<div id="Fig-IntroLayers"></div>
<pre>
             +----------------+
             |      IPv6      |
          +- +----------------+            
          |  |   Compression  |  
    SCHC &lt;   +----------------+   
          |  |  Fragmentation |
          +- +----------------+         
             |LPWAN technology|
             +----------------+

</pre>
<p class="figure">Figure 2: Protocol stack comprising IPv6, SCHC and an LPWAN technology</p>
<p id="rfc.section.4.p.2">As per this document, when a packet (e.g. an IPv6 packet) needs to be transmitted, header compression is first applied to the packet. The resulting packet after header compression (whose header may or may not actually be smaller than that of the original packet) is called a SCHC Packet. If the SCHC Packet size exceeds the layer 2 (L2) MTU, fragmentation is then applied to the SCHC Packet. The SCHC Packet or the SCHC Fragments are then transmitted over the LPWAN. The reciprocal operations take place at the receiver. This process is illustrated in <a href="#Fig-Operations" class="xref">Figure 3</a>.</p>
<div id="rfc.figure.3"></div>
<div id="Fig-Operations"></div>
<pre>
A packet (e.g. an IPv6 packet) 
           |                                           ^ 
           v                                           | 
  +&#8212;-----------------+                      +--------------------+ 
  | SCHC Compression |                      | SCHC Decompression | 
  +------------------+                      +--------------------+ 
           |                                           | 
           |   If no fragmentation (*)                 | 
           +----------------- SCHC Packet ------------&gt;| 
           |                                           | 
 +--------------------+                       +-----------------+ 
 | SCHC Fragmentation |                       | SCHC Reassembly | 
 +--------------------+                       +-----------------+ 
        ^     |                                    ^     |
        |     |                                    |     |
        |     +---------- SCHC Fragments ----------+     |
        +-------------- SCHC ACK ------------------------+
SENDER                                                RECEIVER

*: see Section 7 to define the use of Fragmentation and the 
         technology-specific documents for the L2 decision.

</pre>
<p class="figure">Figure 3: SCHC operations taking place at the sender and the receiver</p>
<p id="rfc.section.4.p.3">The SCHC Packet is composed of the Compressed Header followed by the payload from the original packet (see <a href="#Fig-SCHCpckt" class="xref">Figure 4</a>).  The Compressed Header itself is composed of a Rule ID and a Compression Residue. The Compression Residue may be absent, see <a href="#SCHComp" class="xref">Section 6</a>. Both the Rule ID and the Compression Residue potentially have a variable size, and generally are not a mutiple of bytes in size.</p>
<div id="rfc.figure.4"></div>
<div id="Fig-SCHCpckt"></div>
<pre>
|  Rule ID +  Compression Residue |
+---------------------------------+--------------------+ 
|      Compressed Header          |      Payload       |
+---------------------------------+--------------------+

</pre>
<p class="figure">Figure 4: SCHC Packet</p>
<p id="rfc.section.4.p.4">The Fragment Header size is variable and depends on the Fragmentation parameters. The Fragment payload may contain: part of the SCHC Packet or Payload or both and its size depends on the L2 data unit, see <a href="#Frag" class="xref">Section 7</a>. The SCHC Fragment has the following format:</p>
<div id="rfc.figure.5"></div>
<div id="Fig-SCHCfragment"></div>
<pre>
| Rule ID + DTAG + W + FCN [+ MIC ] |   Partial  SCHC Packet  |
+-----------------------------------+-------------------------+ 
|        Fragment Header            |   Fragment  Payload     |
+-----------------------------------+-------------------------+

</pre>
<p class="figure">Figure 5: SCHC Fragment</p>
<p id="rfc.section.4.p.5">The SCHC ACK is byte aligned and the ACK Header and the encoded Bitmap both have variable size. The SCHC ACK is used only in Fragmentation and has the following format:</p>
<div id="rfc.figure.6"></div>
<div id="Fig-SCHCack"></div>
<pre>
|Rule ID + DTag + W|             
+------------------+-------- ... ---------+
|    ACK Header    |    encoded Bitmap    |
+------------------+-------- ... ---------+

</pre>
<p class="figure">Figure 6: SCHC ACK</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#rule-id" id="rule-id">Rule ID</a>
</h1>
<p id="rfc.section.5.p.1">Rule ID are identifiers used to select either the correct context to be used for Compression/Decompression functionalities or for Fragmentation/Reassembly or after trying to do SCHC C/D and SCHC F/R the packet is sent as is. The size of the Rule ID is not specified in this document, as it is implementation-specific and can vary according to the LPWAN technology and the number of Rules, among others.</p>
<p id="rfc.section.5.p.2">The Rule IDs identifiers are used:</p>
<p></p>

<ul>
<li>In the SCHC C/D context to keep the Field Description of the header packet.</li>
<li>In SCHC F/R to identify the specific modes and settings. In bidirectional SCHC F/R at least two Rules ID are needed.</li>
<li>To identify the SCHC ACK in SCHC F/R</li>
<li>And at least one Rule ID MAY be reserved to the case where no SCHC C/D nor SCHC F/R were possible.</li>
</ul>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#SCHComp" id="SCHComp">Static Context Header Compression</a>
</h1>
<p id="rfc.section.6.p.1">In order to perform header compression, this document defines a mechanism called Static Context Header Compression (SCHC), which is based on using context, i.e. a set of rules to compress or decompress headers. SCHC avoids context synchronization, which is the most bandwidth-consuming operation in other header compression mechanisms such as RoHC <a href="#RFC5795" class="xref">[RFC5795]</a>. Since the nature of packets are highly predictable in LPWAN networks, static contexts MAY be stored beforehand to omit transmitting some information over the air. The contexts MUST be stored at both ends, and they can either be learned by a provisioning protocol, by out of band means, or they can be pre-provisioned. The way the contexts are provisioned on both ends is out of the scope of this document.</p>
<div id="rfc.figure.7"></div>
<div id="Fig-archi"></div>
<pre>
     Dev                                                 App
+----------------+                                  +--------------+
| APP1 APP2 APP3 |                                  |APP1 APP2 APP3|
|                |                                  |              |
|       UDP      |                                  |     UDP      |
|      IPv6      |                                  |    IPv6      |   
|                |                                  |              |  
|SCHC Comp / Frag|                                  |              |  
+--------+-------+                                  +-------+------+
         |   +--+     +----+     +-----------+              .
         +~~ |RG| === |NGW | === |   SCHC    |... Internet ..
             +--+     +----+     |Comp / Frag|
                                 +-----------+
</pre>
<p class="figure">Figure 7: Architecture</p>
<p><a href="#Fig-archi" class="xref">Figure 7</a> The figure represents the architecture for SCHC (Static Context Header Compression) Compression/Fragmentation where SCHC C/D (Compressor/Decompressor) and SCHC F/R (Fragmentation/Reassembly) are performed. It is based on {{I-D.ietf- lpwan-overview}} terminology.  SCHC Compression/Fragmentation is located on both sides of the transmission in the Dev and in the Network side. In the Uplink direction, the Device application packets use IPv6 or IPv6/UDP protocols. Before sending these packets, the Dev compresses their headers using SCHC C/D and if the SCHC Packet resulting from the compression exceeds the maximum payload size of the underlying LPWAN technology, SCHC F/R is performed, see <a href="#Frag" class="xref">Section 7</a>. The resulting SCHC Fragments are sent as one or more L2 frames to an LPWAN Radio Gateway (RG) which forwards the frame(s) to a Network Gateway (NGW).</p>
<p id="rfc.section.6.p.3">The NGW sends the data to a SCHC F/R and then to the SCHC C/D for decompression. The SCHC C/D in the Network side can be located in the Network Gateway (NGW) or somewhere else as long as a tunnel is established between the NGW and the SCHC Compression/Fragmentation. Note that, for some LPWAN technologies, it MAY be suitable to locate SCHC Fragmentation/Reassembly functionality nearer the NGW, in order to better deal with time constraints of such technologies.  The SCHC C/Ds on both sides MUST share the same set of Rules. After decompression, the packet can be sent over the Internet to one or several LPWAN Application Servers (App).</p>
<p id="rfc.section.6.p.4">The SCHC Compression/Fragmentation process is symmetrical, therefore the same description applies to the reverse direction.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#schc-cd-rules" id="schc-cd-rules">SCHC C/D Rules</a>
</h1>
<p id="rfc.section.6.1.p.1">The main idea of the SCHC compression scheme is to transmit the Rule ID to the other end instead of sending known field values. This Rule ID identifies a rule that provides the closest match to the original packet values. Hence, when a value is known by both ends, it is only necessary to send the corresponding Rule ID over the LPWAN network.  How Rules are generated is out of the scope of this document. The rule MAY be changed but it will be specified in another document.</p>
<p id="rfc.section.6.1.p.2">The context contains a list of rules (cf. <a href="#Fig-ctxt" class="xref">Figure 8</a>). Each Rule contains itself a list of Fields Descriptions composed of a field identifier (FID), a field length (FL), a field position (FP), a direction indicator (DI), a target value (TV), a matching operator (MO) and a Compression/Decompression Action (CDA).</p>
<div id="rfc.figure.8"></div>
<div id="Fig-ctxt"></div>
<pre>
  /-----------------------------------------------------------------\
  |                         Rule N                                  |
 /-----------------------------------------------------------------\|
 |                       Rule i                                    ||
/-----------------------------------------------------------------\||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |
\-----------------------------------------------------------------/

</pre>
<p class="figure">Figure 8: Compression/Decompression Context</p>
<p id="rfc.section.6.1.p.3">The Rule does not describe how to delineate each field in the original packet header. This MUST be known from the compressor/decompressor. The rule only describes the compression/decompression behavior for each header field. In the rule, the Fields Descriptions are listed in the order in which the fields appear in the packet header.</p>
<p id="rfc.section.6.1.p.4">The Rule also describes the Compression Residue sent regarding the order of the Fields Descriptions in the Rule.</p>
<p id="rfc.section.6.1.p.5">The Context describes the header fields and its values with the following entries:</p>
<p></p>

<ul>
<li>Field ID (FID) is a unique value to define the header field.</li>
<li>Field Length (FL) represents the length of the field. It can be either a fixed value (in bits) if the length is known when the rule is created or a type if the length is variable. The length of a header field is defined in the specific protocol standard. The type defines the process to compute length, its unit (bits, bytes,&#8230;) and the value to be sent before the compression residue.</li>
<li>Field Position (FP): indicating if several instances of a field exist in the headers which one is targeted. The default position is 1.</li>
<li>A direction indicator (DI) indicates the packet direction(s) this Field Description applies to. Three values are possible:  <ul>
<li>UPLINK (Up): this Field Description is only applicable to packets sent by the Dev to the App,</li>
<li>DOWNLINK (Dw): this Field Description is only applicable to packets sent from the App to the Dev,</li>
<li>BIDIRECTIONAL (Bi): this Field Description is applicable to packets travelling both Up and Dw.</li>
</ul>
</li>
<li>Target Value (TV) is the value used to make the match with the packet header field. The Target Value can be of any type (integer, strings, etc.). For instance, it can be a single value or a more complex structure (array, list, etc.), such as a JSON or a CBOR structure.</li>
<li>Matching Operator (MO) is the operator used to match the Field Value and the Target Value. The Matching Operator may require some parameters. MO is only used during the compression phase. The set of MOs defined in this document can be found in <a href="#chap-MO" class="xref">Section 6.4</a>.</li>
<li>Compression Decompression Action (CDA) describes the compression and decompression processes to be performed after the MO is applied. The CDA MAY require some parameters to be processed. CDAs are used in both the compression and the decompression functions. The set of CDAs defined in this document can be found in <a href="#chap-CDA" class="xref">Section 6.5</a>.</li>
</ul>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#IDComp" id="IDComp">Rule ID for SCHC C/D</a>
</h1>
<p id="rfc.section.6.2.p.1">Rule IDs are sent by the compression function in one side and are received for the decompression function in the other side.  In SCHC C/D, the Rule IDs are specific to a Dev. Hence, multiple Dev instances MAY use the same Rule ID to define different header compression contexts. To identify the correct Rule ID, the SCHC C/D needs to correlate the Rule ID with the Dev identifier to find the appropriate Rule to be applied.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#packet-processing" id="packet-processing">Packet processing</a>
</h1>
<p id="rfc.section.6.3.p.1">The compression/decompression process follows several steps:</p>
<p></p>

<ul>
<li>Compression Rule selection: The goal is to identify which Rule(s) will be used to compress the packet&#8217;s headers. When doing decompression, in the network side the SCHC C/D needs to find the correct Rule based on the L2 address and in this way, it can use the Dev-ID and the Rule-ID. In the Dev side, only the Rule ID is needed to identify the correct Rule since the Dev only holds Rules that apply to itself. The Rule will be selected by matching the Fields Descriptions to the packet header as described below. When the selection of a Rule is done, this Rule is used to compress the header. The detailed steps for compression Rule selection are the following:  <ul>
<li>The first step is to choose the Fields Descriptions by their direction, using the direction indicator (DI). A Field Description that does not correspond to the appropriate DI will be ignored, if all the fields of the packet do not have a Field Description with the correct DI the Rule is discarded and SCHC C/D proceeds to explore the next Rule.</li>
<li>When the DI has matched, then the next step is to identify the fields according to Field Position (FP). If the Field Position does not correspond, the Rule is not used and the SCHC C/D proceeds to consider the next Rule.</li>
<li>Once the DI and the FP correspond to the header information, each field&#8217;s value of the packet is then compared to the corresponding Target Value (TV) stored in the Rule for that specific field using the matching operator (MO).      <br><br> If all the fields in the packet&#8217;s header satisfy all the matching operators (MO) of a Rule (i.e. all MO results are True), the fields of the header are then compressed according to the Compression/Decompression Actions (CDAs) and a compressed header (with possibly a Compression Residue) SHOULD be obtained. Otherwise, the next Rule is tested.</li>
<li>If no eligible Rule is found, then the header MUST be sent without compression, depending on the L2 PDU size, this is one of the case that MAY require the use of the SCHC F/R process.</li>
</ul>
</li>
<li>Sending: If an eligible Rule is found, the Rule ID is sent to the other end followed by the Compression Residue (which could be empty) and directly followed by the payload. The Compression Residue is the concatenation of the Compression Residues for each field according to the CDAs for that rule. The way the Rule ID is sent depends on the specific LPWAN layer two technology. For example, it can be either included in a Layer 2 header or sent in the first byte of the L2 payload. (Cf. <a href="#Fig-FormatPckt" class="xref">Figure 9</a>). This process will be specified in the LPWAN technology-specific document and is out of the scope of the present document. On LPWAN technologies that are byte-oriented, the compressed header concatenated with the original packet payload is padded to a multiple of 8 bits, if needed. See <a href="#Padding" class="xref">Section 8</a> for details.</li>
<li>Decompression: When doing decompression, in the network side the SCHC C/D needs to find the correct Rule based on the L2 address and in this way, it can use the Dev-ID and the Rule-ID. In the Dev side, only the Rule ID is needed to identify the correct Rule since the Dev only holds Rules that apply to itself.  <br><br> The receiver identifies the sender through its device-id (e.g. MAC address, if exists) and selects the appropriate Rule from the Rule ID. If a source identifier is present in the L2 technology, it is used to select the Rule ID. This Rule describes the compressed header format and associates the values to the header fields.  The receiver applies the CDA action to reconstruct the original header fields. The CDA application order can be different from the order given by the Rule. For instance, Compute-* SHOULD be applied at the end, after all the other CDAs.</li>
</ul>
<div id="rfc.figure.9"></div>
<div id="Fig-FormatPckt"></div>
<pre>
+--- ... --+------- ... -------+------------------+~~~~~~~
|  Rule ID |Compression Residue|  packet payload  |padding
+--- ... --+------- ... -------+------------------+~~~~~~~
                                                   (optional)
|----- compressed header ------|

</pre>
<p class="figure">Figure 9: SCHC C/D Packet Format</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#chap-MO" id="chap-MO">Matching operators</a>
</h1>
<p id="rfc.section.6.4.p.1">Matching Operators (MOs) are functions used by both SCHC C/D endpoints involved in the header compression/decompression. They are not typed and can be indifferently applied to integer, string or any other data type. The result of the operation can either be True or False. MOs are defined as follows:</p>
<p></p>

<ul>
<li>equal: The match result is True if a field value in a packet and the value in the TV are equal.</li>
<li>ignore: No check is done between a field value in a packet and a TV in the Rule. The result of the matching is always true.</li>
<li>MSB(x): A match is obtained if the most significant x bits of the field value in the header packet are equal to the TV in the Rule. The x parameter of the MSB Matching Operator indicates how many bits are involved in the comparison. If the FL is described as variable, the length must be a multiple of the unit. For example, x must be multiple of 8 if the unit of the variable length is in bytes.</li>
<li>match-mapping: With match-mapping, the Target Value is a list of values. Each value of the list is identified by a short ID (or index). Compression is achieved by sending the index instead of the original header field value. This operator matches if the header field value is equal to one of the values in the target list.</li>
</ul>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#chap-CDA" id="chap-CDA">Compression Decompression Actions (CDA)</a>
</h1>
<p id="rfc.section.6.5.p.1">The Compression Decompression Action (CDA) describes the actions taken during the compression of headers fields, and inversely, the action taken by the decompressor to restore the original value.</p>
<div id="rfc.figure.10"></div>
<div id="Fig-function"></div>
<pre>
/--------------------+-------------+----------------------------\
|  Action            | Compression | Decompression              |
|                    |             |                            |
+--------------------+-------------+----------------------------+
|not-sent            |elided       |use value stored in ctxt    |
|value-sent          |send         |build from received value   |
|mapping-sent        |send index   |value from index on a table |
|LSB                 |send LSB     |TV, received value          |
|compute-length      |elided       |compute length              |
|compute-checksum    |elided       |compute UDP checksum        |
|Deviid              |elided       |build IID from L2 Dev addr  |
|Appiid              |elided       |build IID from L2 App addr  |
\--------------------+-------------+----------------------------/
y=size of the transmitted bits

</pre>
<p class="figure">Figure 10: Compression and Decompression Functions</p>
<p><a href="#Fig-function" class="xref">Figure 10</a> summarizes the basic functions that can be used to compress and decompress a field. The first column lists the actions name. The second and third columns outline the reciprocal compression/decompression behavior for each action.</p>
<p id="rfc.section.6.5.p.3">Compression is done in order that Fields Descriptions appear in the Rule. The result of each Compression/Decompression Action is appended to the working Compression Residue in that same order. The receiver knows the size of each compressed field which can be given by the rule or MAY be sent with the compressed header.</p>
<p id="rfc.section.6.5.p.4">If the field is identified as being variable in the Field Description, then the size of the Compression Residue value (using the unit defined in the FL) MUST be sent first using the following coding:</p>
<p></p>

<ul>
<li>If the size is between 0 and 14, it is sent as a 4-bits integer.</li>
<li>For values between 15 and 254, the first 4 bits sent are set to 1 and the size is sent using 8 bits integer.</li>
<li>For higher values of size, the first 12 bits are set to 1 and the next two bytes contain the size value as a 16 bits integer.</li>
<li>If a field does not exist in the packet but in the Rule and its FL is variable, the size zero MUST be used.</li>
</ul>
<h1 id="rfc.section.6.5.1">
<a href="#rfc.section.6.5.1">6.5.1.</a> <a href="#not-sent-cda" id="not-sent-cda">not-sent CDA</a>
</h1>
<p id="rfc.section.6.5.1.p.1">The not-sent function is generally used when the field value is specified in the Rule and therefore known by both the Compressor and the Decompressor. This action is generally used with the &#8220;equal&#8221; MO. If MO is &#8220;ignore&#8221;, there is a risk to have a decompressed field value different from the compressed field.</p>
<p id="rfc.section.6.5.1.p.2">The compressor does not send any Compression Residue for a field on which not-sent compression is applied.</p>
<p id="rfc.section.6.5.1.p.3">The decompressor restores the field value with the Target Value stored in the matched Rule identified by the received Rule ID.</p>
<h1 id="rfc.section.6.5.2">
<a href="#rfc.section.6.5.2">6.5.2.</a> <a href="#value-sent-cda" id="value-sent-cda">value-sent CDA</a>
</h1>
<p id="rfc.section.6.5.2.p.1">The value-sent action is generally used when the field value is not known by both Compressor and Decompressor. The value is sent in the compressed message header. Both Compressor and Decompressor MUST know the size of the field, either implicitly (the size is known by both sides) or by explicitly indicating the length in the Compression Residue, as defined in <a href="#chap-CDA" class="xref">Section 6.5</a>. This function is generally used with the &#8220;ignore&#8221; MO.</p>
<h1 id="rfc.section.6.5.3">
<a href="#rfc.section.6.5.3">6.5.3.</a> <a href="#mapping-sent-cda" id="mapping-sent-cda">mapping-sent CDA</a>
</h1>
<p id="rfc.section.6.5.3.p.1">The mapping-sent is used to send a smaller index (the index into the Target Value list of values) instead of the original value. This function is used together with the &#8220;match-mapping&#8221; MO.</p>
<p id="rfc.section.6.5.3.p.2">On the compressor side, the match-mapping Matching Operator searches the TV for a match with the header field value and the mapping-sent CDA appends the corresponding index to the Compression Residue to be sent.  On the decompressor side, the CDA uses the received index to restore the field value by looking up the list in the TV.</p>
<p id="rfc.section.6.5.3.p.3">The number of bits sent is the minimal size for coding all the possible indices.</p>
<h1 id="rfc.section.6.5.4">
<a href="#rfc.section.6.5.4">6.5.4.</a> <a href="#lsb-cda" id="lsb-cda">LSB CDA</a>
</h1>
<p id="rfc.section.6.5.4.p.1">The LSB action is used together with the &#8220;MSB(x)&#8221; MO to avoid sending the higher part of the packet field if that part is already known by the receiving end. A length can be specified in the rule to indicate how many bits have to be sent. If the length is not specified, the number of bits sent is the original header field length minus the length specified in the MSB(x) MO.</p>
<p id="rfc.section.6.5.4.p.2">The compressor sends the Least Significant Bits (e.g. LSB of the length field). The decompressor combines the value received with the Target Value depending on the field type.</p>
<p id="rfc.section.6.5.4.p.3">If this action needs to be done on a variable length field, the size of the Compression Residue in bytes MUST be sent as described in <a href="#chap-CDA" class="xref">Section 6.5</a>.</p>
<h1 id="rfc.section.6.5.5">
<a href="#rfc.section.6.5.5">6.5.5.</a> <a href="#deviid-appiid-cda" id="deviid-appiid-cda">DEViid, APPiid CDA</a>
</h1>
<p id="rfc.section.6.5.5.p.1">These functions are used to process respectively the Dev and the App Interface Identifiers (Deviid and Appiid) of the IPv6 addresses. Appiid CDA is less common since current LPWAN technologies frames contain a single address, which is the Dev&#8217;s address.</p>
<p id="rfc.section.6.5.5.p.2">The IID value MAY be computed from the Device ID present in the Layer 2 header, or from some other stable identifier. The computation is specific for each LPWAN technology and MAY depend on the Device ID size.</p>
<p id="rfc.section.6.5.5.p.3">In the Downlink direction, these Deviid CDA is used to determine the L2 addresses used by the LPWAN.</p>
<h1 id="rfc.section.6.5.6">
<a href="#rfc.section.6.5.6">6.5.6.</a> <a href="#compute-" id="compute-">Compute-*</a>
</h1>
<p id="rfc.section.6.5.6.p.1">Some fields are elided during compression and reconstructed during decompression. This is the case for length and Checksum, so:</p>
<p></p>

<ul>
<li>compute-length: computes the length assigned to this field. This CDA MAY be used to compute IPv6 length or UDP length.</li>
<li>compute-checksum: computes a checksum from the information already received by the SCHC C/D. This field MAY be used to compute UDP checksum.</li>
</ul>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#Frag" id="Frag">Fragmentation</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.7.1.p.1">In LPWAN technologies, the L2 data unit size typically varies from tens to hundreds of bytes. The SCHC F/R (Fragmentation /Reassembly) MAY be used either because after applying SCHC C/D or when SCHC C/D is not possible the entire SCHC Packet still exceeds the L2 data unit.</p>
<p id="rfc.section.7.1.p.2">The SCHC F/R functionality defined in this document has been designed under the assumption that data unit out-of-sequence delivery will not happen between the entity performing fragmentation and the entity performing reassembly. This assumption allows reducing the complexity and overhead of the SCHC F/R mechanism.</p>
<p id="rfc.section.7.1.p.3">To adapt the SCHC F/R to the capabilities of LPWAN technologies is required to enable optional SCHC Fragment retransmission and to allow a stepper delivery for the reliability of SCHC Fragments. This document does not make any decision with regard to which SCHC Fragment delivery reliability mode will be used over a specific LPWAN technology. These details will be defined in other technology-specific documents.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#fragmentation-tools" id="fragmentation-tools">Fragmentation Tools</a>
</h1>
<p id="rfc.section.7.2.p.1">This subsection describes the different tools that are used to enable the SCHC F/R functionality defined in this document, such as fields in the SCHC F/R header frames (see the related formats in <a href="#Fragfor" class="xref">Section 7.4</a>), and the different parameters supported in the reliability modes such as timers and parameters.</p>
<p></p>

<ul>
<li>Rule ID. The Rule ID is present in the SCHC Fragment header and in the SCHC ACK header format.  The Rule ID in a SCHC fragment header is used to identify that a SCHC Fragment is being carried, which SCHC F/R reliability mode is used and which window size is used. The Rule ID  in the SCHC F/R header also allows interleaving non-fragmented packets and SCHC Fragments that carry other SCHC Packets. The Rule ID in an SCHC ACK identifies the message as an SCHC ACK.</li>
<li>Fragment Compressed Number (FCN).  The FCN is included in all SCHC Fragments. This field can be understood as a truncated, efficient representation of a larger-sized fragment number, and does not carry an absolute SCHC Fragment number. There are two FCN reserved values that are used for controlling the SCHC F/R process, as described next:  <ul>
<li>The FCN value with all the bits equal to 1 (All-1) denotes the last SCHC Fragment of a packet. The last window of a packet is called an All-1 window.</li>
<li>The FCN value with all the bits equal to 0 (All-0) denotes the last SCHC Fragment of a window that is not the last one of the packet. Such a window is called an All-0 window.</li>
</ul>
<p> The rest of the FCN values are assigned in a sequentially decreasing order, which has the purpose to avoid possible ambiguity for the receiver that might arise under certain conditions. In the SCHC Fragments, this field is an unsigned integer, with a size of N bits. In the No-ACK mode, it is set to 1 bit (N=1), All-0 is used in all SCHC Fragments and All-1 for the last one.  For the other reliability modes, it is recommended to use a number of bits (N) equal to or greater than 3. Nevertheless, the appropriate value of N MUST be defined in the corresponding technology-specific profile documents. For windows that are not the last one from a SCHC Fragmented packet, the FCN for the last SCHC Fragment in such windows is an All-0. This indicates that the window is finished and communication proceeds according to the reliability mode in use. The FCN for the last SCHC Fragment in the last window is an All-1, indicating the last SCHC Fragment of the SCHC Packet. It is also important to note that, in the No-ACK mode or when N=1, the last SCHC Fragment of the packet will carry a FCN equal to 1, while all previous  SCHC Fragments will carry a FCN to 0. For further details see </p>
<a href="#FragModes" class="xref">Section 7.5</a>. The highest FCN in the window, denoted MAX_WIND_FCN, MUST be a value equal to or smaller than 2^N-2. (Example for N=5, MAX_WIND_FCN MAY be set to 23, then subsequent FCNs are set sequentially and in decreasing order, and the FCN will wrap from 0 back to 23).</li>
<li>Datagram Tag (DTag). The DTag field, if present, is set to the same value for all SCHC Fragments carrying the same SCHC packet. Using this field, the sender can interleave fragments fromdifferent SCHC Packets, while the receiver can still tell them apart.  In the SCHC Fragment formats, the size of the DTag field is T bits, which MAY be set to a value greater than or equal to 0 bits. For each new SCHC Packet processed by the sender, DTag MUST be sequentially increased, from 0 to 2^T &#8211; 1 wrapping back from 2^T - 1 to 0.  In the SCHC ACK format, DTag carries the same value as the DTag field in the SCHC Fragments for which this SCHC ACK is intended.  The length of DTag, denoted T is not given in this document because is technolgy dependant, and will be defined in the corresponding technology-documents. DTag is based on the number of simultaneous packets supported.</li>
<li>W (window): W is a 1-bit field. This field carries the same value for all SCHC Fragments of a window, and it is complemented for the next window. The initial value for this field is 0. In the SCHC ACK format, this field also has a size of 1 bit. In all SCHC ACKs, the W bit carries the same value as the W bit carried by the SCHC Fragments whose reception is being positively or negatively acknowledged by the SCHC ACK.</li>
<li>Message Integrity Check (MIC). This field is computed by the sender over the complete SCHC Packet and before SCHC fragmentation. The MIC allows the receiver to check errors in the reassembled packet, while it also enables compressing the UDP checksum by use of SCHC compression. The CRC32 as 0xEDB88320 (i.e. the reverse representation of the polynomial used e.g. in the Ethernet standard <a href="#RFC3385" class="xref">[RFC3385]</a>) is recommended as the default algorithm for computing the MIC. Nevertheless, other algorithms MAY be required and are defined in the technology-specific documents as well as the length in bits of the MIC used.</li>
<li>C (MIC checked): C is a 1-bit field. This field is used in the SCHC ACK packets to report the outcome of the MIC check, i.e. whether the reassembled packet was correctly received or not. A value of 1 represents a positive MIC check at the receiver side (i.e. the MIC computed by the receiver matches the received MIC).</li>
<li>Retransmission Timer. A SCHC Fragment sender uses it after the transmission of a window to detect a transmission error of the SCHC ACK corresponding to this window. Depending on the reliability mode, it will lead to a request an SCHC ACK retransmission (in ACK-Always mode) or it will trigger the transmission of the next window (in ACK-on-Error mode). The duration of this timer is not defined in this document and MUST be defined in the corresponding technology documents.</li>
<li>Inactivity Timer. A SCHC Fragment receiver uses it to take action when there is a problem in the transmission of SCHC fragments. Such a problem could be detected by the receiver not getting a single SCHC Fragment during a given period of time or not getting a given number of packets in a given period of time. When this happens, an Abort message will be sent (see related text later in this section). Initially, and each time a SCHC Fragment is received, the timer is reinitialized. The duration of this timer is not defined in this document and MUST be defined in the specific technology document.</li>
<li>Attempts. This counter counts the requests for a missing SCHC ACK. When it reaches the value MAX_ACK_REQUESTS, the sender assume there are recurrent SCHC Fragment transmission errors and determines that an Abort is needed. The default value offered MAX_ACK_REQUESTS is not stated in this document, and it is expected to be defined in the specific technology document. The Attempts counter is defined per window. It is initialized each time a new window is used.</li>
<li>Bitmap. The Bitmap is a sequence of bits carried in an SCHC ACK. Each bit in the Bitmap corresponds to a SCHC fragment of the current window, and provides feedback on whether the SCHC Fragment has been received or not. The right-most position on the Bitmap reports if the All-0 or All-1 fragment has been received or not. Feedback on the SCHC fragment with the highest FCN value is provided by the bit in the left-most position of the Bitmap. In the Bitmap, a bit set to 1 indicates that the SCHC Fragment of FCN corresponding to that bit position has been correctly sent and received. The text above describes the internal representation of the Bitmap. When inserted in the SCHC ACK for transmission from the receiver to the sender, the Bitmap MAY be truncated for energy/bandwidth optimisation, see more details in <a href="#Bitmapopt" class="xref">Section 7.4.3.1</a>.</li>
<li>Abort. On expiration of the Inactivity timer, or when Attempts reached MAX_ACK_REQUESTS or upon an occurrence of some other error, the sender or the receiver MUST use the Abort. When the receiver needs to abort the on-going SCHC Fragmented packet transmission, it sends the Receiver-Abort format. When the sender needs to abort the transmission, it sends the Sender-Abort format. None of the Abort are acknowledged.</li>
<li>Padding (P). If it is needed, the number of bits used for padding is not defined and depends on the size of the Rule ID, DTag and FCN fields, and on the L2 payload size (see <a href="#Padding" class="xref">Section 8</a>). Some SCHC ACKs are byte-aligned and do not need padding (see <a href="#Bitmapopt" class="xref">Section 7.4.3.1</a>).</li>
</ul>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#reliability-modes" id="reliability-modes">Reliability modes</a>
</h1>
<p id="rfc.section.7.3.p.1">This specification defines three reliability modes: No-ACK, ACK-Always, and ACK-on-Error. ACK-Always and ACK-on-Error operate on windows of SCHC Fragments. A window of SCHC Fragments is a subset of the full set of SCHC Fragments needed to carry a packet or an SCHC Packet.</p>
<p></p>

<ul>
<li>No-ACK. No-ACK is the simplest SCHC Fragment reliability mode. The receiver does not generate overhead in the form of acknowledgments (ACKs).  However, this mode does not enhance reliability beyond that offered by the underlying LPWAN technology. In the No-ACK mode, the receiver MUST NOT issue SCHC ACKs. See further details in <a href="#No-ACK-subsection" class="xref">Section 7.5.1</a>.</li>
<li>ACK-Always. The ACK-Always mode provides flow control using a window scheme. This mode is also able to handle long bursts of lost SCHC Fragments since detection of such events can be done before the end of the SCHC Packet transmission as long as the window size is short enough. However, such benefit comes at the expense of SCHC ACK use. In ACK-Always the receiver sends an SCHC ACK after a window of SCHC Fragments has been received, where a window of SCHC Fragments is a subset of the whole number of SCHC Fragments needed to carry a complete SCHC Packet. The SCHC ACK is used to inform the sender if a SCHC fragment in the actual window has been lost or well received. Upon an SCHC ACK reception, the sender retransmits the lost SCHC Fragments. When an SCHC ACK is lost and the sender has not received it before the expiration of the Retransmission Timer, the sender uses an SCHC ACK request by sending the All-0 empty SCHC Fragment when it is not the last window and the ALL-1 empty Fragment when it is the last window. The maximum number of SCHC ACK requests is MAX_ACK_REQUESTS. If the MAX_ACK_REQUEST is reached the transmission needs to be Aborted. See further details in <a href="#ACK-Always-subsection" class="xref">Section 7.5.2</a>.</li>
<li>ACK-on-Error. The ACK-on-Error mode is suitable for links offering relatively low L2 data unit loss probability. In this mode, the SCHC Fragment receiver reduces the number of SCHC ACKs transmitted, which MAY be especially beneficial in asymmetric scenarios. Because the SCHC Fragments use the uplink of the underlying LPWAN technology, which has higher capacity than downlink. The receiver transmits an SCHC ACK only after the complete window transmission and if at least one SCHC Fragment of this window has been lost. An exception to this behavior is in the last window, where the receiver MUST transmit an SCHC ACK, including the C bit set based on the MIC checked result, even if all the SCHC Fragments of the last window have been correctly received.  The SCHC ACK gives the state of all the SCHC Fragments (received or lost). Upon an SCHC ACK reception, the sender retransmits the lost SCHC Fragments. If an SCHC ACK is not transmitted back by the receiver at the end of a window, the sender assumes that all SCHC Fragments have been correctly received. When the SCHC ACK is lost, the sender assumes that all SCHC Fragments covered by the lost SCHC ACK have been successfully delivered, so the sender continues transmitting the next window of SCHC Fragments. If the next SCHC Fragments received belong to the next window, the receiver will abort the on-going fragmented packet transmission. See further details in <a href="#ACK-on-Error-subsection" class="xref">Section 7.5.3</a>.</li>
</ul>
<p id="rfc.section.7.3.p.3">The same reliability mode MUST be used for all SCHC Fragments of an SCHC Packet. The decision on which reliability mode will be used and whether the same reliability mode applies to all SCHC Packets is an implementation problem and is out of the scope of this document.</p>
<p id="rfc.section.7.3.p.4">Note that the reliability mode choice is not necessarily tied to a particular characteristic of the underlying L2 LPWAN technology, e.g. the No-ACK mode MAY be used on top of an L2 LPWAN technology with symmetric characteristics for uplink and downlink. This document does not make any decision as to which SCHC Fragment reliability mode(s) are supported by a specific LPWAN technology.</p>
<p id="rfc.section.7.3.p.5">Examples of the different reliability modes described are provided in Appendix B.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#Fragfor" id="Fragfor">Fragmentation Formats</a>
</h1>
<p id="rfc.section.7.4.p.1">This section defines the SCHC Fragment format, the All-0 and All-1 formats, the SCHC ACK format and the Abort formats.</p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#fragment-format" id="fragment-format">Fragment format</a>
</h1>
<p id="rfc.section.7.4.1.p.1">A SCHC Fragment comprises a SCHC Fragment header, a SCHC Fragment payload and padding bits (if needed). A SCHC Fragment conforms to the general format shown in <a href="#Fig-FragFormat" class="xref">Figure 11</a>. The SCHC Fragment payload carries a subset of SCHC Packet. A SCHC Fragment is the payload of the L2 protocol data unit (PDU). Padding MAY be added in SCHC Fragments and in SCHC ACKs if necessary, therefore a padding field is optional (this is explicitly indicated in <a href="#Fig-FragFormat" class="xref">Figure 11</a> for the sake of illustration clarity.</p>
<div id="rfc.figure.11"></div>
<div id="Fig-FragFormat"></div>
<pre>
+-----------------+-----------------------+~~~~~~~~~~~~~~~
| Fragment Header | &#160; Fragment payload    | padding (opt.)
+-----------------+-----------------------+~~~~~~~~~~~~~~~
</pre>
<p class="figure">Figure 11: Fragment general format. Presence of a padding field is optional</p>
<p id="rfc.section.7.4.1.p.2">In ACK-Always or ACK-on-Error, SCHC Fragments except the last one SHALL conform the detailed format defined in <a href="#Fig-NotLastWin" class="xref">Figure 12</a>. The total size of the fragment header is not byte aligned.</p>
<div id="rfc.figure.12"></div>
<div id="Fig-NotLastWin"></div>
<pre>
 |---Fragmentation Header----|
           |-- T --|1|-- N --|
 +-- ... --+- ... -+-+- ... -+--------...-------+
 | Rule ID | DTag  |W|  FCN  | Fragment payload |
 +-- ... --+- ... -+-+- ... -+--------...-------+

</pre>
<p class="figure">Figure 12: Fragment Detailed Format for Fragments except the Last One, ACK-Always and ACK-on-Error</p>
<p id="rfc.section.7.4.1.p.3">In the No-ACK mode, SCHC Fragments except the last one SHALL conform to the detailed format defined in <a href="#Fig-NotLast" class="xref">Figure 13</a>. The total size of the fragment header is not byte aligned.</p>
<div id="rfc.figure.13"></div>
<div id="Fig-NotLast"></div>
<pre>
 |---Fragmentation Header--|
           |-- T --|-- N --|
 +-- ... --+- ... -+- ... -+--------...-------+
 | Rule ID |  DTag |  FCN  | Fragment payload |
 +-- ... --+- ... -+- ... -+--------...-------+
 &#160; &#160; &#160; &#160; &#160; &#160;

</pre>
<p class="figure">Figure 13: Fragment Detailed Format for Fragments except the Last One, No-ACK mode</p>
<p id="rfc.section.7.4.1.p.4">In all these cases, the total size of the fragment header is not byte aligned.</p>
<h1 id="rfc.section.7.4.2">
<a href="#rfc.section.7.4.2">7.4.2.</a> <a href="#all-1-and-all-0-formats" id="all-1-and-all-0-formats">All-1 and All-0 formats</a>
</h1>
<p id="rfc.section.7.4.2.p.1">The All-0 format is used for sending the last SCHC Fragment of a window that is not the last window of the packet.</p>
<div id="rfc.figure.14"></div>
<div id="Fig-All0"></div>
<pre>
          |-- T --|1|-- N --|
+-- ... --+- ... -+-+- ... -+--- ... ---+
| Rule ID | DTag  |W|  0..0 |  payload  |  
+-- ... --+- ... -+-+- ... -+--- ... ---+

</pre>
<p class="figure">Figure 14: All-0 fragment detailed format</p>
<p id="rfc.section.7.4.2.p.2">The All-0 empty fragment format is used by a sender to request the retransmission of an SCHC ACK by the receiver. It is only used in ACK-Always mode.</p>
<div id="rfc.figure.15"></div>
<div id="Fig-All0empty"></div>
<pre>
           |-- T --|1|-- N --|
 +-- ... --+- ... -+-+- ... -+
 | Rule ID | DTag  |W|  0..0 | (no payload)  
 +-- ... --+- ... -+-+- ... -+

</pre>
<p class="figure">Figure 15: All-0 empty fragment detailed format</p>
<p id="rfc.section.7.4.2.p.3">In the No-ACK mode, the last SCHC Fragment of an IPv6 datagram SHALL contain a SCHC Fragment header that conforms to the detaield format shown in <a href="#Fig-Last" class="xref">Figure 16</a>.</p>
<div id="rfc.figure.16"></div>
<div id="Fig-Last"></div>
<pre>
             |-- T --|-N=1-| 
+---- ... ---+- ... -+-----+---- ... ----+---...---+
|   Rule ID  | DTag  |  1  |     MIC     | payload |
+---- ... ---+- ... -+-----+---- ... ----+---...---+

</pre>
<p class="figure">Figure 16: All-1 Fragment Detailed Format for the Last Fragment, No-ACK mode</p>
<p id="rfc.section.7.4.2.p.4">In any of the Window modes, the last fragment of an IPv6 datagram SHALL contain a SCHC Fragment header that conforms to the detailed format shown in <a href="#Fig-LastWinMode" class="xref">Figure 17</a>. The total size of the SCHC Fragment header in this format is not byte aligned.</p>
<div id="rfc.figure.17"></div>
<div id="Fig-LastWinMode"></div>
<pre>
          |-- T --|1|-- N --|
+-- ... --+- ... -+-+- ... -+---- ... ----+---...---+
| Rule ID | DTag  |W| 11..1 |     MIC     | payload |
+-- ... --+- ... -+-+- ... -+---- ... ----+---...---+
                      (FCN)
</pre>
<p class="figure">Figure 17: All-1 Fragment Detailed Format for the Last Fragment, ACK-Always or ACK-on-Error</p>
<p id="rfc.section.7.4.2.p.5">In either ACK-Always or ACK-on-Error, in order to request a retransmission of the SCHC ACK for the All-1 window, the fragment sender uses the format shown in <a href="#Fig-All1retries" class="xref">Figure 18</a>. The total size of the SCHC Fragment header in not byte aligned.</p>
<div id="rfc.figure.18"></div>
<div id="Fig-All1retries"></div>
<pre>
          |-- T --|1|-- N --|
+-- ... --+- ... -+-+- ... -+---- ... ----+
| Rule ID | DTag  |W|  1..1 |     MIC     | (no payload)  
+-- ... --+- ... -+-+- ... -+---- ... ----+

</pre>
<p class="figure">Figure 18: All-1 for Retries format, also called All-1 empty</p>
<p id="rfc.section.7.4.2.p.6">The values for Fragmentation Header, N, T and the length of MIC are not specified in this document, and SHOULD be determined in other documents (e.g. technology-specific profile documents).</p>
<h1 id="rfc.section.7.4.3">
<a href="#rfc.section.7.4.3">7.4.3.</a> <a href="#schc-ack-format" id="schc-ack-format">SCHC ACK format</a>
</h1>
<p id="rfc.section.7.4.3.p.1">The format of an SCHC ACK that acknowledges a window that is not the last one (denoted as All-0 window) is shown in <a href="#Fig-ACK-Format" class="xref">Figure 19</a>.</p>
<div id="rfc.figure.19"></div>
<div id="Fig-ACK-Format"></div>
<pre>
            |-- T --|1|
+---- ... --+- ... -+-+---- ... -----+
|  Rule ID  |  DTag |W|encoded Bitmap| (no payload)
+---- ... --+- ... -+-+---- ... -----+

</pre>
<p class="figure">Figure 19: ACK format for All-0 windows</p>
<p id="rfc.section.7.4.3.p.2">To acknowledge the last window of a packet (denoted as All-1 window), a C bit (i.e. MIC checked) following the W bit is set to 1 to indicate that the MIC check computed by the receiver matches the MIC present in the All-1 fragment. If the MIC check fails, the C bit is set to 0 and the Bitmap for the All-1 window follows.</p>
<div id="rfc.figure.20"></div>
<div id="Fig-ACK-Format1"></div>
<pre>
            |-- T --|1|1|
+---- ... --+- ... -+-+-+
|  Rule ID  |  DTag |W|1| (MIC correct)
+---- ... --+- ... -+-+-+

+---- ... --+- ... -+-+-+----- ... -----+
|  Rule ID  |  DTag |W|0|encoded Bitmap |(MIC Incorrect)
+---- ... --+- ... -+-+-+----- ... -----+
                       C

</pre>
<p class="figure">Figure 20: Format of an SCHC ACK for All-1 windows</p>
<h1 id="rfc.section.7.4.3.1">
<a href="#rfc.section.7.4.3.1">7.4.3.1.</a> <a href="#Bitmapopt" id="Bitmapopt">Bitmap Encoding</a>
</h1>
<p id="rfc.section.7.4.3.1.p.1">The Bitmap is transmitted by a receiver as part of the SCHC ACK format. An SCHC ACK message MAY include padding at the end to align its number of transmitted bits to a multiple of 8 bits.</p>
<p id="rfc.section.7.4.3.1.p.2">Note that the SCHC ACK sent a response to an All-1 fragment including the C bit. Therefore, the window size and thus the encoded Bitmap size need to be determined to take into account the available space in the layer two frame payload, where there will be 1 bit less for an SCHC ACK sent in response to an All-1 fragment than in other SCHC ACKs. Note that the maximum number of SCHC Fragments of the last window is one unit smaller than that of the previous windows.</p>
<p id="rfc.section.7.4.3.1.p.3">When the receiver transmits an encoded Bitmap with a SCHC Fragment that has not been sent during the transmission, the sender will Abort the transmission.</p>
<div id="rfc.figure.21"></div>
<div id="Fig-Localbitmap"></div>
<pre>
                   |----         Bitmap bits       ----|   
| Rule ID | DTag |W|1|0|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|   
|next byte boundary --&gt;|  next byte --&gt;|  next byte --&gt;|   

</pre>
<p class="figure">Figure 21: A non-encoded Bitmap</p>
<p id="rfc.section.7.4.3.1.p.4">In order to reduce the resulting frame size, the encoded Bitmap is shortened by applying the following algorithm: all the right-most contiguous bytes in the encoded Bitmap that have all their bits set to 1 MUST NOT be transmitted.  Because the SCHC Fragment sender knows the actual Bitmap size, it can reconstruct the original Bitmap with the trailing 1 bit optimized away.  In the example shown in <a href="#Fig-transmittedbitmap" class="xref">Figure 22</a>, the last 2 bytes of the Bitmap shown in <a href="#Fig-Localbitmap" class="xref">Figure 21</a> comprises bits that are all set to 1, therefore they are not sent.</p>
<div id="rfc.figure.22"></div>
<div id="Fig-transmittedbitmap"></div>
<pre>
            |-- T --|1|
+---- ... --+- ... -+-+-+-+
|  Rule ID  |  DTag |W|1|0|
+---- ... --+- ... -+-+-+-+
|  next byte boundary ---&gt;|    

</pre>
<p class="figure">Figure 22: Optimized Bitmap format</p>
<p><a href="#Fig-Bitmap-Win" class="xref">Figure 23</a> shows an example of an SCHC ACK with FCN ranging from 6 down to 0, where the Bitmap indicates that the second and the fifth SCHC Fragments have not been correctly received.</p>
<div id="rfc.figure.23"></div>
<div id="Fig-Bitmap-Win"></div>
<pre>
                     6 5 4 3 2 1   0 (*)
          |-- T --|1|  
+---------+-------+-+-+-+-+-+-+-+-----+
| Rule ID |  DTag |W|1|0|1|1|0|1|all-0| Bitmap(before tx)
+---------+-------+-+-+-+-+-+-+-+-----+
|next byte boundary -&gt;|  next  byte ---&gt;|
    (*)=(FCN values)

+---------+-------+-+-+-+-+-+-+-+-----+~~
| Rule ID | DTag  |W|1|0|1|1|0|1|all-0|Padding(opt.) encoded Bitmap
+---------+-------+-+-+-+-+-+-+-+-----+~~
|next byte boundary -&gt;|  next  byte----&gt;|

</pre>
<p class="figure">Figure 23: Example of a Bitmap before transmission, and the transmitted one, in any window except the last one</p>
<p><a href="#Fig-Bitmap-lastWin" class="xref">Figure 24</a> shows an example of an SCHC ACK with FCN ranging from 6 down to 0, where the Bitmap indicates that the MIC check has failed but there are no missing SCHC Fragments.</p>
<div id="rfc.figure.24"></div>
<div id="Fig-Bitmap-lastWin"></div>
<pre>
 |-Fragmentation Header-|6 5 4 3 2 1 7 (*)
            |-- T --|1|
 |  Rule ID |  DTag |W|0|1|1|1|1|1|1|1|padding|  Bitmap (before tx)
 |next byte boundary ----&gt;| next byte --&gt;|  
                       C
 +---- ... --+-... -+-+-+-+
 |  Rule ID  | DTag |W|0|1| encoded Bitmap
 +---- ... --+-... -+-+-+-+
 |next byte boundary ----&gt;|
   (*) = (FCN values indicating the order)

</pre>
<p class="figure">Figure 24: Example of the Bitmap in ACK-Always or ACK-on-Error for the last window, for N=3)</p>
<h1 id="rfc.section.7.4.4">
<a href="#rfc.section.7.4.4">7.4.4.</a> <a href="#abort-formats" id="abort-formats">Abort formats</a>
</h1>
<p id="rfc.section.7.4.4.p.1">Abort are coded as exceptions to the previous coding, a specific format is defined for each direction. When a SCHC Fragment sender needs to abort the transmission, it sends the Sender-Abort format <a href="#Fig-All1Abort" class="xref">Figure 25</a>, that is an All-1 fragment with no MIC or payload. In regular cases All-1 fragment contains at least a MIC value. This absence of the MIC value indicates an Abort.</p>
<p id="rfc.section.7.4.4.p.2">When a SCHC Fragment receiver needs to abort the on-going SCHC Fragmented packet transmission, it transmits the Receiver-Abort format <a href="#Fig-ACKabort" class="xref">Figure 26</a>, creating an exception in the encoded Bitmap coding. Encoded Bitmap avoid sending the rigth most bits of the Bitmap set to 1. Abort is coded as an SCHC ACK message with a Bitmap set to 1 until the next byte boundary, followed by an extra 0xFF byte. Such message never occurs in a regular acknowledgement and is view as an abort.</p>
<p id="rfc.section.7.4.4.p.3">None of these messages are not acknowledged nor retransmitted.</p>
<p id="rfc.section.7.4.4.p.4">The sender uses the Sender-Abort when the MAX_ACK_REQUEST is reached. The receiver uses the Receiver-Abort when the Inactivity timer expires, or in the ACK-on-Error mode, SCHC ACK is lost and the sender transmits SCHC Fragments of a new window. Some other cases for Abort are explained in the <a href="#FragModes" class="xref">Section 7.5</a> or <a href="#FSM" class="xref">Appendix C</a>.</p>
<div id="rfc.figure.25"></div>
<div id="Fig-All1Abort"></div>
<pre>
|-- Fragmentation Header ---|--- 1 byte ----|
+--- ... ---+- ... -+-+-...-+-+-+-+-+-+-+-+-+
|  Rule ID  | DTag  |W| FCN |       FF      | (no MIC &amp; no payload)  
+--- ... ---+- ... -+-+-...-+-+-+-+-+-+-+-+-+

</pre>
<p class="figure">Figure 25: Sender-Abort format. All FCN fields in this format are set to 1</p>
<div id="rfc.figure.26"></div>
<div id="Fig-ACKabort"></div>
<pre>
 | next byte boundary  ----&gt;|---- 1 byte ---|

 +---- ... --+-... -+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Rule ID  | DTag |W| 1..1|       FF      |  
 +---- ... --+-... -+-+-+-+-+-+-+-+-+-+-+-+-+

</pre>
<p class="figure">Figure 26: Receiver-Abort format</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#FragModes" id="FragModes">Baseline mechanism</a>
</h1>
<p id="rfc.section.7.5.p.1">If after applying SCHC header compression (or when SCHC header compression is not possible) the SCHC Packet does not fit within the payload of a single L2 data unit, the SCHC Packet SHALL be broken into SCHC Fragments and the fragments SHALL be sent to the fragment receiver. The fragment receiver needs to identify all the SCHC Fragments that belong to a given SCHC Packet. To this end, the receiver SHALL use:</p>
<p></p>

<ul>
<li>The sender&#8217;s L2 source address (if present),</li>
<li>The destination&#8217;s L2 address (if present),</li>
<li>Rule ID,</li>
<li>DTag (if present).</li>
</ul>
<p id="rfc.section.7.5.p.3">Then, the fragment receiver MAY determine the SCHC Fragment reliability mode that is used for this SCHC Fragment based on the Rule ID in that fragment.</p>
<p id="rfc.section.7.5.p.4">After a SCHC Fragment reception, the receiver starts constructing the SCHC Packet. It uses the FCN and the arrival order of each SCHC Fragment to determine the location of the individual fragments within the SCHC Packet. For example, the receiver MAY place the fragment payload within a payload datagram reassembly buffer at the location determined from the FCN, the arrival order of the SCHC Fragments, and the fragment payload sizes. In Window mode, the fragment receiver also uses the W bit in the received SCHC Fragments. Note that the size of the original, unfragmented packet cannot be determined from fragmentation headers.</p>
<p id="rfc.section.7.5.p.5">Fragmentation functionality uses the FCN value to transmit the SCHC Fragments. It has a length of N bits where the All-1 and All-0 FCN values are used to control the fragmentation transmission. The rest of the FCN numbers MUST be assigned sequentially in a decreasing order, the first FCN of a window is RECOMMENDED to be MAX_WIND_FCN, i.e. the highest possible FCN value depending on the FCN number of bits.</p>
<p id="rfc.section.7.5.p.6">In all modes, the last SCHC Fragment of a packet MUST contain a MIC which is used to check if there are errors or missing SCHC Fragments and MUST use the corresponding All-1 fragment format.  Note that a SCHC Fragment with an All-0 format is considered the last SCHC Fragment of the current window.</p>
<p id="rfc.section.7.5.p.7">If the receiver receives the last fragment of a datagram (All-1), it checks for the integrity of the reassembled datagram, based on the MIC received. In No-ACK, if the integrity check indicates that the reassembled datagram does not match the original datagram (prior to fragmentation), the reassembled datagram MUST be discarded. In Window mode, a MIC check is also performed by the fragment receiver after reception of each subsequent SCHC Fragment retransmitted after the first MIC check.</p>
<p id="rfc.section.7.5.p.8">There are three reliability modes: No-ACK, ACK-Always and ACK-on-Error. In ACK-Always and ACK-on-Error, a jumping window protocol uses two windows alternatively, identified as 0 and 1.  A SCHC Fragment with all FCN bits set to 0 (i.e. an All-0 fragment) indicates that the window is over (i.e. the SCHC Fragment is the last one of the window) and allows to switch from one window to the next one.  The All-1 FCN in a SCHC Fragment indicates that it is the last fragment of the packet being transmitted and therefore there will not be another window for this packet.</p>
<h1 id="rfc.section.7.5.1">
<a href="#rfc.section.7.5.1">7.5.1.</a> <a href="#No-ACK-subsection" id="No-ACK-subsection">No-ACK</a>
</h1>
<p id="rfc.section.7.5.1.p.1">In the No-ACK mode, there is no feedback communication from the fragment receiver. The sender will send all the SCHC fragments of a packet without any possibility of knowing if errors or losses have occurred. As, in this mode, there is no need to identify specific SCHC Fragments, a one-bit FCN MAY be used. Consequently, the FCN All-0 value is used in all SCHC fragments except the last one, which carries an All-1 FCN and the MIC. The receiver will wait for SCHC Fragments and will set the Inactivity timer. The receiver will use the MIC contained in the last SCHC Fragment to check for errors.  When the Inactivity Timer expires or if the MIC check indicates that the reassembled packet does not match the original one, the receiver will release all resources allocated to reassembling this packet. The initial value of the Inactivity Timer will be determined based on the characteristics of the underlying LPWAN technology and will be defined in other documents (e.g. technology-specific profile documents).</p>
<h1 id="rfc.section.7.5.2">
<a href="#rfc.section.7.5.2">7.5.2.</a> <a href="#ACK-Always-subsection" id="ACK-Always-subsection">ACK-Always</a>
</h1>
<p id="rfc.section.7.5.2.p.1">In ACK-Always, the sender transmits SCHC Fragments by using the two-jumping-windows procedure. A delay between each SCHC fragment can be added to respect local regulations or other constraints imposed by the applications.  Each time a SCHC fragment is sent, the FCN is decreased by one.  When the FCN reaches value 0 and there are more SCHC Fragments to be sent after, the sender transmits the last SCHC Fragment of this window using the All-0 fragment format, it starts the transmitted is the last SCHC Fragment of the SCHC Packet, the sender uses the All-1 fragment format, which includes a MIC. The sender sets the Retransmission Timer and waits for the SCHC ACK to know if transmission errors have occured.</p>
<p id="rfc.section.7.5.2.p.2">The Retransmission Timer is dimensioned based on the LPWAN technology in use. When the Retransmission Timer expires, the sender sends an All-0 empty (resp. All-1 empty) fragment to request again the SCHC ACK for the window that ended with the All-0 (resp. All-1) fragment just sent. The window number is not changed.</p>
<p id="rfc.section.7.5.2.p.3">After receiving an All-0 or All-1 fragment, the receiver sends an SCHC ACK with an encoded Bitmap reporting whether any SCHC fragments have been lost or not. When the sender receives an SCHC ACK, it checks the W bit carried by the SCHC ACK. Any SCHC ACK carrying an unexpected W bit value is discarded. If the W bit value of the received SCHC ACK is correct, the sender analyzes the rest of the SCHC ACK message, such as the encoded Bitmap and the MIC. If all the SCHC Fragments sent for this window have been well received, and if at least one more SCHC Fragment needs to be sent, the sender advances its sending window to the next window value and sends the next SCHC Fragments. If no more SCHC Fragments have to be sent, then the SCHC fragmented packet transmission is finished.</p>
<p id="rfc.section.7.5.2.p.4">However, if one or more SCHC Fragments have not been received as per the SCHC ACK (i.e. the corresponding bits are not set in the encoded Bitmap) then the sender resends the missing SCHC Fragments.  When all missing SCHC Fragments have been retransmitted, the sender starts the Retransmission Timer, even if an All-0 or an All-1 has not been sent as part of this retransmission and waits for an SCHC ACK. Upon receipt of the SCHC ACK, if one or more SCHC Fragments have not yet been received, the counter Attempts is increased and the sender resends the missing SCHC Fragments again. When Attempts reaches MAX_ACK_REQUESTS, the sender aborts the on-going SCHC Fragmented packet transmission by sending an Abort message and releases any resources for transmission of the packet. The sender also aborts an on-going SCHC Fragmented packet transmission when a failed MIC check is reported by the receiver or when a SCHC Fragment that has not been sent is reported in the encoded Bitmap.</p>
<p id="rfc.section.7.5.2.p.5">On the other hand, at the beginning, the receiver side expects to receive window 0. Any SCHC Fragment received but not belonging to the current window is discarded.  All SCHC Fragments belonging to the correct window are accepted, and the actual SCHC Fragment number managed by the receiver is computed based on the FCN value.  The receiver prepares the encoded Bitmap to report the correctly received and the missing SCHC Fragments for the current window. After each SCHC Fragment is received the receiver initializes the Inactivity timer, if the Inactivity Timer expires the transmission is aborted.</p>
<p id="rfc.section.7.5.2.p.6">When an All-0 fragment is received, it indicates that all the SCHC Fragments have been sent in the current window.  Since the sender is not obliged to always send a full window, some SCHC Fragment number not set in the receiver memory SHOULD not correspond to losses.  The receiver sends the corresponding SCHC ACK, the Inactivity Timer is set and the transmission of the next window by the sender can start.</p>
<p id="rfc.section.7.5.2.p.7">If an All-0 fragment has been received and all SCHC Fragments of the current window have also been received, the receiver then expects a new Window and waits for the next SCHC Fragment.  Upon receipt of a SCHC Fragment, if the window value has not changed, the received SCHC Fragments are part of a retransmission. A receiver that has already received a SCHC Fragment SHOULD discard it, otherwise, it updates the encoded Bitmap.  If all the bits of the encoded Bitmap are set to one, the receiver MUST send an SCHC ACK without waiting for an All-0 fragment and the Inactivity Timer is initialized.</p>
<p id="rfc.section.7.5.2.p.8">On the other hand, if the window value of the next received SCHC Fragment is set to the next expected window value, this means that the sender has received a correct encoded Bitmap reporting that all SCHC Fragments have been received.  The receiver then updates the value of the next expected window.</p>
<p id="rfc.section.7.5.2.p.9">When an All-1 fragment is received, it indicates that the last SCHC Fragment of the packet has been sent.  Since the last window is not always full, the MIC will be used to detect if all SCHC Fragments of the packet have been received.  A correctMIC indicates the end of the transmission but the receiver MUST stay alive for an Inactivity Timer period to answer to any empty All-1 fragments the sender MAY send if SCHC ACKs sent by the receiver are lost. If the MIC is incorrect, some SCHC Fragments have been lost. The receiver sends the SCHC ACK regardless of successful SCHC Fragmented packet reception or not, the Inactitivity Timer is set. In case of an incorrect MIC, the receiver waits for SCHC Fragments belonging to the same window. After MAX_ACK_REQUESTS, the receiver will abort the on-going SCHC Fragmented packet transmission by transmitting the Receiver-Abort format. The receiver also aborts upon Inactivity Timer expiration.</p>
<h1 id="rfc.section.7.5.3">
<a href="#rfc.section.7.5.3">7.5.3.</a> <a href="#ACK-on-Error-subsection" id="ACK-on-Error-subsection">ACK-on-Error</a>
</h1>
<p id="rfc.section.7.5.3.p.1">The senders behavior for ACK-on-Error and ACK-Always are similar. The main difference is that in ACK-on-Error the SCHC ACK with the encoded Bitmap is not sent at the end of each window but only when at least one SCHC Fragment of the current window has been lost. Excepts for the last window where an SCHC ACK MUST be sent to finish the transmission.</p>
<p id="rfc.section.7.5.3.p.2">In ACK-on-Error, the Retransmission Timer expiration will be considered as a positive acknowledgment. This timer is set after sending an All-0 or an All-1 fragment. When the All-1 fragment has been sent, then the on-going SCHC F/R process is finished and the sender waits for the last SCHC ACK.  If the Retransmission Timer expires while waiting for the SCHC ACK for the last window, an All-1 empty MUST be sent to request the last SCHC ACK by the sender to complete the SCHC Fragmented packet transmission. When it expires the sender continue sending SCHC Fragments of the next window.</p>
<p id="rfc.section.7.5.3.p.3">If the sender receives an SCHC ACK, it checks the window value. SCHC ACKs with an unexpected window number are discarded.  If the window number on the received encoded Bitmap is correct, the sender verifies if the receiver has received all SCHC fragments of the current window.  When at least one SCHC Fragment has been lost, the counter Attempts is increased by one and the sender resends the missing SCHC Fragments again.  When Attempts reaches MAX_ACK_REQUESTS, the sender sends an Abort message and releases all resources for the on-going SCHC Fragmented packet transmission.  When the retransmission of the missing SCHC Fragments is finished, the sender starts listening for an SCHC ACK (even if an All-0 or an All-1 has not been sent during the retransmission) and initializes the Retransmission Timer. After sending an All-1 fragment, the sender listens for an SCHC ACK, initializes Attempts, and starts the Retransmission Timer. If the Retransmission Timer expires, Attempts in increased by one and an empty All-1 fragment is sent to request the SCHC ACK for the last window. If Attempts reaches MAX_ACK_REQUESTS, the sender aborts the on-going SCHC Fragmented packet transmission by transmitting the Sender-Abort fragment.</p>
<p id="rfc.section.7.5.3.p.4">Unlike the sender, the receiver for ACK-on-Error has a larger amount of differences compared with ACK-Always.  First, an SCHC ACK is not sent unless there is a lost SCHC Fragment or an unexpected behavior. With the exception of the last window, where an SCHC ACK is always sent regardless of SCHC Fragment losses or not.  The receiver starts by expecting SCHC Fragments from window 0 and maintains the information regarding which SCHC Fragments it receives.  After receiving an SCHC Fragment, the Inactivity Timer is set. If no further SCHC Fragment are received and the Inactivity Timer expires, the SCHC Fragment receiver aborts the on-going SCHC Fragmented packet transmission by transmitting the Receiver-Abort data unit.</p>
<p id="rfc.section.7.5.3.p.5">Any SCHC Fragment not belonging to the current window is discarded. The actual SCHC Fragment number is computed based on the FCN value.  When an All-0 fragment is received and all SCHC Fragments have been received, the receiver updates the expected window value and expects a new window and waits for the next SCHC Fragment. If the window value of the next SCHC Fragment has not changed, the received SCHC Fragment is a retransmission. A receiver that has already received an SCHC Fragment discard it. If all SCHC Fragments of a window (that is not the last one) have been received, the receiver does not send an SCHC ACK. While the receiver waits for the next window and if the window value is set to the next value, and if an All-1 fragment with the next value window arrived the receiver knows that the last SCHC Fragment of the packet has been sent.  Since the last window is not always full, the MIC will be used to detect if all SCHC Fragments of the window have been received.  A correct MIC check indicates the end of the SCHC Fragmented packet transmission. An ACK is sent by the SCHC Fragment receiver. In case of an incorrect MIC, the receiver waits for SCHC Fragments belonging to the same window or the expiration of the Inactivity Timer. The latter will lead the receiver to abort the on-going SCHC fragmented packet transmission.</p>
<p id="rfc.section.7.5.3.p.6">If after receiving an All-0 fragment the receiver missed some SCHC Fragments, the receiver uses an SCHC ACK with the encoded Bitmap to ask the retransmission of the missing fragments and expect to receive SCHC Fragments with the actual window. While waiting the retransmission an All-0 empty fragment is received, the receiver sends again the SCHC ACK with the encoded Bitmap, if the SCHC Fragments received belongs to another window or an All-1 fragment is received, the transmission is aborted by sending a Receiver-Abort fragment. Once it has received all the missing fragments it waits for the next window fragments.</p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#supporting-multiple-window-sizes" id="supporting-multiple-window-sizes">Supporting multiple window sizes</a>
</h1>
<p id="rfc.section.7.6.p.1">For ACK-Always or ACK-on-Error, implementers MAY opt to support a single window size or multiple window sizes.  The latter, when feasible, may provide performance optimizations.  For example, a large window size SHOULD be used for packets that need to be carried by a large number of SCHC Fragments. However, when the number of SCHC Fragments required to carry a packet is low, a smaller window size, and thus a shorter Bitmap, MAY be sufficient to provide feedback on all SCHC Fragments. If multiple window sizes are supported, the Rule ID MAY be used to signal the window size in use for a specific packet transmission.</p>
<p id="rfc.section.7.6.p.2">Note that the same window size MUST be used for the transmission of all SCHC Fragments that belong to the same SCHC Packet.</p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> <a href="#downlink-schc-fragment-transmission" id="downlink-schc-fragment-transmission">Downlink SCHC Fragment transmission</a>
</h1>
<p id="rfc.section.7.7.p.1">In some LPWAN technologies, as part of energy-saving techniques, downlink transmission is only possible immediately after an uplink transmission. In order to avoid potentially high delay in the downlink transmission of a SCHC Fragmented datagram, the SCHC Fragment receiver MAY perform an uplink transmission as soon as possible after reception of a SCHC Fragment that is not the last one. Such uplink transmission MAY be triggered by the L2 (e.g. an L2 ACK sent in response to a SCHC Fragment encapsulated in a L2 frame that requires an L2 ACK) or it MAY be triggered from an upper layer.</p>
<p id="rfc.section.7.7.p.2">For downlink transmission of a SCHC Fragmented packet in ACK-Always mode, the SCHC Fragment receiver MAY support timer-based SCHC ACK retransmission. In this mechanism, the SCHC Fragment receiver initializes and starts a timer (the Inactivity Timer is used) after the transmission of an SCHC ACK, except when the SCHC ACK is sent in response to the last SCHC Fragment of a packet (All-1 fragment). In the latter case, the SCHC Fragment receiver does not start a timer after transmission of the SCHC ACK.</p>
<p id="rfc.section.7.7.p.3">If, after transmission of an SCHC ACK that is not an All-1 fragment, and before expiration of the corresponding Inactivity timer, the SCHC Fragment receiver receives a SCHC Fragment that belongs to the current window (e.g. a missing SCHC Fragment from the current window) or to the next window, the Inactivity timer for the SCHC ACK is stopped. However, if the Inactivity timer expires, the SCHC ACK is resent and the Inactivity timer is reinitialized and restarted.</p>
<p id="rfc.section.7.7.p.4">The default initial value for the Inactivity timer, as well as the maximum number of retries for a specific SCHC ACK, denoted MAX_ACK_RETRIES, are not defined in this document, and need to be defined in other documents (e.g. technology-specific profiles). The initial value of the Inactivity timer is expected to be greater than that of the Retransmission timer, in order to make sure that a (buffered) SCHC Fragment to be retransmitted can find an opportunity for that transmission.</p>
<p id="rfc.section.7.7.p.5">When the SCHC Fragment sender transmits the All-1 fragment, it starts its Retransmission Timer with a large timeout value (e.g. several times that of the initial Inactivity timer). If an SCHC ACK is received before expiration of this timer, the SCHC Fragment sender retransmits any lost SCHC Fragments reported by the SCHC ACK, or if the SCHC ACK confirms successful reception of all SCHC Fragments of the last window, the transmission of the SCHC Fragmented packet is considered complete. If the timer expires, and no SCHC ACK has been received since the start of the timer, the SCHC Fragment sender assumes that the All-1 fragment has been successfully received (and possibly, the last SCHC ACK has been lost: this mechanism assumes that the retransmission timer for the All-1 fragment is long enough to allow several SCHC ACK retries if the All-1 fragment has not;been received by the SCHC Fragment receiver, and it also assumes that it is unlikely that several ACKs become all lost).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#Padding" id="Padding">Padding management</a>
</h1>
<p id="rfc.section.8.p.1">Default padding is defined for L2 frame with a variable length of bytes. Padding is done twice, after compression and in the all-1 fragmentation.</p>
<p id="rfc.section.8.p.2">In compression, the Compressed Header is generally not a multiple of bytes in size, but the payload following the Compressed Header is always a multiple of 8 bits (see <a href="#Fig-SCHCpckt" class="xref">Figure 4</a>). If needed, padding bits can be added after the payload to reach the next byte boundary. Since the Compressed Header (through the Rule ID and the Compression Residue) tells its length and the payload is always a multiple of 8 bits, the receiver can without ambiguity remove the padding bits, which never exceed 7 bits.</p>
<p id="rfc.section.8.p.3">SCHC F/R works on a byte aligned (i.e. padded SCHC Packet). Fragmentation header may not be aligned on the next byte boundary, but each fragment except the last one (All-1 fragment) must sent the maximum bits as possible. Only the last fragment need to introduce padding to reach the next boundary limit. Since the SCHC is known to be a multiple of 8 bits, the receiver can remove the extra bit to reach this limit.</p>
<p id="rfc.section.8.p.4">Default padding mechanism do not need to send the padding length and can lead to a maximum of 14 bits of padding.</p>
<p id="rfc.section.8.p.5">The padding is not mandatory and is optional to the technology-specific document to give a different solution. In this document there are some inputs on how to manage the padding.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#schc-compression-for-ipv6-and-udp-headers" id="schc-compression-for-ipv6-and-udp-headers">SCHC Compression for IPv6 and UDP headers</a>
</h1>
<p id="rfc.section.9.p.1">This section lists the different IPv6 and UDP header fields and how they can be compressed.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#ipv6-version-field" id="ipv6-version-field">IPv6 version field</a>
</h1>
<p id="rfc.section.9.1.p.1">This field always holds the same value. Therefore, in the rule, TV is set to 6, MO to &#8220;equal&#8221; and CDA to &#8220;not-sent&#8221;.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#ipv6-traffic-class-field" id="ipv6-traffic-class-field">IPv6 Traffic class field</a>
</h1>
<p id="rfc.section.9.2.p.1">If the DiffServ field does not vary and is known by both sides, the Field Descriptor in the rule SHOULD contain a TV with this well-known value, an &#8220;equal&#8221; MO and a &#8220;not-sent&#8221; CDA.</p>
<p id="rfc.section.9.2.p.2">Otherwise, two possibilities can be considered depending on the variability of the value:</p>
<p></p>

<ul>
<li>One possibility is to not compress the field and send the original value. In the rule, TV is not set to any particular value, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
<li>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</li>
</ul>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#flow-label-field" id="flow-label-field">Flow label field</a>
</h1>
<p id="rfc.section.9.3.p.1">If the Flow Label field does not vary and is known by both sides, the Field Descriptor in the rule SHOULD contain a TV with this well-known value, an &#8220;equal&#8221; MO and a &#8220;not-sent&#8221; CDA.</p>
<p id="rfc.section.9.3.p.2">Otherwise, two possibilities can be considered:</p>
<p></p>

<ul>
<li>One possibility is to not compress the field and send the original value. In the rule, TV is not set to any particular value, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
<li>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</li>
</ul>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#payload-length-field" id="payload-length-field">Payload Length field</a>
</h1>
<p id="rfc.section.9.4.p.1">This field can be elided for the transmission on the LPWAN network. The SCHC C/D recomputes the original payload length value. In the Field Descriptor, TV is not set, MO is set to &#8220;ignore&#8221; and CDA is &#8220;compute-IPv6-length&#8221;.</p>
<p id="rfc.section.9.4.p.2">If the payload length needs to be sent and does not need to be coded in 16 bits, the TV can be set to 0x0000, the MO set to MSB(16-s) where &#8216;s&#8217; is the number of bits to code the maximum length, and CDA is set to LSB(s).</p>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#next-header-field" id="next-header-field">Next Header field</a>
</h1>
<p id="rfc.section.9.5.p.1">If the Next Header field does not vary and is known by both sides, the Field Descriptor in the rule SHOULD contain a TV with this Next Header value, the MO SHOULD be &#8220;equal&#8221; and the CDA SHOULD be &#8220;not-sent&#8221;.</p>
<p id="rfc.section.9.5.p.2">Otherwise, TV is not set in the Field Descriptor, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;. Alternatively, a matching-list MAY also be used.</p>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#hop-limit-field" id="hop-limit-field">Hop Limit field</a>
</h1>
<p id="rfc.section.9.6.p.1">The field behavior for this field is different for Uplink and Downlink. In Uplink, since there is no IP forwarding between the Dev and the SCHC C/D, the value is relatively constant. On the other hand, the Downlink value depends of Internet routing and MAY change more frequently. One neat way of processing this field is to use the Direction Indicator (DI) to distinguish both directions:</p>
<p></p>

<ul>
<li>in the Uplink, elide the field: the TV in the Field Descriptor is set to the known constant value, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</li>
<li>in the Downlink, send the value: TV is not set, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
</ul>
<h1 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> <a href="#ipv6-addresses-fields" id="ipv6-addresses-fields">IPv6 addresses fields</a>
</h1>
<p id="rfc.section.9.7.p.1">As in 6LoWPAN <a href="#RFC4944" class="xref">[RFC4944]</a>, IPv6 addresses are split into two 64-bit long fields; one for the prefix and one for the Interface Identifier (IID). These fields SHOULD be compressed. To allow for a single rule being used for both directions, these values are identified by their role (DEV or APP) and not by their position in the frame (source or destination).</p>
<h1 id="rfc.section.9.7.1">
<a href="#rfc.section.9.7.1">9.7.1.</a> <a href="#ipv6-source-and-destination-prefixes" id="ipv6-source-and-destination-prefixes">IPv6 source and destination prefixes</a>
</h1>
<p id="rfc.section.9.7.1.p.1">Both ends MUST be synchronized with the appropriate prefixes. For a specific flow, the source and destination prefixes can be unique and stored in the context. It can be either a link-local prefix or a global prefix. In that case, the TV for the source and destination prefixes contain the values, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.9.7.1.p.2">If the rule is intended to compress packets with different prefix values, match-mapping SHOULD be used. The different prefixes are listed in the TV, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;. See <a href="#Fig-fields" class="xref">Figure 28</a></p>
<p id="rfc.section.9.7.1.p.3">Otherwise, the TV contains the prefix, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.9.7.2">
<a href="#rfc.section.9.7.2">9.7.2.</a> <a href="#ipv6-source-and-destination-iid" id="ipv6-source-and-destination-iid">IPv6 source and destination IID</a>
</h1>
<p id="rfc.section.9.7.2.p.1">If the DEV or APP IID are based on an LPWAN address, then the IID can be reconstructed with information coming from the LPWAN header. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;DEViid&#8221; or &#8220;APPiid&#8221;. Note that the LPWAN technology generally carries a single identifier corresponding to the DEV. Therefore Appiid cannot be used.</p>
<p id="rfc.section.9.7.2.p.2">For privacy reasons or if the DEV address is changing over time, a static value that is not equal to the DEV address SHOULD be used. In that case, the TV contains the static value, the MO operator is set to &#8220;equal&#8221; and the CDF is set to &#8220;not-sent&#8221;.  <a href="#RFC7217" class="xref">[RFC7217]</a> provides some methods that MAY be used to derive this static identifier.</p>
<p id="rfc.section.9.7.2.p.3">If several IIDs are possible, then the TV contains the list of possible IIDs, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.9.7.2.p.4">It MAY also happen that the IID variability only expresses itself on a few bytes. In that case, the TV is set to the stable part of the IID, the MO is set to &#8220;MSB&#8221; and the CDA is set to &#8220;LSB&#8221;.</p>
<p id="rfc.section.9.7.2.p.5">Finally, the IID can be sent in extenso on the LPWAN. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.9.8">
<a href="#rfc.section.9.8">9.8.</a> <a href="#ipv6-extensions" id="ipv6-extensions">IPv6 extensions</a>
</h1>
<p id="rfc.section.9.8.p.1">No rule is currently defined that processes IPv6 extensions. If such extensions are needed, their compression/decompression rules can be based on the MOs and CDAs described above.</p>
<h1 id="rfc.section.9.9">
<a href="#rfc.section.9.9">9.9.</a> <a href="#udp-source-and-destination-port" id="udp-source-and-destination-port">UDP source and destination port</a>
</h1>
<p id="rfc.section.9.9.p.1">To allow for a single rule being used for both directions, the UDP port values are identified by their role (DEV or APP) and not by their position in the frame (source or destination). The SCHC C/D MUST be aware of the traffic direction (Uplink, Downlink) to select the appropriate field. The following rules apply for DEV and APP port numbers.</p>
<p id="rfc.section.9.9.p.2">If both ends know the port number, it can be elided. The TV contains the port number, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.9.9.p.3">If the port variation is on few bits, the TV contains the stable part of the port number, the MO is set to &#8220;MSB&#8221; and the CDA is set to &#8220;LSB&#8221;.</p>
<p id="rfc.section.9.9.p.4">If some well-known values are used,  the TV can contain the list of these values, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.9.9.p.5">Otherwise the port numbers are sent over the LPWAN. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.9.10">
<a href="#rfc.section.9.10">9.10.</a> <a href="#udp-length-field" id="udp-length-field">UDP length field</a>
</h1>
<p id="rfc.section.9.10.p.1">The UDP length can be computed from the received data. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-length&#8221;.</p>
<p id="rfc.section.9.10.p.2">If the payload is small, the TV can be set to 0x0000, the MO set to &#8220;MSB&#8221; and the CDA to &#8220;LSB&#8221;.</p>
<p id="rfc.section.9.10.p.3">In other cases, the length SHOULD be sent and the CDA is replaced by &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.9.11">
<a href="#rfc.section.9.11">9.11.</a> <a href="#udp-checksum-field" id="udp-checksum-field">UDP Checksum field</a>
</h1>
<p id="rfc.section.9.11.p.1">IPv6 mandates a checksum in the protocol above IP. Nevertheless, if a more efficient mechanism such as L2 CRC or MIC is carried by or over the L2 (such as in the LPWAN SCHC F/R process (see <a href="#Frag" class="xref">Section 7</a>)), the UDP checksum transmission can be avoided. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-checksum&#8221;.</p>
<p id="rfc.section.9.11.p.2">In other cases, the checksum SHOULD be explicitly sent. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDF is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security considerations</a>
</h1>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#security-considerations-for-header-compression" id="security-considerations-for-header-compression">Security considerations for header compression</a>
</h1>
<p id="rfc.section.10.1.p.1">A malicious header compression could cause the reconstruction of a wrong packet that does not match with the original one. Such a corruption MAY be detected with end-to-end authentication and integrity mechanisms. Header Compression does not add more security problem than what is already needed in a transmission. For instance, to avoid an attack, never re-construct a packet bigger than some configured size (with 1500 bytes as generic default).</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#security-considerations-for-schc-fragmentationreassembly" id="security-considerations-for-schc-fragmentationreassembly">Security considerations for SCHC Fragmentation/Reassembly</a>
</h1>
<p id="rfc.section.10.2.p.1">This subsection describes potential attacks to LPWAN SCHC F/R and suggests possible countermeasures.</p>
<p id="rfc.section.10.2.p.2">A node can perform a buffer reservation attack by sending a first SCHC Fragment to a target.  Then, the receiver will reserve buffer space for the IPv6 packet.  Other incoming SCHC Fragmented packets will be dropped while the reassembly buffer is occupied during the reassembly timeout.  Once that timeout expires, the attacker can repeat the same procedure, and iterate, thus creating a denial of service attack.  The (low) cost to mount this attack is linear with the number of buffers at the target node.  However, the cost for an attacker can be increased if individual SCHC Fragments of multiple packets can be stored in the reassembly buffer.  To further increase the attack cost, the reassembly buffer can be split into SCHC Fragment-sized buffer slots. Once a packet is complete, it is processed normally.  If buffer overload occurs, a receiver can discard packets based on the sender behavior, which MAY help identify which SCHC Fragments have been sent by an attacker.</p>
<p id="rfc.section.10.2.p.3">In another type of attack, the malicious node is required to have overhearing capabilities.  If an attacker can overhear a SCHC Fragment, it can send a spoofed duplicate (e.g. with random payload) to the destination. If the LPWAN technology does not support suitable protection (e.g. source authentication and frame counters to prevent replay attacks), a receiver cannot distinguish legitimate from spoofed SCHC Fragments.  Therefore, the original IPv6 packet will be considered corrupt and will be dropped. To protect resource-constrained nodes from this attack, it has been proposed to establish a binding among the SCHC Fragments to be transmitted by a node, by applying content-chaining to the different SCHC Fragments, based on cryptographic hash functionality.  The aim of this technique is to allow a receiver to identify illegitimate SCHC Fragments.</p>
<p id="rfc.section.10.2.p.4">Further attacks MAY involve sending overlapped fragments (i.e. comprising some overlapping parts of the original IPv6 datagram). Implementers SHOULD make sure that the correct operation is not affected by such event.</p>
<p id="rfc.section.10.2.p.5">In Window mode &#8211; ACK on error, a malicious node MAY force a SCHC Fragment sender to resend a SCHC Fragment a number of times, with the aim to increase consumption of the SCHC Fragment sender&#8217;s resources. To this end, the malicious node MAY repeatedly send a fake ACK to the SCHC Fragment sender, with a Bitmap that reports that one or more SCHC Fragments have been lost. In order to mitigate this possible attack, MAX_ACK_RETRIES MAY be set to a safe value which allows to limit the maximum damage of the attack to an acceptable extent. However, note that a high setting for MAX_ACK_RETRIES benefits SCHC Fragment reliability modes, therefore the trade-off needs to be carefully considered.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.11.p.1">Thanks to Dominique Barthel, Carsten Bormann, Philippe Clavier, Eduardo Ingles Sanchez, Arunprabhu Kandasamy, Rahul Jadhav, Sergio Lopez Bernal, Antony Markovski, Alexander Pelov, Pascal Thubert, Juan Carlos Zuniga, Diego Dujovne, Edgar Ramos, and Shoichi Sakane for useful design consideration and comments.</p>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">12.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2460">[RFC2460]</b></td>
<td class="top">
<a>Deering, S.</a> and <a>R. Hinden</a>, "<a href="https://tools.ietf.org/html/rfc2460">Internet Protocol, Version 6 (IPv6) Specification</a>", RFC 2460, DOI 10.17487/RFC2460, December 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3385">[RFC3385]</b></td>
<td class="top">
<a>Sheinwald, D.</a>, <a>Satran, J.</a>, <a>Thaler, P.</a> and <a>V. Cavanna</a>, "<a href="https://tools.ietf.org/html/rfc3385">Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations</a>", RFC 3385, DOI 10.17487/RFC3385, September 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4944">[RFC4944]</b></td>
<td class="top">
<a>Montenegro, G.</a>, <a>Kushalnagar, N.</a>, <a>Hui, J.</a> and <a>D. Culler</a>, "<a href="https://tools.ietf.org/html/rfc4944">Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a>", RFC 4944, DOI 10.17487/RFC4944, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5795">[RFC5795]</b></td>
<td class="top">
<a>Sandlund, K.</a>, <a>Pelletier, G.</a> and <a>L-E. Jonsson</a>, "<a href="https://tools.ietf.org/html/rfc5795">The RObust Header Compression (ROHC) Framework</a>", RFC 5795, DOI 10.17487/RFC5795, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7136">[RFC7136]</b></td>
<td class="top">
<a>Carpenter, B.</a> and <a>S. Jiang</a>, "<a href="https://tools.ietf.org/html/rfc7136">Significance of IPv6 Interface Identifiers</a>", RFC 7136, DOI 10.17487/RFC7136, February 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7217">[RFC7217]</b></td>
<td class="top">
<a>Gont, F.</a>, "<a href="https://tools.ietf.org/html/rfc7217">A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</a>", RFC 7217, DOI 10.17487/RFC7217, April 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">12.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="I-D.ietf-lpwan-overview">[I-D.ietf-lpwan-overview]</b></td>
<td class="top">
<a>Farrell, S.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-lpwan-overview-10">LPWAN Overview</a>", Internet-Draft draft-ietf-lpwan-overview-10, February 2018.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#compressIPv6" id="compressIPv6">SCHC Compression Examples</a>
</h1>
<p id="rfc.section.A.p.1">This section gives some scenarios of the compression mechanism for IPv6/UDP. The goal is to illustrate the behavior of SCHC.</p>
<p id="rfc.section.A.p.2">The most common case using the mechanisms defined in this document will be a LPWAN Dev that embeds some applications running over CoAP. In this example, three flows are considered. The first flow is for the device management based on CoAP using Link Local IPv6 addresses and UDP ports 123 and 124 for Dev and App, respectively.  The second flow will be a CoAP server for measurements done by the Device (using ports 5683) and Global IPv6 Address prefixes alpha::IID/64 to beta::1/64.  The last flow is for legacy applications using different ports numbers, the destination IPv6 address prefix is gamma::1/64.</p>
<p><a href="#FigStack" class="xref">Figure 27</a> presents the protocol stack for this Device. IPv6 and UDP are represented with dotted lines since these protocols are compressed on the radio link.</p>
<div id="rfc.figure.27"></div>
<div id="FigStack"></div>
<pre>
 Management   Data
+----------+---------+---------+
|   CoAP   |  CoAP   | legacy  |
+----||----+---||----+---||----+
.   UDP    .  UDP    |   UDP   |
................................
.   IPv6   .  IPv6   .  IPv6   .
+------------------------------+
|    SCHC Header compression   |
|      and fragmentation       |
+------------------------------+
|      LPWAN L2 technologies   |
+------------------------------+
         DEV or NGW

</pre>
<p class="figure">Figure 27: Simplified Protocol Stack for LP-WAN</p>
<p id="rfc.section.A.p.4">Note that in some LPWAN technologies, only the Devs have a device ID.  Therefore, when such technologies are used, it is necessary to statically define an IID for the Link Local address for the SCHC C/D.</p>
<div id="rfc.figure.28"></div>
<div id="Fig-fields"></div>
<pre>
Rule 0
 +----------------+--+--+--+---------+--------+------------++------+
 | Field &#160; &#160; &#160; &#160;  |FL|FP|DI| Value &#160; | Match  | Comp Decomp|| Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+---------------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 APPiid     |64|1 |Bi|::1      | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|123      | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|124      | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+

 Rule 1
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||  [1] |
 |                |  |  |  |fe80::/64] mapping|            ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|[beta/64,| match- |mapping-sent||  [2] |
 |                |  |  |  |alpha/64,| mapping|            ||      |
 |                |  |  |  |fe80::64]|        |            ||      |
 |IPv6 APPiid     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+

 Rule 2
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Up|255      | ignore | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Dw|         | ignore | value-sent ||  [8] |
 |IPv6 DEVprefix  |64|1 |Bi|alpha/64 | equal  | not-sent   ||      |
 |IPv6 DEViid     |64|1 |Bi|         | ignore | DEViid     ||      |
 |IPv6 APPprefix  |64|1 |Bi|gamma/64 | equal  | not-sent   ||      |
 |IPv6 APPiid     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|8720     | MSB(12)| LSB        || [4]  |
 |UDP APPport     |16|1 |Bi|8720     | MSB(12)| LSB        || [4]  |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+


</pre>
<p class="figure">Figure 28: Context rules</p>
<p id="rfc.section.A.p.5">All the fields described in the three rules depicted on <a href="#Fig-fields" class="xref">Figure 28</a> are present in the IPv6 and UDP headers.  The DEViid-DID value is found in the L2 header.</p>
<p id="rfc.section.A.p.6">The second and third rules use global addresses. The way the Dev learns the prefix is not in the scope of the document.</p>
<p id="rfc.section.A.p.7">The third rule compresses port numbers to 4 bits.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#fragmentation-examples" id="fragmentation-examples">Fragmentation Examples</a>
</h1>
<p id="rfc.section.B.p.1">This section provides examples for the different fragment reliability modes specified in this document.</p>
<p><a href="#Fig-Example-Unreliable" class="xref">Figure 29</a> illustrates the transmission in No-ACK mode of an IPv6 packet that needs 11 fragments. FCN is 1 bit wide.</p>
<div id="rfc.figure.29"></div>
<div id="Fig-Example-Unreliable"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-----FCN=1 + MIC ---&gt;|MIC checked: success =&gt;
 &#160; &#160; &#160; &#160;
</pre>
<p class="figure">Figure 29: Transmission in No-ACK mode of an IPv6 packet carried by 11 fragments</p>
<p id="rfc.section.B.p.3">In the following examples, N (i.e. the size if the FCN field) is 3 bits. Therefore, the All-1 FCN value is 7.</p>
<p><a href="#Fig-Example-Win-NoLoss-NACK" class="xref">Figure 30</a> illustrates the transmission in ACK-on-Error of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no fragment loss.</p>
<div id="rfc.figure.30"></div>
<div id="Fig-Example-Win-NoLoss-NACK"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2-----&gt;|
          |-----W=0, FCN=1-----&gt;|
          |-----W=0, FCN=0-----&gt;|
      (no ACK)
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4-----&gt;|
          |--W=1, FCN=7 + MIC--&gt;|MIC checked: success =&gt;
          |&lt;---- ACK, W=1 ------|

</pre>
<p class="figure">Figure 30: Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no loss.</p>
<p><a href="#Fig-Example-Rel-Window-NACK-Loss" class="xref">Figure 31</a> illustrates the transmission in ACK-on-Error mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<div id="rfc.figure.31"></div>
<div id="Fig-Example-Rel-Window-NACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160; Sender &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4--X--&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2--X--&gt;|             7
          |-----W=0, FCN=1-----&gt;|             /
          |-----W=0, FCN=0-----&gt;|       6543210
          |&lt;-----ACK, W=0-------|Bitmap:1101011
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=2-----&gt;|   
      (no ACK)     
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4--X--&gt;|
          |- W=1, FCN=7 + MIC -&gt;|MIC checked: failed
          |&lt;-----ACK, W=1-------|C=0 Bitmap:1100001
          |-----W=1, FCN=4-----&gt;|MIC checked: success =&gt;
          |&lt;---- ACK, W=1 ------|C=1, no Bitmap

</pre>
<p class="figure">Figure 31: Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-NoLoss" class="xref">Figure 32</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no loss.</p>
<div id="rfc.figure.32"></div>
<div id="Fig-Example-Rel-Window-ACK-NoLoss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2-----&gt;|
          |-----W=0, FCN=1-----&gt;|
          |-----W=0, FCN=0-----&gt;|
          |&lt;-----ACK, W=0-------| Bitmap:1111111
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|   
          |-----W=1, FCN=4-----&gt;|
          |--W=1, FCN=7 + MIC--&gt;|MIC checked: success =&gt;
          |&lt;-----ACK, W=1-------| C=1 no Bitmap
        (End)    

</pre>
<p class="figure">Figure 32: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no lost fragment.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss" class="xref">Figure 33</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<div id="rfc.figure.33"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4--X--&gt;|
          |-----W=1, FCN=3-----&gt;|
          |-----W=1, FCN=2--X--&gt;|             7
          |-----W=1, FCN=1-----&gt;|             /
          |-----W=1, FCN=0-----&gt;|       6543210
          |&lt;-----ACK, W=1-------|Bitmap:1101011
          |-----W=1, FCN=4-----&gt;|
          |-----W=1, FCN=2-----&gt;|
          |&lt;-----ACK, W=1-------|Bitmap:
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|   
          |-----W=0, FCN=4--X--&gt;|
          |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
          |&lt;-----ACK, W=0-------| C= 0 Bitmap:11000001
          |-----W=0, FCN=4-----&gt;|MIC checked: success =&gt;
          |&lt;-----ACK, W=0-------| C= 1 no Bitmap
        (End)    

</pre>
<p class="figure">Figure 33: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-A" class="xref">Figure 34</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments and only one retry needed to recover each lost fragment.</p>
<div id="rfc.figure.34"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-A"></div>
<pre>
          Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C= 0 Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |&lt;-----ACK, W=0-------|C=1 no Bitmap
           (End)
</pre>
<p class="figure">Figure 34: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, three lost framents and only one retry needed for each lost fragment.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-B" class="xref">Figure 35</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost.</p>
<div id="rfc.figure.35"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-B"></div>
<pre>
          Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C=0  Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |  X---ACK, W=0-------|C= 1 no Bitmap
    timeout  |                     |
             |--W=0, FCN=7 + MIC--&gt;|
             |&lt;-----ACK, W=0-------|C= 1 no Bitmap  

           (End)
</pre>
<p class="figure">Figure 35: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-C" class="xref">Figure 36</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again.</p>
<div id="rfc.figure.36"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-C"></div>
<pre>
           Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C=0 Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2--X--&gt;|
      timeout|                     |
             |--W=0, FCN=7 + MIC--&gt;|All-0 empty
             |&lt;-----ACK, W=0-------|C=0 Bitmap: 1111101
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |&lt;-----ACK, W=0-------|C=1 no Bitmap
           (End)
</pre>
<p class="figure">Figure 36: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again.</p>
<p><a href="#Fig-Example-MaxWindFCN" class="xref">Figure 37</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments. Note that MAX_WIND_FCN=23 may be useful when the maximum possible Bitmap size, considering the maximum lower layer technology payload size and the value of R, is 3 bytes. Note also that the FCN of the last fragment of the packet is the one with FCN=31 (i.e. FCN=2^N-1 for N=5, or equivalently, all FCN bits set to 1).</p>
<div id="rfc.figure.37"></div>
<div id="Fig-Example-MaxWindFCN"></div>
<pre>
      Sender               Receiver
        |-----W=0, FCN=23-----&gt;|
        |-----W=0, FCN=22-----&gt;|
        |-----W=0, FCN=21--X--&gt;|
        |-----W=0, FCN=20-----&gt;|
        |-----W=0, FCN=19-----&gt;|
        |-----W=0, FCN=18-----&gt;|
        |-----W=0, FCN=17-----&gt;|
        |-----W=0, FCN=16-----&gt;|
        |-----W=0, FCN=15-----&gt;|
        |-----W=0, FCN=14-----&gt;|
        |-----W=0, FCN=13-----&gt;|
        |-----W=0, FCN=12-----&gt;|
        |-----W=0, FCN=11-----&gt;|
        |-----W=0, FCN=10--X--&gt;|
        |-----W=0, FCN=9 -----&gt;|
        |-----W=0, FCN=8 -----&gt;|
        |-----W=0, FCN=7 -----&gt;|
        |-----W=0, FCN=6 -----&gt;|
        |-----W=0, FCN=5 -----&gt;|
        |-----W=0, FCN=4 -----&gt;|
        |-----W=0, FCN=3 -----&gt;|
        |-----W=0, FCN=2 -----&gt;|
        |-----W=0, FCN=1 -----&gt;|
        |-----W=0, FCN=0 -----&gt;|
        |                      |lcl-Bitmap:110111111111101111111111
        |&lt;------ACK, W=0-------|encoded Bitmap:1101111111111011
        |-----W=0, FCN=21-----&gt;|
        |-----W=0, FCN=10-----&gt;|
        |&lt;------ACK, W=0-------|no Bitmap
        |-----W=1, FCN=23-----&gt;|
        |-----W=1, FCN=22-----&gt;|
        |-----W=1, FCN=21-----&gt;|
        |--W=1, FCN=31 + MIC--&gt;|MIC checked: sucess =&gt;
        |&lt;------ACK, W=1-------|no Bitmap
      (End)
</pre>
<p class="figure">Figure 37: Transmission in ACK-Always mode of an IPv6 packet carried by 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#FSM" id="FSM">Fragmentation State Machines</a>
</h1>
<p id="rfc.section.C.p.1">The fragmentation state machines of the sender and the receiver, one for each of the different reliability modes, are described in the following figures:</p>
<div id="rfc.figure.38"></div>
<div id="Fig-NoACKModeSnd"></div>
<pre>
             +===========+
+------------+  Init     |                                      
|  FCN=0     +===========+                                      
|  No Window                                       
|  No Bitmap                                                      
|                   +-------+           
|          +========+==+    | More Fragments                 
|          |           | &lt;--+ ~~~~~~~~~~~~~~~~~~~~                          
+--------&gt; |   Send    |      send Fragment (FCN=0)                            
           +===+=======+                                                                      
               |  last fragment
               |  ~~~~~~~~~~~~                               
               |  FCN = 1                               
               v  send fragment+MIC
           +============+                                             
           |    END     |                                             
           +============+                       
</pre>
<p class="figure">Figure 38: Sender State Machine for the No-ACK Mode</p>
<div id="rfc.figure.39"></div>
<div id="Fig-NoACKModeRcv"></div>
<pre>
                      +------+ Not All-1
           +==========+=+    | ~~~~~~~~~~~~~~~~~~~
           |            + &lt;--+ set Inactivity Timer
           |  RCV Frag  +-------+
           +=+===+======+       |All-1 &amp;
   All-1 &amp;   |   |              |MIC correct
 MIC wrong   |   |Inactivity    |
             |   |Timer Exp.    |
             v   |              |
  +==========++  |              v
  |   Error   |&lt;-+     +========+==+
  +===========+        |    END    |
                       +===========+

</pre>
<p class="figure">Figure 39: Receiver State Machine for the No-ACK Mode</p>
<div id="rfc.figure.40"></div>
<div id="Fig-ACKAlwaysSnd"></div>
<pre>
              +=======+  
              | INIT  |       FCN!=0 &amp; more frags
              |       |       ~~~~~~~~~~~~~~~~~~~~~~
              +======++  +--+ send Window + frag(FCN)
                 W=0 |   |  | FCN-
  Clear local Bitmap |   |  v set local Bitmap
       FCN=max value |  ++==+========+
                     +&gt; |            |
+---------------------&gt; |    SEND    |
|                       +==+===+=====+
|      FCN==0 &amp; more frags |   | last frag
|    ~~~~~~~~~~~~~~~~~~~~~ |   | ~~~~~~~~~~~~~~~
|         set local-Bitmap |   | set local-Bitmap
|   send wnd + frag(all-0) |   | send wnd+frag(all-1)+MIC
|       set Retrans_Timer  |   | set Retrans_Timer
|                          |   |
|Recv_wnd == wnd &amp;         |   |  
|Lcl_Bitmap==recv_Bitmap&amp;  |   |  +----------------------+
|more frag                 |   |  |lcl-Bitmap!=rcv-Bitmap|
|~~~~~~~~~~~~~~~~~~~~~~    |   |  | ~~~~~~~~~            |
|Stop Retrans_Timer        |   |  | Attemp++             v
|clear local_Bitmap        v   v  |                +=====+=+
|window=next_window   +====+===+==+===+            |Resend |
+---------------------+               |            |Missing|
                 +----+     Wait      |            |Frag   |
not expected wnd |    |    Bitmap     |            +=======+
~~~~~~~~~~~~~~~~ +---&gt;+               ++Retrans_Timer Exp  |          
    discard frag      +==+=+===+=+==+=+| ~~~~~~~~~~~~~~~~~ |
                         | |   | ^  ^  |reSend(empty)All-* |   
                         | |   | |  |  |Set Retrans_Timer  |
MIC_bit==1 &amp;             | |   | |  +--+Attemp++           |
Recv_window==window &amp;    | |   | +-------------------------+   
Lcl_Bitmap==recv_Bitmap &amp;| |   |   all missing frag sent
             no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~
 ~~~~~~~~~~~~~~~~~~~~~~~~| |&#160;  | &#160; Set Retrans_Timer &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;
       Stop Retrans_Timer| |   |    
 +=============+         | |   |
 |     END     +&lt;--------+ |   | Attemp &gt; MAX_ACK_REQUESTS
 +=============+           |   | ~~~~~~~~~~~~~~~~~~
              All-1 Window |   v Send Abort
 &#160; &#160; &#160; &#160; &#160; &#160;  ~~~~~~~~~~~~ | +=+===========+
             MIC_bit ==0 &amp; +&gt;|    ERROR    |
    Lcl_Bitmap==recv_Bitmap  +=============+


</pre>
<p class="figure">Figure 40: Sender State Machine for the ACK-Always Mode</p>
<div id="rfc.figure.41"></div>
<div id="Fig-ACKAlwaysRcv"></div>
<pre>
 Not All- &amp; w=expected +---+   +---+w = Not expected
 ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
 Set local_Bitmap(FCN) |   v   v   |discard
                      ++===+===+===+=+      
+---------------------+ &#160; &#160; Rcv &#160; &#160;  +---&gt;* ABORT
|  +------------------+ &#160; Window &#160; &#160; |
|  | &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;  +=====+==+=====+  
|  | &#160; &#160; &#160; All-0 &amp; w=expect | &#160;^ w =next &amp; not-All
|  |     ~~~~~~~~~~~~~~~~~~ |  |~~~~~~~~~~~~~~~~~~~~~
|  |     set lcl_Bitmap(FCN)|  |expected = next window
|  |      send local_Bitmap |  |Clear local_Bitmap
|  |                        |  |    
|  | w=expct &amp; not-All      |  |    
|  | ~~~~~~~~~~~~~~~~~~     |  |
|  | set lcl_Bitmap(FCN)+-+ |  | +--+ w=next &amp; All-0
|  | if lcl_Bitmap full | | |  | |  | ~~~~~~~~~~~~~~~
|  | send lcl_Bitmap    | | |  | |  | expct = nxt wnd
|  |                    v | v  | |  | Clear lcl_Bitmap
|  |  w=expct &amp; All-1 +=+=+=+==+=++ | set lcl_Bitmap(FCN)     
|  |  ~~~~~~~~~~~  +-&gt;+    Wait   +&lt;+ send lcl_Bitmap       
|  |    discard    +--|    Next   |   
|  | All-0  +---------+  Window   +---&gt;* ABORT  
|  | ~~~~~  +--------&gt;+========+=++        
|  | snd lcl_bm  All-1 &amp; w=next| |  All-1 &amp; w=nxt
|  |                &amp; MIC wrong| |  &amp; MIC right      
|  |          ~~~~~~~~~~~~~~~~~| | ~~~~~~~~~~~~~~~~~~
|  |      set local_Bitmap(FCN)| |set lcl_Bitmap(FCN)       
|  |          send local_Bitmap| |send local_Bitmap
|  |                           | +----------------------+
|  |All-1 &amp; w=expct            |                        |
|  |&amp; MIC wrong                v   +---+ w=expctd &amp;     |
|  |~~~~~~~~~~~~~~~~~~~~  +====+=====+ | MIC wrong      |
|  |set local_Bitmap(FCN) |          +&lt;+ ~~~~~~~~~~~~~~ |
|  |send local_Bitmap     | Wait End | set lcl_btmp(FCN)|
|  +---------------------&gt;+          +---&gt;* ABORT       |
|                         +===+====+=+-+ All-1&amp;MIC wrong|
|                             |    ^   | ~~~~~~~~~~~~~~~|
|      w=expected &amp; MIC right |    +---+ send lcl_btmp  |                
|      ~~~~~~~~~~~~~~~~~~~~~~ |                         |
|       set local_Bitmap(FCN) | +-+ Not All-1           |
|        send local_Bitmap    | | | ~~~~~~~~~           |
|                             | | |  discard            |
|All-1 &amp; w=expctd &amp; MIC right | | |                     |
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v | v +----+All-1         |
|set local_Bitmap(FCN)      +=+=+=+=+==+ |~~~~~~~~~     |
|send local_Bitmap          |          +&lt;+Send lcl_btmp |
+--------------------------&gt;+    END   |                |
                            +==========+&lt;---------------+

       ---&gt;* ABORT
 &#160; &#160; &#160; &#160; &#160; &#160;~~~~~~~
            Inactivity_Timer = expires
        When DWN_Link
          IF Inactivity_Timer expires
             Send DWL Request
             Attemp++
 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;
</pre>
<p class="figure">Figure 41: Receiver State Machine for the ACK-Always Mode</p>
<div id="rfc.figure.42"></div>
<div id="Fig-ACKonerrorSnd"></div>
<pre>
                   +=======+  
                   |       |  
                   | INIT  |  
                   |       |        FCN!=0 &amp; more frags
                   +======++  +--+  ~~~~~~~~~~~~~~~~~~~~~~
                      W=0 |   |  |  send Window + frag(FCN)
       ~~~~~~~~~~~~~~~~~~ |   |  |  FCN-
       Clear local Bitmap |   |  v  set local Bitmap
            FCN=max value |  ++=============+
                          +&gt; |              |
                             |     SEND     |
 +-------------------------&gt; |              |
 |                           ++=====+=======+
 |         FCN==0 &amp; more frags|     |last frag
 |     ~~~~~~~~~~~~~~~~~~~~~~~|     |~~~~~~~~~~~~~~~~~
 |            set local-Bitmap|     |set local-Bitmap
 |      send wnd + frag(all-0)|     |send wnd+frag(all-1)+MIC
 |           set Retrans_Timer|     |set Retrans_Timer
 |                            |     |
 |Retrans_Timer expires &amp;     |     |   lcl-Bitmap!=rcv-Bitmap
 |more fragments &#160; &#160; &#160; &#160; &#160; &#160;  | &#160; &#160; | &#160; ~~~~~~~~~~~~~~~~~~~~~~
 |~~~~~~~~~~~~~~~~~~~~        |     |   Attemp++        
 |stop Retrans_Timer          |     |  +-----------------+
 |clear local-Bitmap          v     v  |                 v
 |window = next window  +=====+=====+==+==+         +====+====+
 +----------------------+                 +         | Resend  |
 +---------------------&gt;+    Wait Bitmap  |         | Missing |
 |                  +-- +                 |         | Frag    |
 | not expected wnd |   ++=+===+===+===+==+         +======+==+
 | ~~~~~~~~~~~~~~~~ |    ^ |   |   |   ^                   |
 |    discard frag  +----+ |   |   |   +-------------------+
 |                         |   |   |     all missing frag sent
 |Retrans_Timer expires &amp;  |   |   |     ~~~~~~~~~~~~~~~~~~~~~
 |       No more Frag      |   |   |     Set Retrans_Timer
 | ~~~~~~~~~~~~~~~~~~~~~~~ |   |   |   
 |  Stop Retrans_Timer     | &#160; | &#160; | &#160;
 |  Send ALL-1-empty       |   |   |
 +-------------------------+   |   |
                               |   |
      Local_Bitmap==Recv_Bitmap|   |
 &#160; &#160;  ~~~~~~~~~~~~~~~~~~~~~~~~~| &#160; |Attemp &gt; MAX_ACK_REQUESTS
 +=========+Stop Retrans_Timer&#160;| &#160; |~~~~~~~~~~~~~~~~~~~~~~~
 |   END   +&lt;------------------+   v  Send Abort
 +=========+                     +=+=========+
                                 |   ERROR   |
                                 +===========+                                      
</pre>
<p class="figure">Figure 42: Sender State Machine for the ACK-on-Error Mode</p>
<div id="rfc.figure.43"></div>
<div id="Fig-ACKonerrorRcv"></div>
<pre>
   Not All- &amp; w=expected +---+   +---+w = Not expected
   ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
   Set local_Bitmap(FCN) |   v   v   |discard
                        ++===+===+===+=+
+-----------------------+              +--+ All-0 &amp; full
|            ABORT *&lt;---+  Rcv Window  |  | ~~~~~~~~~~~~
|  +--------------------+              +&lt;-+ w =next
|  | &#160; &#160; All-0 empty +-&gt;+=+=+===+======+ clear lcl_Bitmap
|  | &#160; &#160; ~~~~~~~~~~~ | &#160;  | | &#160; ^
|  |     send bitmap +----+ |   |w=expct &amp; not-All &amp; full
|  |                        |   |~~~~~~~~~~~~~~~~~~~~~~~~
|  |                        |   |set lcl_Bitmap; w =nxt
|  |                        |   |     
|  |      All-0 &amp; w=expect  |   |     w=next   
|  |      &amp; no_full Bitmap  |   |    ~~~~~~~~  +========+
|  |      ~~~~~~~~~~~~~~~~~ |   |    Send abort| Error/ |
|  |      send local_Bitmap |   |  +----------&gt;+ Abort  |
|  |                        |   |  | +--------&gt;+========+
|  | &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;  v &#160; |  | | &#160; all-1       ^
|  | &#160;  All-0 empty &#160;  +====+===+==+=+=+ ~~~~~~~  &#160;  |        
|  |  ~~~~~~~~~~~~~ +--+    Wait       | Send abort  |
|  |  send lcl_btmp +-&gt;| Missing Fragm.|             |
|  |                   +==============++             |
|  |                             &#160;  &#160; +--------------+
|  |                                   Uplink Only &amp;
|  |                             Inactivity_Timer = expires
|  | &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ~~~~~~~~~~~~~~~~~~~~~~~~~~
|  |                              Send Abort
|  |All-1 &amp; w=expect &amp; MIC wrong &#160;   
|  |~~~~~~~~~~~~~~~~~~~~~~~~~~~~      +-+  All-1       
|  |set local_Bitmap(FCN)             | v  ~~~~~~~~~~  
|  |send local_Bitmap     +===========+==+ snd lcl_btmp
|  +---------------------&gt;+   Wait End   +-+           
|                         +=====+=+====+=+ | w=expct &amp;  
|       w=expected &amp; MIC right  | |    ^   | MIC wrong
|       ~~~~~~~~~~~~~~~~~~~~~~  | |    +---+ ~~~~~~~~~
|  set &amp; send local_Bitmap(FCN) | | set lcl_Bitmap(FCN)
|                               | |                    
|All-1 &amp; w=expected &amp; MIC right | +--&gt;* ABORT          
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v                      
|set &amp; send local_Bitmap(FCN) +=+==========+           
+----------------------------&gt;+     END    |
                              +============+   
            ---&gt;* ABORT
                 Only Uplink
                 Inactivity_Timer = expires&#160;
 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ~~~~~~~~~~~~~~~~~~~~~~~~~~
 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; Send Abort &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;
</pre>
<p class="figure">Figure 43: Receiver State Machine for the ACK-on-Error Mode</p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#schc-parameters-ticket-15" id="schc-parameters-ticket-15">SCHC Parameters - Ticket #15</a>
</h1>
<p id="rfc.section.D.p.1">This section gives the list of parameters that need to be defined in the technology-specific documents, technology developers must evaluate that L2 has strong enough integrity checking to match SCHC&#8217;s assumption:</p>
<p></p>

<ul>
<li>LPWAN Architecture. Explain the SCHC entities (Compression and Fragmentation), how/where are they be represented in the corresponding technology architecture.</li>
<li>L2 fragmentation decision</li>
<li>Rule ID number of rules</li>
<li>Size of the Rule ID</li>
<li>The way the Rule ID is sent (L2 or L3) and how (describe)</li>
<li>Fragmentation delivery reliability mode used in which cases</li>
<li>Define the number of bits FCN (N) and DTag (T)</li>
<li>The MIC algorithm to be used and the size if different from the default CRC32</li>
<li>Retransmission Timer duration</li>
<li>Inactivity Timer duration</li>
<li>Define the MAX_ACK_REQUEST (number of attempts)</li>
<li>Use of padding or not and how and when to use it</li>
<li>Take into account that the length of rule-id + N + T + W when possible is good to have a multiple of 8 bits to complete a byte and avoid padding</li>
<li>In the ACK format to have a length for Rule-ID + T + W bit into a complete number of byte to do optimization more easily</li>
<li>The technology documents will describe if Rule ID is constrained by any alignment</li>
</ul>
<p id="rfc.section.D.p.3">And the following parameters need to be addressed in another document but not forcely in the technology-specific one:</p>
<p></p>

<ul>
<li>The way the contexts are provisioning</li>
<li>The way the Rules as generated</li>
</ul>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#note" id="note">Note</a>
</h1>
<p id="rfc.section.E.p.1">Carles Gomez has been funded in part by the Spanish Government (Ministerio de Educacion, Cultura y Deporte) through the Jose Castillejo grant CAS15/00336, and by the ERDF and the Spanish Government through project TEC2016-79988-P.  Part of his contribution to this work has been carried out during his stay as a visiting scholar at the Computer Laboratory of the University of Cambridge.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ana Minaburo</span> 
	  <span class="n hidden">
		<span class="family-name">Minaburo</span>
	  </span>
	</span>
	<span class="org vcardline">Acklio</span>
	<span class="adr">
	  <span class="vcardline">2bis rue de la Chataigneraie</span>

	  <span class="vcardline">
		<span class="locality">35510 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ana@ackl.io">ana@ackl.io</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Laurent Toutain</span> 
	  <span class="n hidden">
		<span class="family-name">Toutain</span>
	  </span>
	</span>
	<span class="org vcardline">IMT-Atlantique</span>
	<span class="adr">
	  <span class="vcardline">2 rue de la Chataigneraie</span>
<span class="vcardline">CS 17607</span>

	  <span class="vcardline">
		<span class="locality">35576 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Laurent.Toutain@imt-atlantique.fr">Laurent.Toutain@imt-atlantique.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carles Gomez</span> 
	  <span class="n hidden">
		<span class="family-name">Gomez</span>
	  </span>
	</span>
	<span class="org vcardline">Universitat Polit&#232;cnica de Catalunya</span>
	<span class="adr">
	  <span class="vcardline">C/Esteve Terradas, 7</span>
<span class="vcardline">08860 Castelldefels</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Spain</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:carlesgo@entel.upc.edu">carlesgo@entel.upc.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dominique Barthel</span> 
	  <span class="n hidden">
		<span class="family-name">Barthel</span>
	  </span>
	</span>
	<span class="org vcardline">Orange Labs</span>
	<span class="adr">
	  <span class="vcardline">28 chemin du Vieux Ch&#234;ne</span>
<span class="vcardline">38243 Meylan, France</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dominique.barthel@orange.com">dominique.barthel@orange.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/lp-wan/ip-compression">Fork me on GitHub</a></div></div>
</body>
</html>
