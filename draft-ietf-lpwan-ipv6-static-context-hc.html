<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Requirements Notation">
<link href="#rfc.section.3" rel="Chapter" title="3 LPWAN Architecture">
<link href="#rfc.section.4" rel="Chapter" title="4 Terminology">
<link href="#rfc.section.5" rel="Chapter" title="5 SCHC overview">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 SCHC Packet format">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Functional mapping">
<link href="#rfc.section.6" rel="Chapter" title="6 Rule ID">
<link href="#rfc.section.7" rel="Chapter" title="7 Compression/Decompression">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 SCHC C/D Rules">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Rule ID for SCHC C/D">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Packet processing">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Matching operators">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Compression Decompression Actions (CDA)">
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 processing variable-length fields">
<link href="#rfc.section.7.5.2" rel="Chapter" title="7.5.2 not-sent CDA">
<link href="#rfc.section.7.5.3" rel="Chapter" title="7.5.3 value-sent CDA">
<link href="#rfc.section.7.5.4" rel="Chapter" title="7.5.4 mapping-sent CDA">
<link href="#rfc.section.7.5.5" rel="Chapter" title="7.5.5 LSB CDA">
<link href="#rfc.section.7.5.6" rel="Chapter" title="7.5.6 DevIID, AppIID CDA">
<link href="#rfc.section.7.5.7" rel="Chapter" title="7.5.7 Compute-*">
<link href="#rfc.section.8" rel="Chapter" title="8 Fragmentation/Reassembly">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Overview">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 SCHC F/R Tools">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 Messages">
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 Tiles, Windows, Bitmaps, Timers, Counters">
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 Integrity Checking">
<link href="#rfc.section.8.2.4" rel="Chapter" title="8.2.4 Header Fields">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 SCHC F/R Message Formats">
<link href="#rfc.section.8.3.1" rel="Chapter" title="8.3.1 SCHC Fragment format">
<link href="#rfc.section.8.3.2" rel="Chapter" title="8.3.2 SCHC ACK format">
<link href="#rfc.section.8.3.3" rel="Chapter" title="8.3.3 SCHC ACK REQ format">
<link href="#rfc.section.8.3.4" rel="Chapter" title="8.3.4 SCHC Abort formats">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 SCHC F/R modes">
<link href="#rfc.section.8.4.1" rel="Chapter" title="8.4.1 No-ACK mode">
<link href="#rfc.section.8.4.2" rel="Chapter" title="8.4.2 ACK-Always">
<link href="#rfc.section.8.4.3" rel="Chapter" title="8.4.3 ACK-on-Error">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Supporting multiple window sizes">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Downlink SCHC Fragment transmission">
<link href="#rfc.section.9" rel="Chapter" title="9 Padding management">
<link href="#rfc.section.10" rel="Chapter" title="10 SCHC Compression for IPv6 and UDP headers">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 IPv6 version field">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 IPv6 Traffic class field">
<link href="#rfc.section.10.3" rel="Chapter" title="10.3 Flow label field">
<link href="#rfc.section.10.4" rel="Chapter" title="10.4 Payload Length field">
<link href="#rfc.section.10.5" rel="Chapter" title="10.5 Next Header field">
<link href="#rfc.section.10.6" rel="Chapter" title="10.6 Hop Limit field">
<link href="#rfc.section.10.7" rel="Chapter" title="10.7 IPv6 addresses fields">
<link href="#rfc.section.10.7.1" rel="Chapter" title="10.7.1 IPv6 source and destination prefixes">
<link href="#rfc.section.10.7.2" rel="Chapter" title="10.7.2 IPv6 source and destination IID">
<link href="#rfc.section.10.8" rel="Chapter" title="10.8 IPv6 extensions">
<link href="#rfc.section.10.9" rel="Chapter" title="10.9 UDP source and destination port">
<link href="#rfc.section.10.10" rel="Chapter" title="10.10 UDP length field">
<link href="#rfc.section.10.11" rel="Chapter" title="10.11 UDP Checksum field">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security considerations">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Security considerations for SCHC Compression/Decompression">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Security considerations for SCHC Fragmentation/Reassembly">
<link href="#rfc.section.13" rel="Chapter" title="13 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="14 References">
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A SCHC Compression Examples">
<link href="#rfc.appendix.B" rel="Chapter" title="B Fragmentation Examples">
<link href="#rfc.appendix.C" rel="Chapter" title="C Fragmentation State Machines">
<link href="#rfc.appendix.D" rel="Chapter" title="D SCHC Parameters">
<link href="#rfc.appendix.E" rel="Chapter" title="E Note">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.11.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Minaburo, A., Toutain, L., Gomez, C., and D. Barthel" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-lpwan-ipv6-static-context-hc-16" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-10-15" />
  <meta name="dct.abstract" content="This document defines the Static Context Header Compression (SCHC) framework, which provides both header compression and fragmentation functionalities. SCHC has been designed for Low Power Wide Area Networks (LPWAN)." />
  <meta name="description" content="This document defines the Static Context Header Compression (SCHC) framework, which provides both header compression and fragmentation functionalities. SCHC has been designed for Low Power Wide Area Networks (LPWAN)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">lpwan Working Group</td>
<td class="right">A. Minaburo</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Acklio</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">L. Toutain</td>
</tr>
<tr>
<td class="left">Expires: April 18, 2019</td>
<td class="right">IMT-Atlantique</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Gomez</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Universitat Polit&#232;cnica de Catalunya</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">D. Barthel</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Orange Labs</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 15, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">LPWAN Static Context Header Compression (SCHC) and fragmentation for IPv6 and UDP<br />
  <span class="filename">draft-ietf-lpwan-ipv6-static-context-hc-16</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines the Static Context Header Compression (SCHC) framework, which provides both header compression and fragmentation functionalities. SCHC has been designed for Low Power Wide Area Networks (LPWAN).</p>
<p>SCHC compression is based on a common static context stored in both the LPWAN device and the network side. This document defines a header compression mechanism and its application to compress IPv6/UDP headers.</p>
<p>This document also specifies a fragmentation and reassembly mechanism that is used to support the IPv6 MTU requirement over the LPWAN technologies. Fragmentation is needed for IPv6 datagrams that, after SCHC compression or when such compression was not possible, still exceed the layer-2 maximum payload size.</p>
<p>The SCHC header compression and fragmentation mechanisms are independent of the specific LPWAN technology over which they are used. This document defines generic functionalities and offers flexibility with regard to parameter settings and mechanism choices. Technology-specific settings and choices are expected to be grouped into Profiles specified in other documents.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 18, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Requirements Notation</a>
</li>
<li>3.   <a href="#rfc.section.3">LPWAN Architecture</a>
</li>
<li>4.   <a href="#rfc.section.4">Terminology</a>
</li>
<li>5.   <a href="#rfc.section.5">SCHC overview</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">SCHC Packet format</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Functional mapping</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Rule ID</a>
</li>
<li>7.   <a href="#rfc.section.7">Compression/Decompression</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">SCHC C/D Rules</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Rule ID for SCHC C/D</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Packet processing</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Matching operators</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Compression Decompression Actions (CDA)</a>
</li>
<ul><li>7.5.1.   <a href="#rfc.section.7.5.1">processing variable-length fields</a>
</li>
<li>7.5.2.   <a href="#rfc.section.7.5.2">not-sent CDA</a>
</li>
<li>7.5.3.   <a href="#rfc.section.7.5.3">value-sent CDA</a>
</li>
<li>7.5.4.   <a href="#rfc.section.7.5.4">mapping-sent CDA</a>
</li>
<li>7.5.5.   <a href="#rfc.section.7.5.5">LSB CDA</a>
</li>
<li>7.5.6.   <a href="#rfc.section.7.5.6">DevIID, AppIID CDA</a>
</li>
<li>7.5.7.   <a href="#rfc.section.7.5.7">Compute-*</a>
</li>
</ul></ul><li>8.   <a href="#rfc.section.8">Fragmentation/Reassembly</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Overview</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">SCHC F/R Tools</a>
</li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">Messages</a>
</li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">Tiles, Windows, Bitmaps, Timers, Counters</a>
</li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">Integrity Checking</a>
</li>
<li>8.2.4.   <a href="#rfc.section.8.2.4">Header Fields</a>
</li>
</ul><li>8.3.   <a href="#rfc.section.8.3">SCHC F/R Message Formats</a>
</li>
<ul><li>8.3.1.   <a href="#rfc.section.8.3.1">SCHC Fragment format</a>
</li>
<li>8.3.2.   <a href="#rfc.section.8.3.2">SCHC ACK format</a>
</li>
<li>8.3.3.   <a href="#rfc.section.8.3.3">SCHC ACK REQ format</a>
</li>
<li>8.3.4.   <a href="#rfc.section.8.3.4">SCHC Abort formats</a>
</li>
</ul><li>8.4.   <a href="#rfc.section.8.4">SCHC F/R modes</a>
</li>
<ul><li>8.4.1.   <a href="#rfc.section.8.4.1">No-ACK mode</a>
</li>
<li>8.4.2.   <a href="#rfc.section.8.4.2">ACK-Always</a>
</li>
<li>8.4.3.   <a href="#rfc.section.8.4.3">ACK-on-Error</a>
</li>
</ul><li>8.5.   <a href="#rfc.section.8.5">Supporting multiple window sizes</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">Downlink SCHC Fragment transmission</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Padding management</a>
</li>
<li>10.   <a href="#rfc.section.10">SCHC Compression for IPv6 and UDP headers</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">IPv6 version field</a>
</li>
<li>10.2.   <a href="#rfc.section.10.2">IPv6 Traffic class field</a>
</li>
<li>10.3.   <a href="#rfc.section.10.3">Flow label field</a>
</li>
<li>10.4.   <a href="#rfc.section.10.4">Payload Length field</a>
</li>
<li>10.5.   <a href="#rfc.section.10.5">Next Header field</a>
</li>
<li>10.6.   <a href="#rfc.section.10.6">Hop Limit field</a>
</li>
<li>10.7.   <a href="#rfc.section.10.7">IPv6 addresses fields</a>
</li>
<ul><li>10.7.1.   <a href="#rfc.section.10.7.1">IPv6 source and destination prefixes</a>
</li>
<li>10.7.2.   <a href="#rfc.section.10.7.2">IPv6 source and destination IID</a>
</li>
</ul><li>10.8.   <a href="#rfc.section.10.8">IPv6 extensions</a>
</li>
<li>10.9.   <a href="#rfc.section.10.9">UDP source and destination port</a>
</li>
<li>10.10.   <a href="#rfc.section.10.10">UDP length field</a>
</li>
<li>10.11.   <a href="#rfc.section.10.11">UDP Checksum field</a>
</li>
</ul><li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security considerations</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Security considerations for SCHC Compression/Decompression</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Security considerations for SCHC Fragmentation/Reassembly</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">Acknowledgements</a>
</li>
<li>14.   <a href="#rfc.references">References</a>
</li>
<ul><li>14.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">SCHC Compression Examples</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Fragmentation Examples</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Fragmentation State Machines</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">SCHC Parameters</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Note</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This document defines the Static Context Header Compression (SCHC) framework, which provides both header compression and fragmentation functionalities. SCHC has been designed for Low Power Wide Area Networks (LPWAN).</p>
<p id="rfc.section.1.p.2">Header compression is needed for efficient Internet connectivity to the node within an LPWAN network. Some LPWAN networks properties can be exploited to get an efficient header compression:</p>
<p></p>

<ul>
<li>The network topology is star-oriented, which means that all packets between the same source-destination pair follow the same path. For the needs of this document, the architecture can simply be described as Devices (Dev) exchanging information with LPWAN Application Servers (App) through a Network Gateway (NGW).</li>
<li>Because devices embed built-in applications, the traffic flows to be compressed are known in advance. Indeed, new applications cannot be easily installed in LPWAN devices, as they would in computers or smartphones.</li>
</ul>
<p id="rfc.section.1.p.4">SCHC compression uses a context in which information about header fields is stored. This context is static: the values of the header fields do not change over time. This avoids complex resynchronization mechanisms, that would be incompatible with LPWAN characteristics. In most cases, a small context identifier is enough to represent the full IPv6/UDP headers. The SCHC header compression mechanism is independent of the specific LPWAN technology over which it is used.</p>
<p id="rfc.section.1.p.5">LPWAN technologies impose some strict limitations on traffic. For instance, devices are sleeping most of the time and may receive data during short periods of time after transmission to preserve battery. LPWAN technologies are also characterized by a greatly reduced data unit and/or payload size (see <a href="#RFC8376" class="xref">[RFC8376]</a>).  However, some LPWAN technologies do not provide fragmentation functionality; to support the IPv6 MTU requirement of 1280 bytes <a href="#RFC8200" class="xref">[RFC8200]</a>, they require a fragmentation protocol at the adaptation layer below IPv6.  Accordingly, this document defines an fragmentation/reassembly mechanism for LPWAN technologies to supports the IPv6 MTU. Its implementation is optional. If not interested, the reader can safely skip its description.</p>
<p id="rfc.section.1.p.6">This document defines generic functionality and offers flexibility with regard to parameters settings and mechanism choices. Technology-specific settings and choices are expected to be grouped into Profiles specified in other documents.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#requirements-notation" id="requirements-notation">Requirements Notation</a>
</h1>
<p id="rfc.section.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#LPWAN-Archi" id="LPWAN-Archi">LPWAN Architecture</a>
</h1>
<p id="rfc.section.3.p.1">LPWAN technologies have similar network architectures but different terminologies.  Using the terminology defined in <a href="#RFC8376" class="xref">[RFC8376]</a>, we can identify different types of entities in a typical LPWAN network, see <a href="#Fig-LPWANarchi" class="xref">Figure 1</a>:</p>
<p id="rfc.section.3.p.2">o  Devices (Dev) are the end-devices or hosts (e.g. sensors, actuators, etc.). There can be a very high density of devices per radio gateway.</p>
<p id="rfc.section.3.p.3">o  The Radio Gateway (RGW), which is the end point of the constrained link.</p>
<p id="rfc.section.3.p.4">o  The Network Gateway (NGW) is the interconnection node between the Radio Gateway and the Internet.</p>
<p id="rfc.section.3.p.5">o  LPWAN-AAA Server, which controls the user authentication and the applications.</p>
<p id="rfc.section.3.p.6">o  Application Server (App)</p>
<div id="rfc.figure.1"></div>
<div id="Fig-LPWANarchi"></div>
<pre>
                                           +------+
 ()   ()   ()       |                      |LPWAN-|
  ()  () () ()     / \       +---------+   | AAA  |
() () () () () () /   \======|    ^    |===|Server|  +-----------+
 ()  ()   ()     |           | &lt;--|--&gt; |   +------+  |APPLICATION|
()  ()  ()  ()  / \==========|    v    |=============|   (App)   |
  ()  ()  ()   /   \         +---------+             +-----------+
 Dev        Radio Gateways         NGW

</pre>
<p class="figure">Figure 1: LPWAN Architecture</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#Term" id="Term">Terminology</a>
</h1>
<p id="rfc.section.4.p.1">This section defines the terminology and acronyms used in this document.</p>
<p id="rfc.section.4.p.2">Note that the SCHC acronym is pronounced like &#8220;sheek&#8221; in English (or &#8220;chic&#8221; in French). Therefore, this document writes &#8220;a SCHC Packet&#8221; instead of &#8220;an SCHC Packet&#8221;.</p>
<p></p>

<ul>
<li>App: LPWAN Application. An application sending/receiving IPv6 packets to/from the Device.</li>
<li>AppIID: Application Interface Identifier. The IID that identifies the application server interface.</li>
<li>Bi: Bidirectional. Characterises a Rule Entry that applies to headers of packets travelling in either direction (Up and Dw, see this glossary).</li>
<li>CDA: Compression/Decompression Action. Describes the reciprocal pair of actions that are performed at the compressor to compress a header field and at the decompressor to recover the original header field value.</li>
<li>Compression Residue. The bits that need to be sent (beyond the Rule ID itself) after applying the SCHC compression over each header field.</li>
<li>Context: A set of Rules used to compress/decompress headers.</li>
<li>Dev: Device. A node connected to an LPWAN. A Dev SHOULD implement SCHC.</li>
<li>DevIID: Device Interface Identifier. The IID that identifies the Dev interface.</li>
<li>DI: Direction Indicator. This field tells which direction of packet travel (Up, Dw or Bi) a Rule applies to. This allows for assymmetric processing.</li>
<li>Dw: Downlink direction for compression/decompression in both sides, from SCHC C/D in the network to SCHC C/D in the Dev.</li>
<li>Field Description. A line in the Rule table.</li>
<li>FID: Field Identifier. This is an index to describe the header fields in a Rule.</li>
<li>FL: Field Length is the length of the packet header field. It is expressed in bits for header fields of fixed lengths or as a type (e.g. variable, token length, &#8230;) for field lengths that are unknown at the time of Rule creation. The length of a header field is defined in the corresponding protocol specification.</li>
<li>FP: Field Position is a value that is used to identify the position where each instance of a field appears in the header.</li>
<li>IID: Interface Identifier. See the IPv6 addressing architecture <a href="#RFC7136" class="xref">[RFC7136]</a>
</li>
<li>L2: Layer two. The immediate lower layer SCHC interfaces with. It is provided by an underlying LPWAN technology. It does not necessarily correspond to the OSI model definition of Layer 2.</li>
<li>L2 Word: this is the minimum subdivision of payload data that the L2 will carry. In most L2 technologies, the L2 Word is an octet.  In bit-oriented radio technologies, the L2 Word might be a single bit.  The L2 Word size is assumed to be constant over time for each device.</li>
<li>MO: Matching Operator. An operator used to match a value contained in a header field with a value contained in a Rule.</li>
<li>Padding (P). Extra bits that may be appended by SCHC to a data unit that it passes to the underlying Layer 2 for transmission.  SCHC itself operates on bits, not bytes, and does not have any alignment prerequisite. See <a href="#Padding" class="xref">Section 9</a>.</li>
<li>Profile: SCHC offers variations in the way it is operated, with a number of parameters listed in <a href="#SCHCParams" class="xref">Appendix D</a>.  A Profile indicates a particular setting of all these parameters.  Both ends of a SCHC session must be provisioned with the same profile information and with the same set of Rules before the session starts, so that there is no ambiguity in how they expect to communicate.</li>
<li>Rule: A set of header field values.</li>
<li>Rule entry: A column in a Rule that describes a parameter of the header field.</li>
<li>Rule ID: An identifier for a Rule. SCHC C/D on both sides share the same Rule ID for a given packet. A set of Rule IDs are used to support SCHC F/R functionality.</li>
<li>SCHC C/D: Static Context Header Compression Compressor/Decompressor. A mechanism used on both sides, at the Dev and at the network, to achieve Compression/Decompression of headers. SCHC C/D uses Rules to perform compression and decompression.</li>
<li>SCHC Packet: A packet (e.g. an IPv6 packet) whose header has been compressed as per the header compression mechanism defined in this document. If the header compression process is unable to actually compress the packet header, the packet with the uncompressed header is still called a SCHC Packet (in this case, a Rule ID is used to indicate that the packet header has not been compressed). See <a href="#SCHComp" class="xref">Section 7</a> for more details.</li>
<li>TV: Target value. A value contained in a Rule that will be matched with the value of a header field.</li>
<li>Up: Uplink direction for compression/decompression in both sides, from the Dev SCHC C/D to the network SCHC C/D.</li>
</ul>
<p id="rfc.section.4.p.4">Additional terminology for the optional SCHC Fragmentation / Reassembly mechanism (SCHC F/R) is found in <a href="#FragTools" class="xref">Section 8.2</a>.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#schc-overview" id="schc-overview">SCHC overview</a>
</h1>
<p id="rfc.section.5.p.1">SCHC can be characterized as an adaptation layer between IPv6 and the underlying LPWAN technology. SCHC comprises two sublayers (i.e. the Compression sublayer and the Fragmentation sublayer), as shown in <a href="#Fig-IntroLayers" class="xref">Figure 2</a>.</p>
<div id="rfc.figure.2"></div>
<div id="Fig-IntroLayers"></div>
<pre>
             +----------------+
             |      IPv6      |
          +- +----------------+            
          |  |   Compression  |  
    SCHC &lt;   +----------------+   
          |  |  Fragmentation |
          +- +----------------+         
             |LPWAN technology|
             +----------------+

</pre>
<p class="figure">Figure 2: Protocol stack comprising IPv6, SCHC and an LPWAN technology</p>
<p id="rfc.section.5.p.2">As per this document, when a packet (e.g. an IPv6 packet) needs to be transmitted, header compression is first applied to the packet. The resulting packet after header compression (whose header may or may not actually be smaller than that of the original packet) is called a SCHC Packet.  If the SCHC Packet needs to be fragmented by the optional SCHC Fragmentation, fragmentation is then applied to the SCHC Packet. The SCHC Packet or the SCHC Fragments are then transmitted over the LPWAN. The reciprocal operations take place at the receiver. This process is illustrated in <a href="#Fig-Operations" class="xref">Figure 3</a>.</p>
<div id="rfc.figure.3"></div>
<div id="Fig-Operations"></div>
<pre>
A packet (e.g. an IPv6 packet) 
         |                                           ^
         v                                           |
+------------------+                      +--------------------+
| SCHC Compression |                      | SCHC Decompression |
+------------------+                      +--------------------+
         |                                           ^
         |   If no fragmentation (*)                 |
         +-------------- SCHC Packet  --------------&gt;|
         |                                           |
         v                                           |
+--------------------+                       +-----------------+
| SCHC Fragmentation |                       | SCHC Reassembly |
+--------------------+                       +-----------------+
      |     ^                                     |     ^
      |     |                                     |     |
      |     +-------------- SCHC ACK -------------+     |
      |                                                 |
      +-------------- SCHC Fragments -------------------+

        SENDER                                    RECEIVER


*: the decision to use Fragmentation or not is left to each Profile.

</pre>
<p class="figure">Figure 3: SCHC operations at the SENDER and the RECEIVER</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#schc-packet-format" id="schc-packet-format">SCHC Packet format</a>
</h1>
<p id="rfc.section.5.1.p.1">The SCHC Packet is composed of the Compressed Header followed by the payload from the original packet (see <a href="#Fig-SCHCpckt" class="xref">Figure 4</a>).  The Compressed Header itself is composed of a Rule ID and a Compression Residue. The Compression Residue may be empty, see <a href="#SCHComp" class="xref">Section 7</a>. Both the Rule ID and the Compression Residue potentially have a variable size, and generally are not a mutiple of bytes in size.</p>
<div id="rfc.figure.4"></div>
<div id="Fig-SCHCpckt"></div>
<pre>
|  Rule ID +  Compression Residue |
+---------------------------------+--------------------+ 
|      Compressed Header          |      Payload       |
+---------------------------------+--------------------+

</pre>
<p class="figure">Figure 4: SCHC Packet</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#functional-mapping" id="functional-mapping">Functional mapping</a>
</h1>
<p><a href="#Fig-archi" class="xref">Figure 5</a> below maps the functional elements of <a href="#Fig-Operations" class="xref">Figure 3</a> onto the LPWAN architecture elements of <a href="#Fig-LPWANarchi" class="xref">Figure 1</a>.</p>
<div id="rfc.figure.5"></div>
<div id="Fig-archi"></div>
<pre>
     Dev                                                 App
+----------------+                                  +--------------+
| APP1 APP2 APP3 |                                  |APP1 APP2 APP3|
|                |                                  |              |
|       UDP      |                                  |     UDP      |
|      IPv6      |                                  |    IPv6      |   
|                |                                  |              |  
|SCHC C/D and F/R|                                  |              |
+--------+-------+                                  +-------+------+
         |   +--+     +----+     +-----------+              .
         +~~ |RG| === |NGW | === |   SCHC    |... Internet ..
             +--+     +----+     |F/R and C/D|
                                 +-----------+
</pre>
<p class="figure">Figure 5: Architecture</p>
<p id="rfc.section.5.2.p.2">SCHC C/D and SCHC F/R are located on both sides of the LPWAN transmission, i.e. on the Dev side and on the Network side.</p>
<p id="rfc.section.5.2.p.3">The operation in the Uplink direction is as follows. The Device application uses IPv6 or IPv6/UDP protocols. Before sending the packets, the Dev compresses their headers using SCHC C/D and, if the SCHC Packet resulting from the compression needs to be fragmented by SCHC, SCHC F/R is performed (see <a href="#Frag" class="xref">Section 8</a>).  The resulting SCHC Fragments are sent to an LPWAN Radio Gateway (RG) which forwards them to a Network Gateway (NGW).  The NGW sends the data to a SCHC F/R for re-assembly (if needed) and then to the SCHC C/D for decompression.  After decompression, the packet can be sent over the Internet to one or several LPWAN Application Servers (App).</p>
<p id="rfc.section.5.2.p.4">The SCHC F/R and C/D on the Network side can be located in the NGW, or somewhere else as long as a tunnel is established between them and the NGW. Note that, for some LPWAN technologies, it MAY be suitable to locate the SCHC F/R functionality nearer the NGW, in order to better deal with time constraints of such technologies.</p>
<p id="rfc.section.5.2.p.5">The SCHC C/D and F/R on both sides MUST share the same set of Rules.</p>
<p id="rfc.section.5.2.p.6">The SCHC C/D and F/R process is symmetrical, therefore the description of the Downlink direction is symmetrical to the one above.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#rule-id" id="rule-id">Rule ID</a>
</h1>
<p id="rfc.section.6.p.1">Rule IDs are identifiers used to select the correct context either for Compression/Decompression or for Fragmentation/Reassembly.</p>
<p id="rfc.section.6.p.2">The size of the Rule IDs is not specified in this document, as it is implementation-specific and can vary according to the LPWAN technology and the number of Rules, among others. It is defined in Profiles.</p>
<p id="rfc.section.6.p.3">The Rule IDs are used:</p>
<p></p>

<ul>
<li>In the SCHC C/D context, to identify the Rule (i.e., the set of Field Descriptions) that is used to compress a packet header.</li>
<li>At least one Rule ID MAY be allocated to tagging packets for which SCHC compression was not possible (no matching Rule was found).</li>
<li>In SCHC F/R, to identify the specific modes and settings of SCHC Fragments being transmitted, and to identify the SCHC ACKs, including their modes and settings. Note that when F/R is used for both communication directions, at least two Rule ID values are therefore needed for F/R.</li>
</ul>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#SCHComp" id="SCHComp">Compression/Decompression</a>
</h1>
<p id="rfc.section.7.p.1">Compression with SCHC is based on using context, i.e. a set of Rules to compress or decompress headers. SCHC avoids context synchronization, which consumes considerable bandwidth in other header compression mechanisms such as RoHC <a href="#RFC5795" class="xref">[RFC5795]</a>. Since the content of packets is highly predictable in LPWAN networks, static contexts MAY be stored beforehand to omit transmitting some information over the air. The contexts MUST be stored at both ends, and they can be learned by a provisioning protocol or by out of band means, or they can be pre-provisioned. The way the contexts are provisioned is out of the scope of this document.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#schc-cd-rules" id="schc-cd-rules">SCHC C/D Rules</a>
</h1>
<p id="rfc.section.7.1.p.1">The main idea of the SCHC compression scheme is to transmit the Rule ID to the other end instead of sending known field values. This Rule ID identifies a Rule that provides the closest match to the original packet values. Hence, when a value is known by both ends, it is only necessary to send the corresponding Rule ID over the LPWAN network.  The manner by which Rules are generated is out of the scope of this document. The Rules MAY be changed at run-time but the mechanism is out of scope of this document.</p>
<p id="rfc.section.7.1.p.2">The context contains a list of Rules (see <a href="#Fig-ctxt" class="xref">Figure 6</a>). Each Rule itself contains a list of Field Descriptions composed of a Field Identifier (FID), a Field Length (FL), a Field Position (FP), a Direction Indicator (DI), a Target Value (TV), a Matching Operator (MO) and a Compression/Decompression Action (CDA).</p>
<div id="rfc.figure.6"></div>
<div id="Fig-ctxt"></div>
<pre>
  /-----------------------------------------------------------------\
  |                         Rule N                                  |
 /-----------------------------------------------------------------\|
 |                       Rule i                                    ||
/-----------------------------------------------------------------\||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |
\-----------------------------------------------------------------/

</pre>
<p class="figure">Figure 6: A Compression/Decompression Context</p>
<p id="rfc.section.7.1.p.3">A Rule does not describe how to parse a packet header to find each field. This MUST be known from the compressor/decompressor. Rules only describe the compression/decompression behavior for each header field. In a Rule, the Field Descriptions are listed in the order in which the fields appear in the packet header.</p>
<p id="rfc.section.7.1.p.4">A Rule also describes what is sent in the Compression Residue. The Compression Residue is assembled by concatenating the residues for each field, in the order the Field Descriptions appear in the Rule.</p>
<p id="rfc.section.7.1.p.5">The Context describes the header fields and its values with the following entries:</p>
<p></p>

<ul>
<li>Field ID (FID) is a unique value to define the header field.</li>
<li>Field Length (FL) represents the length of the field. It can be either a fixed value (in bits) if the length is known when the Rule is created or a type if the length is variable. The length of a header field is defined in the corresponding protocol specification. The type defines the process to compute the length, its unit (bits, bytes,&#8230;) and the value to be sent before the Compression Residue.</li>
<li>Field Position (FP): most often, a field only occurs once in a packet header. Some fields may occur multiple times in a header. FP indicates which occurrence  this Field Description applies to. The default value is 1 (first occurence).</li>
<li>A Direction Indicator (DI) indicates the packet direction(s) this Field Description applies to. Three values are possible:  <ul>
<li>UPLINK (Up): this Field Description is only applicable to packets sent by the Dev to the App,</li>
<li>DOWNLINK (Dw): this Field Description is only applicable to packets sent from the App to the Dev,</li>
<li>BIDIRECTIONAL (Bi): this Field Description is applicable to packets travelling both Up and Dw.</li>
</ul>
</li>
<li>Target Value (TV) is the value used to match against the packet header field. The Target Value can be of any type (integer, strings, etc.). It can be a single value or a more complex structure (array, list, etc.), such as a JSON or a CBOR structure.</li>
<li>Matching Operator (MO) is the operator used to match the Field Value and the Target Value. The Matching Operator may require some parameters. MO is only used during the compression phase. The set of MOs defined in this document can be found in <a href="#chap-MO" class="xref">Section 7.4</a>.</li>
<li>Compression Decompression Action (CDA) describes the compression and decompression processes to be performed after the MO is applied. Some CDAs MAY require parameter values for their operation. CDAs are used in both the compression and the decompression functions. The set of CDAs defined in this document can be found in <a href="#chap-CDA" class="xref">Section 7.5</a>.</li>
</ul>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#IDComp" id="IDComp">Rule ID for SCHC C/D</a>
</h1>
<p id="rfc.section.7.2.p.1">Rule IDs are sent by the compression function in one side and are received for the decompression function in the other side.  In SCHC C/D, the Rule IDs are specific to a Dev. Hence, multiple Dev instances MAY use the same Rule ID to define different header compression contexts. To identify the correct Rule ID, the SCHC C/D needs to associate the Rule ID with the Dev identifier to find the appropriate Rule to be applied.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#packet-processing" id="packet-processing">Packet processing</a>
</h1>
<p id="rfc.section.7.3.p.1">The compression/decompression process follows several steps:</p>
<p></p>

<ul>
<li>Compression Rule selection: The goal is to identify which Rule(s) will be used to compress the packet&#8217;s headers. When performing decompression, on the network side the SCHC C/D needs to find the correct Rule based on the L2 address; in this way, it can use the DevIID and the Rule ID. On the Dev side, only the Rule ID is needed to identify the correct Rule since the Dev typically only holds Rules that apply to itself. The Rule will be selected by matching the Fields Descriptions to the packet header as described below. When the selection of a Rule is done, this Rule is used to compress the header. The detailed steps for compression Rule selection are the following:  <ul>
<li>The first step is to choose the Field Descriptions by their direction, using the Direction Indicator (DI). A Field Description that does not correspond to the appropriate DI will be ignored. If all the fields of the packet do not have a Field Description with the correct DI, the Rule is discarded and SCHC C/D proceeds to consider the next Rule.</li>
<li>When the DI has matched, then the next step is to identify the fields according to Field Position (FP). If FP does not correspond, the Rule is not used and the SCHC C/D proceeds to consider the next Rule.</li>
<li>Once the DI and the FP correspond to the header information, each packet field&#8217;s value is then compared to the corresponding Target Value (TV) stored in the Rule for that specific field using the matching operator (MO).      <br><br> If all the fields in the packet&#8217;s header satisfy all the matching operators (MO) of a Rule (i.e. all MO results are True), the fields of the header are then compressed according to the Compression/Decompression Actions (CDAs) and a compressed header (with possibly a Compression Residue) SHOULD be obtained. Otherwise, the next Rule is tested.</li>
<li>If no eligible Rule is found, then the header MUST be sent without compression (but may require the use of the SCHC F/R process).</li>
</ul>
</li>
<li>Sending: If an eligible Rule is found, the Rule ID is sent to the other end followed by the Compression Residue (which could be empty) and directly followed by the payload. The Compression Residue is the concatenation of the Compression Residues for each field according to the CDAs for that Rule. The way the Rule ID is sent depends on the Profile. For example, it can be either included in an L2 header or sent in the first byte of the L2 payload. (see <a href="#Fig-FormatPckt" class="xref">Figure 7</a>). This process will be specified in the Profile and is out of the scope of the present document. On LPWAN technologies that are byte-oriented, the compressed header concatenated with the original packet payload is padded to a multiple of 8 bits, if needed. See <a href="#Padding" class="xref">Section 9</a> for details.</li>
<li>Decompression: When doing decompression, on the network side the SCHC C/D needs to find the correct Rule based on the L2 address and in this way, it can use the DevIID and the Rule ID. On the Dev side, only the Rule ID is needed to identify the correct Rule since the Dev only holds Rules that apply to itself.  <br><br> The receiver identifies the sender through its device-id or source identifier (e.g. MAC address, if it exists) and selects the Rule using the Rule ID. This Rule describes the compressed header format and associates the values to the header fields.  The receiver applies the CDA action to reconstruct the original header fields. The CDA application order can be different from the order given by the Rule. For instance, Compute-* SHOULD be applied at the end, after all the other CDAs.</li>
</ul>
<div id="rfc.figure.7"></div>
<div id="Fig-FormatPckt"></div>
<pre>
+--- ... --+------- ... -------+------------------+
|  Rule ID |Compression Residue|  packet payload  |
+--- ... --+------- ... -------+------------------+

|----- compressed header ------|

</pre>
<p class="figure">Figure 7: SCHC C/D Packet Format</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#chap-MO" id="chap-MO">Matching operators</a>
</h1>
<p id="rfc.section.7.4.p.1">Matching Operators (MOs) are functions used by both SCHC C/D endpoints involved in the header compression/decompression. They are not typed and can be applied to integer, string or any other data type. The result of the operation can either be True or False. MOs are defined as follows:</p>
<p></p>

<ul>
<li>equal: The match result is True if the field value in the packet matches the TV.</li>
<li>ignore: No check is done between the field value in the packet and the TV in the Rule. The result of the matching is always true.</li>
<li>MSB(x): A match is obtained if the most significant x bits of the packet header field value are equal to the TV in the Rule. The x parameter of the MSB MO indicates how many bits are involved in the comparison. If the FL is described as variable, the length must be a multiple of the unit. For example, x must be multiple of 8 if the unit of the variable length is in bytes.</li>
<li>match-mapping: With match-mapping, the Target Value is a list of values. Each value of the list is identified by a short ID (or index). Compression is achieved by sending the index instead of the original header field value. This operator matches if the header field value is equal to one of the values in the target list.</li>
</ul>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#chap-CDA" id="chap-CDA">Compression Decompression Actions (CDA)</a>
</h1>
<p id="rfc.section.7.5.p.1">The Compression Decompression Action (CDA) describes the actions taken during the compression of headers fields, and inversely, the action taken by the decompressor to restore the original value.</p>
<div id="rfc.figure.8"></div>
<div id="Fig-function"></div>
<pre>
/--------------------+-------------+----------------------------\
|  Action            | Compression | Decompression              |
|                    |             |                            |
+--------------------+-------------+----------------------------+
|not-sent            |elided       |use value stored in context |
|value-sent          |send         |build from received value   |
|mapping-sent        |send index   |value from index on a table |
|LSB                 |send LSB     |TV, received value          |
|compute-length      |elided       |compute length              |
|compute-checksum    |elided       |compute UDP checksum        |
|DevIID              |elided       |build IID from L2 Dev addr  |
|AppIID              |elided       |build IID from L2 App addr  |
\--------------------+-------------+----------------------------/

</pre>
<p class="figure">Figure 8: Compression and Decompression Actions</p>
<p><a href="#Fig-function" class="xref">Figure 8</a> summarizes the basic actions that can be used to compress and decompress a field. The first column shows the action&#8217;s name. The second and third columns show the reciprocal compression/decompression behavior for each action.</p>
<p id="rfc.section.7.5.p.3">Compression is done in the order that the Field Descriptions appear in a Rule. The result of each Compression/Decompression Action is appended to the accumulated Compression Residue in that same order. The receiver knows the size of each compressed field, which can be given by the Rule or MAY be sent with the compressed header.</p>
<h1 id="rfc.section.7.5.1">
<a href="#rfc.section.7.5.1">7.5.1.</a> <a href="#var-length-field" id="var-length-field">processing variable-length fields</a>
</h1>
<p id="rfc.section.7.5.1.p.1">If the field is identified in the Field Description as being of variable size, then the size of the Compression Residue value (using the unit defined in the FL) MUST first be sent as follows:</p>
<p></p>

<ul>
<li>If the size is between 0 and 14, it is sent as a 4-bits unsigned integer.</li>
<li>For values between 15 and 254, 0b1111 is transmitted and then the size is sent as an 8 bits unsigned integer.</li>
<li>For larger values of the size, 0xffff is transmitted and then the next two bytes contain the size value as a 16 bits unsigned integer.</li>
</ul>
<p id="rfc.section.7.5.1.p.3">If a field is not present in the packet but exists in the Rule and its FL is specified as being variable, size 0 MUST be sent to denote its absence.</p>
<h1 id="rfc.section.7.5.2">
<a href="#rfc.section.7.5.2">7.5.2.</a> <a href="#not-sent-cda" id="not-sent-cda">not-sent CDA</a>
</h1>
<p id="rfc.section.7.5.2.p.1">The not-sent action is generally used when the field value is specified in a Rule and therefore known by both the Compressor and the Decompressor. This action SHOULD be used with the &#8220;equal&#8221; MO. If MO is &#8220;ignore&#8221;, there is a risk to have a decompressed field value different from the original field that was compressed.</p>
<p id="rfc.section.7.5.2.p.2">The compressor does not send any Compression Residue for a field on which not-sent compression is applied.</p>
<p id="rfc.section.7.5.2.p.3">The decompressor restores the field value with the Target Value stored in the matched Rule identified by the received Rule ID.</p>
<h1 id="rfc.section.7.5.3">
<a href="#rfc.section.7.5.3">7.5.3.</a> <a href="#value-sent-cda" id="value-sent-cda">value-sent CDA</a>
</h1>
<p id="rfc.section.7.5.3.p.1">The value-sent action is generally used when the field value is not known by both the Compressor and the Decompressor. The value is sent as a residue in the compressed message header. Both Compressor and Decompressor MUST know the size of the field, either implicitly (the size is known by both sides) or by explicitly indicating the length in the Compression Residue, as defined in <a href="#var-length-field" class="xref">Section 7.5.1</a>. This action is generally used with the &#8220;ignore&#8221; MO.</p>
<h1 id="rfc.section.7.5.4">
<a href="#rfc.section.7.5.4">7.5.4.</a> <a href="#mapping-sent-cda" id="mapping-sent-cda">mapping-sent CDA</a>
</h1>
<p id="rfc.section.7.5.4.p.1">The mapping-sent action is used to send an index (the index into the Target Value list of values) instead of the original value. This action is used together with the &#8220;match-mapping&#8221; MO.</p>
<p id="rfc.section.7.5.4.p.2">On the compressor side, the match-mapping Matching Operator searches the TV for a match with the header field value and the mapping-sent CDA appends the corresponding index to the Compression Residue to be sent.  On the decompressor side, the CDA uses the received index to restore the field value by looking up the list in the TV.</p>
<p id="rfc.section.7.5.4.p.3">The number of bits sent is the minimal size for coding all the possible indices.</p>
<h1 id="rfc.section.7.5.5">
<a href="#rfc.section.7.5.5">7.5.5.</a> <a href="#lsb-cda" id="lsb-cda">LSB CDA</a>
</h1>
<p id="rfc.section.7.5.5.p.1">The LSB action is used together with the &#8220;MSB(x)&#8221; MO to avoid sending the most significant part of the packet field if that part is already known by the receiving end.  The number of bits sent is the original header field length minus the length specified in the MSB(x) MO.</p>
<p id="rfc.section.7.5.5.p.2">The compressor sends the Least Significant Bits (e.g. LSB of the length field). The decompressor concatenates the x most significant bits of Target Value and the received residue.</p>
<p id="rfc.section.7.5.5.p.3">If this action needs to be done on a variable length field, the size of the Compression Residue in bytes MUST be sent as described in <a href="#var-length-field" class="xref">Section 7.5.1</a>.</p>
<h1 id="rfc.section.7.5.6">
<a href="#rfc.section.7.5.6">7.5.6.</a> <a href="#deviid-appiid-cda" id="deviid-appiid-cda">DevIID, AppIID CDA</a>
</h1>
<p id="rfc.section.7.5.6.p.1">These actions are used to process respectively the Dev and the App Interface Identifiers (DevIID and AppIID) of the IPv6 addresses. AppIID CDA is less common since most current LPWAN technologies frames contain a single L2 address, which is the Dev&#8217;s address.</p>
<p id="rfc.section.7.5.6.p.2">The IID value MAY be computed from the Device ID present in the L2 header, or from some other stable identifier. The computation is specific to each Profile and MAY depend on the Device ID size.</p>
<p id="rfc.section.7.5.6.p.3">In the downlink direction (Dw), at the compressor, the DevIID CDA may be used to generate the L2 addresses on the LPWAN, based on the packet&#8217;s Destination Address.</p>
<h1 id="rfc.section.7.5.7">
<a href="#rfc.section.7.5.7">7.5.7.</a> <a href="#compute-" id="compute-">Compute-*</a>
</h1>
<p id="rfc.section.7.5.7.p.1">Some fields may be elided during compression and reconstructed during decompression. This is the case for length and checksum, so:</p>
<p></p>

<ul>
<li>compute-length: computes the length assigned to this field. This CDA MAY be used to compute IPv6 length or UDP length.</li>
<li>compute-checksum: computes a checksum from the information already received by the SCHC C/D. This field MAY be used to compute UDP checksum.</li>
</ul>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#Frag" id="Frag">Fragmentation/Reassembly</a>
</h1>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.8.1.p.1">In LPWAN technologies, the L2 MTU typically ranges from tens to hundreds of bytes.  Some of these technologies do not have an internal fragmentation/reassembly mechanism.</p>
<p id="rfc.section.8.1.p.2">The SCHC Fragmentation/Reassembly (SCHC F/R) functionality is offered as an option for such LPWAN technologies to cope with the IPv6 MTU requirement of 1280 bytes <a href="#RFC8200" class="xref">[RFC8200]</a>.  It is optional to implement. If it is not needed, its description can be safely ignored.</p>
<p id="rfc.section.8.1.p.3">It has been designed under the following assumptions</p>
<p></p>

<ul>
<li>Data unit out-of-sequence delivery does not occur between the entity performing fragmentation and the entity performing reassembly</li>
<li>The L2 MTU value does not change while a fragmented SCHC Packet is being transmitted.</li>
</ul>
<p id="rfc.section.8.1.p.5">These assumptions allow reducing the complexity and overhead of the SCHC F/R mechanism.</p>
<p id="rfc.section.8.1.p.6">This specification includes several SCHC F/R modes, which allow for a range of reliability options such as optional SCHC Fragment retransmission.  More modes may be defined in the future.  The same SCHC F/R mode MUST be used for all SCHC Fragments of the same fragmented SCHC Packet.  This document does not make any decision with regard to which mode(s) will be used over a specific LPWAN technology. This will be defined in Profiles.</p>
<p id="rfc.section.8.1.p.7">SCHC F/R uses the knowledge of the L2 Word size (see <a href="#Term" class="xref">Section 4</a>) to encode some messages. Therefore, SCHC MUST know the L2 Word size.  SCHC F/R usually generates SCHC Fragments and SCHC ACKs that are multiples of L2 Words.  The padding overhead is kept to the absolute minimum (see <a href="#Padding" class="xref">Section 9</a>).</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#FragTools" id="FragTools">SCHC F/R Tools</a>
</h1>
<p id="rfc.section.8.2.p.1">This subsection describes the different tools that are used to enable the SCHC F/R functionality defined in this document.  These tools include the SCHC F/R messages, tiles, windows, counters, timers and header fields.</p>
<p id="rfc.section.8.2.p.2">The tools are described here in a generic manner. Their application to each SCHC F/R mode is found in <a href="#FragModes" class="xref">Section 8.4</a>.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#messages" id="messages">Messages</a>
</h1>
<p id="rfc.section.8.2.1.p.1">The messages that can be used by SCHC F/R are the following</p>
<p></p>

<ul>
<li>SCHC Fragment: A data unit that carries a piece of a SCHC Packet from the sender to the receiver.</li>
<li>SCHC ACK: An acknowledgement for fragmentation, by the receiver to the sender.  This message is used to report on the successful reception of pieces of, or the whole of the fragmented SCHC Packet.</li>
<li>SCHC ACK REQ: An explicit request for a SCHC ACK. By the sender to the receiver.</li>
<li>SCHC Sender-Abort: A message by the sender telling the receiver that it has aborted the transmission of a fragmented SCHC Packet.</li>
<li>SCHC Receiver-Abort: A message by the receiver to tell the sender to abort the transmission of a fragmented SCHC Packet.</li>
</ul>
<h1 id="rfc.section.8.2.2">
<a href="#rfc.section.8.2.2">8.2.2.</a> <a href="#OtherTools" id="OtherTools">Tiles, Windows, Bitmaps, Timers, Counters</a>
</h1>
<p id="rfc.section.8.2.2.p.1">The SCHC Packet is fragmented into pieces, hereafter called tiles.  The tiles MUST be contiguous.</p>
<p id="rfc.section.8.2.2.p.2">Each SCHC Fragment message carries at least one tile in its Payload.</p>
<h1 id="rfc.section.8.2.2.1">
<a href="#rfc.section.8.2.2.1">8.2.2.1.</a> <a href="#Windows" id="Windows">Windows</a>
</h1>
<p id="rfc.section.8.2.2.1.p.1">Some SCHC F/R modes may handle successive tiles in groups, called windows.  If windows are used</p>
<p></p>

<ul>
<li>all the windows of a SCHC Packet, except the last one, MUST contain the same number of tiles.  This number is WINDOW_SIZE.</li>
<li>the windows are numbered.</li>
<li>their numbers MUST increase from 0 upward, from the start of the SCHC Packet to its end.</li>
<li>the last window MUST contain WINDOW_SIZE tiles or less.</li>
<li>tiles are numbered within each window.</li>
<li>the tile numbers MUST decrement from WINDOW_SIZE - 1 downward, looking from the start of the SCHC Packet toward its end.</li>
<li>each tile of a SCHC Packet is therefore uniquely identified by a window number and a tile number within this window.</li>
</ul>
<p id="rfc.section.8.2.2.1.p.3">See <a href="#Fig-TilesExample" class="xref">Figure 9</a> for an example.</p>
<div id="rfc.figure.9"></div>
<div id="Fig-TilesExample"></div>
<pre>
         +----------------------------------------------...---------------------+
         |                            SCHC Packet                               |
         +----------------------------------------------...---------------------+

Tile #   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |      | 2 | 1 | 0 | 4 | 3 |
Window # |-------- 0 --------|-------- 1 --------|- 2 - ... - 27 -------|-- 28 -|

</pre>
<p class="figure">Figure 9: a SCHC Packet fragmented in tiles grouped in 28 windows, with WINDOW_SIZE = 5</p>
<p id="rfc.section.8.2.2.1.p.4">When windows are used</p>
<p></p>

<ul>
<li>information on the correct reception of the tiles belonging to the same window MUST be grouped together.</li>
<li>it is RECOMMENDED that this information is kept in Bitmaps.</li>
<li>Bitmaps MAY be sent back to the sender in a SCHC ACK message.</li>
<li>Each window has a Bitmap.</li>
</ul>
<h1 id="rfc.section.8.2.2.2">
<a href="#rfc.section.8.2.2.2">8.2.2.2.</a> <a href="#Bitmap" id="Bitmap">Bitmap</a>
</h1>
<p id="rfc.section.8.2.2.2.p.1">Each bit in the Bitmap for a window corresponds to a tile in the window.  A Bitmap has therefore WINDOW_SIZE bits.  The bit at the left-most position corresponds to the tile numbered WINDOW_SIZE - 1.  The bit at the right-most position corresponds to the tile numbered 0.</p>
<p id="rfc.section.8.2.2.2.p.2">At the receiver</p>
<p></p>

<ul>
<li>a bit set to 1 in the Bitmap indicates that a tile with the number corresponding to that bit position has been correctly received for that window.</li>
<li>a bit set to 0 in the Bitmap indicates that no tile with the number corresponding to that bit position has been correctly received for that window.</li>
</ul>
<h1 id="rfc.section.8.2.2.3">
<a href="#rfc.section.8.2.2.3">8.2.2.3.</a> <a href="#MiscTools" id="MiscTools">Misc tools</a>
</h1>
<p id="rfc.section.8.2.2.3.p.1">Some SCHC F/R modes can use the following timers and counters</p>
<p></p>

<ul>
<li>Inactivity Timer: this timer can be used to unlock a SCHC Fragment receiver that is not receiving a SCHC F/R message while it is expecting one.</li>
<li>Retransmission Timer: this timer can be used by a SCHC Fragment sender to set a timeout on expecting a SCHC ACK.</li>
<li>Attempts: this counter counts the requests for a missing SCHC ACK. MAX_ACK_REQUESTS is the threshold at which the SCHC Fragment sender stops sending repeated requests.</li>
</ul>
<h1 id="rfc.section.8.2.3">
<a href="#rfc.section.8.2.3">8.2.3.</a> <a href="#IntegrityChecking" id="IntegrityChecking">Integrity Checking</a>
</h1>
<p id="rfc.section.8.2.3.p.1">The reassembled SCHC Packet is checked for integrity at the receive end.  One way of doing integrity checking is by computing a MIC at the sender side and transmitting it to the receiver for comparison with the locally computed MIC.  Some LPWAN technologies under SCHC may provide other means of ensuring that all fragments composing a SCHC Packet were correctly received and reassembled.  The Profile MUST define how integrity checking is done.</p>
<p id="rfc.section.8.2.3.p.2">If a Profile specify that MIC is used, the SCHC F/R mode specifies on what fields of the SCHC Fragments the MIC is computed.</p>
<p id="rfc.section.8.2.3.p.3">If the MIC is present, the sender MUST compute it over the complete SCHC Packet and the potential padding bits of the last SCHC Fragment.</p>
<p id="rfc.section.8.2.3.p.4">Sending a MIC is one way of allowing the receiver to do integrity checking on the reassembled SCHC Packet.  The MIC supports UDP checksum elision by SCHC C/D (see <a href="#UDPchecksum" class="xref">Section 10.11</a>).</p>
<p id="rfc.section.8.2.3.p.5">The CRC32 polynomial 0xEDB88320 (i.e. the reverse representation of the polynomial used e.g. in the Ethernet standard <a href="#RFC3385" class="xref">[RFC3385]</a>) is RECOMMENDED as the default algorithm for computing the MIC. Nevertheless, other MIC lengths or other algorithms MAY be required by the Profile.</p>
<p id="rfc.section.8.2.3.p.6">Note that the concatenation of the complete SCHC Packet and the potential padding bits of the last SCHC Fragment does not generally constitute an integer number of bytes.  For implementers to be able to use byte-oriented CRC libraries, it is RECOMMENDED that the concatenation of the complete SCHC Packet and the last fragment potential padding bits be zero-extended to the next byte boundary and that the MIC be computed on that byte array.</p>
<h1 id="rfc.section.8.2.4">
<a href="#rfc.section.8.2.4">8.2.4.</a> <a href="#HeaderFields" id="HeaderFields">Header Fields</a>
</h1>
<p id="rfc.section.8.2.4.p.1">The SCHC F/R messages use the following fields (see the related formats in <a href="#Fragfor" class="xref">Section 8.3</a>)</p>
<p></p>

<ul>
<li>Rule ID: this is used to identify  <ul>
<li>that a SCHC F/R message is being carried, as opposed to an unfragmented SCHC Packet,</li>
<li>which SCHC F/R mode is used</li>
<li>and among this mode      <ul>
<li>if windows are used, how many tiles the windows contain</li>
<li>what optional fields are present</li>
<li>and what the field sizes are.</li>
</ul>
</li>
</ul>
<p> Therefore, the Rule ID allows SCHC F/R interleaving non-fragmented SCHC Packets and SCHC Fragments that carry other SCHC Packets, or interleaving SCHC Fragments that use different SCHC F/R modes or different parameters.</p>
</li>
<li>Fragment Compressed Number (FCN). The FCN is present in the SCHC Fragments header.  This field conveys information about the progress in the sequence of tiles being transmitted by the SCHC Fragment.  For example, it can contain a truncated, efficient representation of a larger-sized tile number.  The exact use of the FCN field is left to each SCHC F/R mode.  However, two values are reserved for special purposes. They help control the SCHC F/R process:  <ul>
<li>The FCN value with all the bits equal to 1 (called All-1) signals the very last tile of a SCHC Packet.  By extension, if windows are used, the last window of a packet is called the All-1 window.</li>
<li>If windows are used, the FCN value with all the bits equal to 0 (called All-0) signals the last tile of a window that is not the last one of the SCHC packet.  By extension, such a window is called an All-0 window.</li>
</ul>
<p> N is the size of the FCN field, in bits. It is defined for each SCHC F/R mode, Profile and Rule ID.  Since All-1 is special, the highest value of FCN (an unsigned integer), called MAX_WIND_FCN, theoretically is (2^N)-2.  However, each SCHC F/R mode or Profile is free to specify for MAX_WIND_FCN a value lower than (2^N)-2.  The rationale is that MAX_WIND_FCN finely controls the size of the Bitmap in the SCHC ACK message, which may be critical to some LPWAN technologies.</p>
</li>
<li>Datagram Tag (DTag). The DTag field is optional.  <br><br> When there is no DTag, there can be only one fragmented SCHC Packet in transit.  In other words, only after all its fragments have been transmitted can another fragmented SCHC Packet be sent.  <br><br> If present, DTag MUST be set to the same value for all SCHC Fragments carrying the same SCHC Packet, and to different values for different SCHC Packets.  Using this field, the sender can interleave fragments from different SCHC Packets, while the receiver can still tell them apart.  <br><br> If a SCHC ACK message is sent, it MUST carry the same DTag value as the SCHC Fragments for the same SCHC Packet.  <br><br> The presence and size of the DTag field is defined by each SCHC F/R mode for each Rule ID value.  For each new SCHC Packet processed by the sender under the same F/R mode and same RuleID, DTag MUST be sequentially increased, from 0 to (2^T) &#8211; 1 wrapping back from (2^T) - 1 to 0, where T is the size of DTag in bits.</li>
<li>W: The W field is optional. It is only present if windows are used.  <br><br> This field carries information pertaining to the window number a SCHC F/R message relates to.  It MUST carry the same value for all SCHC F/R messages pertaining to the same window.  <br><br> The presence of W and its size (called M, in bits) is defined for each F/R mode and Rule ID.  <br><br> Depending on the mode and Profile, W may carry the full window number, or just the least significant bit or any other partial representation of the window number.</li>
<li>Message Integrity Check (MIC).  This field is optional. If present, it only appears in the All-1 SCHC Fragments.  See <a href="#IntegrityChecking" class="xref">Section 8.2.3</a> for details on the computation of the MIC.</li>
<li>C (integrity Check): C is a 1-bit field.  This field is used in the SCHC ACK message to report on the reassembled SCHC Packet integrity check (see <a href="#IntegrityChecking" class="xref">Section 8.2.3</a>).  A value of 1 tells that the integrity check was performed and is successful.  A value of 0 tells that the integrity check was not performed, or that is was a failure.</li>
<li>Bitmap. The Bitmap is used together with windows.  It is a bit field that may be maintained by the sender during the fragmentation and by the receiver during the reassembly of a fragmented SCHC Packet.  A truncated version MAY be send in a SCHC ACK message.</li>
</ul>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#Fragfor" id="Fragfor">SCHC F/R Message Formats</a>
</h1>
<p id="rfc.section.8.3.p.1">This section defines the SCHC Fragment format, the SCHC ACK format, the SCHC ACK REQ format and the SCHC Abort formats.</p>
<h1 id="rfc.section.8.3.1">
<a href="#rfc.section.8.3.1">8.3.1.</a> <a href="#schc-fragment-format" id="schc-fragment-format">SCHC Fragment format</a>
</h1>
<p id="rfc.section.8.3.1.p.1">A SCHC Fragment conforms to the general format shown in <a href="#Fig-FragFormat" class="xref">Figure 10</a>.  It comprises a SCHC Fragment Header and a SCHC Fragment Payload.  The SCHC Fragment Payload carries one or several tile(s).  In addition, the last SCHC Fragment of a SCHC Packet carries just enough padding bits as needed to fill up an L2 Word.  The SCHC Fragment is the data unit passed on to the L2 for transmission.</p>
<div id="rfc.figure.10"></div>
<div id="Fig-FragFormat"></div>
<pre>
+-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~
| Fragment Header | &#160; Fragment Payload    | padding (as needed)
+-----------------+-----------------------+~~~~~~~~~~~~~~~~~~~~~
</pre>
<p class="figure">Figure 10: SCHC Fragment general format. Presence of a padding field is optional</p>
<h1 id="rfc.section.8.3.1.1">
<a href="#rfc.section.8.3.1.1">8.3.1.1.</a> <a href="#NotLastFrag" id="NotLastFrag">Regular SCHC Fragment</a>
</h1>
<p id="rfc.section.8.3.1.1.p.1">The Regular SCHC Fragment format is shown in <a href="#Fig-NotLastFrag" class="xref">Figure 11</a>.  Regular SCHC Fragments are generally used to carry tiles that are not the last one of a SCHC Packet.  The W field is optional. Its presence is specified by each SCHC F/R mode.</p>
<div id="rfc.figure.11"></div>
<div id="Fig-NotLastFrag"></div>
<pre>
 |------ Fragment Header ------|
           |-- T --|-M-|-- N --|
 +-- ... --+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~~
 | Rule ID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)
 +-- ... --+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~~

</pre>
<p class="figure">Figure 11: Detailed Header Format for Fragments except the Last One</p>
<p id="rfc.section.8.3.1.1.p.2">The total size of the Fragment Header is not necessarily a multiple of the L2 Word size.</p>
<p id="rfc.section.8.3.1.1.p.3">If the size of the tiles carried in the SCHC Fragment Payload does not nicely complement the SCHC Header size in a way that would make the SCHC Fragment a multiple of the L2 Word, then padding bits MUST be added.</p>
<p id="rfc.section.8.3.1.1.p.4">The padding bits that are added MUST be less that the L2 Word size.</p>
<p id="rfc.section.8.3.1.1.p.5">The Fragment Payload of a SCHC Fragment with FCN == 0 (called an All-0 SCHC Fragment) MUST be at least the size of an L2 Word.  The rationale is that, even in the presence of padding, an All-0 SCHC Fragment needs to be distinguishable from the SCHC ACK REQ message, which has the same header but has no payload (see <a href="#ACKREQ" class="xref">Section 8.3.3</a>).</p>
<h1 id="rfc.section.8.3.1.2">
<a href="#rfc.section.8.3.1.2">8.3.1.2.</a> <a href="#LastFrag" id="LastFrag">All-1 SCHC Fragment</a>
</h1>
<p id="rfc.section.8.3.1.2.p.1">The All-1 SCHC Fragment format is shown in <a href="#Fig-LastFrag" class="xref">Figure 12</a>.  The All-1 SCHC Fragment is generally used to carry the very last tile of a SCHC Packet.  The W field is optional.  The MIC field is optional.</p>
<div id="rfc.figure.12"></div>
<div id="Fig-LastFrag"></div>
<pre>
|----------- Fragment Header ---------|
          |-- T --|-M-|-- N --|
+-- ... --+- ... -+---+- ... -+- ... -+------...-----+~~~~~~~~~~~~~~~~~~~~~
| Rule ID | DTag  | W | 11..1 |  MIC  | Frag Payload | padding (as needed)
+-- ... --+- ... -+---+- ... -+- ... -+------...-----+~~~~~~~~~~~~~~~~~~~~~
                        (FCN)
</pre>
<p class="figure">Figure 12: Detailed format for the All-1 SCHC Fragment</p>
<p id="rfc.section.8.3.1.2.p.2">The total size of the All-1 SCHC Fragment header is generally not a multiple of the L2 Word size.</p>
<p id="rfc.section.8.3.1.2.p.3">If the size of the tiles carried in the SCHC Fragment Payload does not nicely complement the SCHC Header size in a way that would make the SCHC Fragment a multiple of the L2 Word, then padding bits MUST be added.</p>
<p id="rfc.section.8.3.1.2.p.4">The padding bits that are added MUST be less that the L2 Word size.</p>
<p id="rfc.section.8.3.1.2.p.5">The optional MIC concatenated with the All-1 SCHC Fragment Payload MUST be at least the size of an L2 Word.  The rationale is that, even in the presence of padding, the All-1 SCHC Fragment needs to be distinguishable from the SCHC Sender-Abort (see <a href="#SenderAbort" class="xref">Section 8.3.4.1</a>).  If the MIC is absent, or if it is present but its size is less than an L2 Word, this requirement places a constraint on the size of the Payload.  Meeting this constraint may entail saving an L2 Word from the payload of the previous SCHC Fragment to make the payload of this All-1 SCHC Fragment big enough.</p>
<h1 id="rfc.section.8.3.2">
<a href="#rfc.section.8.3.2">8.3.2.</a> <a href="#ACK" id="ACK">SCHC ACK format</a>
</h1>
<p id="rfc.section.8.3.2.p.1">The SCHC ACK message MUST obey the format shown in <a href="#Fig-ACK-Format" class="xref">Figure 13</a>.  The W field is optional. Its presence is specified by each SCHC F/R mode.  The Truncated Bitmap field is optional. It can only be present in SCHC F/R modes that use windows.</p>
<div id="rfc.figure.13"></div>
<div id="Fig-ACK-Format"></div>
<pre>
|---- SCHC ACK Header ----|
            |-- T --|-M-|1|
+---- ... --+- ... -+---+-+
|  Rule ID  |  DTag | W |1| (integrity check success)
+---- ... --+- ... -+---+-+

+---- ... --+- ... -+---+-+------ ... ------+
|  Rule ID  |  DTag | W |0|Truncated Bitmap |(integrity check failure)
+---- ... --+- ... -+---+-+------ ... ------+
                         C
</pre>
<p class="figure">Figure 13: Format of a SCHC ACK message</p>
<p id="rfc.section.8.3.2.p.2">The SCHC ACK Header contains a C bit (see <a href="#HeaderFields" class="xref">Section 8.2.4</a>).  If the C bit is set to 0 (integrity check not performed or failed) and if windows are used, the Bitmap for the window referred to by the W field MUST follow.  See <a href="#Bitmap" class="xref">Section 8.2.2.2</a> for a description of the Bitmap.</p>
<p id="rfc.section.8.3.2.p.3">In order to reduce the SCHC ACK size, the Bitmap that is actually transmitted is shortened (&#8220;truncated&#8221;) as explained in <a href="#Bitmapopt" class="xref">Section 8.3.2.1</a>.</p>
<p id="rfc.section.8.3.2.p.4">The Rule ID and DTag values in the SCHC ACK messages MUST be identical to the ones used in the SCHC Fragments that carry the tiles for this SCHC Packet.</p>
<p id="rfc.section.8.3.2.p.5">See <a href="#SCHCParams" class="xref">Appendix D</a> for a discussion on the size of the Bitmaps.</p>
<h1 id="rfc.section.8.3.2.1">
<a href="#rfc.section.8.3.2.1">8.3.2.1.</a> <a href="#Bitmapopt" id="Bitmapopt">Bitmap Truncation</a>
</h1>
<p id="rfc.section.8.3.2.1.p.1">For transmission, the Bitmap in the SCHC ACK message is truncated by applying the following algorithm (see <a href="#Fig-Localbitmap" class="xref">Figure 14</a> for a follow-along example):</p>
<p></p>

<ul>
<li>Build a temporary SCHC ACK message that contains the Header and the original Bitmap.</li>
<li>Positioning scissors at the end of the Bitmap, after its last bit.</li>
<li>While the bit left to the scissors is 1 and belongs to the Bitmap, keep moving left, then stop. When this is done,</li>
<li>while the scissors are not on an L2 Word boundary of the SCHC ACK message and are strictly inside the Bitmap, keep moving right, then stop.</li>
<li>At this point, cut and drop off any bits to the right of the scissors</li>
</ul>
<p id="rfc.section.8.3.2.1.p.3">When one or more bits have effectively been dropped off as a result of the above algorithm, the resulting SCHC ACK message is a multiple of L2 Words, and padding MUST NOT be appended.  Otherwise, padding bits MUST be appended as needed to fill up the last L2 Word.</p>
<p id="rfc.section.8.3.2.1.p.4">The result of this algorithm is the SCHC ACK message that MUST be sent.</p>
<p id="rfc.section.8.3.2.1.p.5">Because the SCHC Fragment sender knows the size of the original Bitmap, it can reconstruct the original Bitmap from the Truncated Bitmap received in the SCH ACK message.</p>
<p><a href="#Fig-Localbitmap" class="xref">Figure 14</a> shows an example where L2 Words are actually bytes and where the original Bitmap contains 17 bits, the last 15 of which are all set to 1.</p>
<div id="rfc.figure.14"></div>
<div id="Fig-Localbitmap"></div>
<pre>
|--  SCHC ACK Header ----|--------       Bitmap    --------|
|  Rule ID  |  DTag  |W|0|1|0|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|
                        C
       next L2 Word boundary -&gt;|  next L2 Word |  next L2 Word |
</pre>
<p class="figure">Figure 14: Tentative SCHC ACK message with Bitmap before truncation</p>
<p><a href="#Fig-transmittedbitmap" class="xref">Figure 15</a> shows that the last 14 bits are not sent.</p>
<div id="rfc.figure.15"></div>
<div id="Fig-transmittedbitmap"></div>
<pre>
            |-- T --|-M-|1|
+---- ... --+- ... -+---+-+-+-+-+
|  Rule ID  |  DTag | W |0|1|0|1|
+---- ... --+- ... -+---+-+-+-+-+
                         C
        next L2 Word boundary -&gt;|

</pre>
<p class="figure">Figure 15: Actual SCHC ACK message with Truncated Bitmap</p>
<p><a href="#Fig-Bitmap-Win" class="xref">Figure 16</a> shows an example of a SCHC ACK with FCN ranging from 6 down to 0, where the Bitmap indicates that the second and the sixth tile of the window have not been correctly received.</p>
<div id="rfc.figure.16"></div>
<div id="Fig-Bitmap-Win"></div>
<pre>
                           6 5 4 3 2 1 0 (*)
            |-- T --|-M-|1|
+-----------+-------+---+-+-+-+-+-+-+-+-+
|  Rule ID  |  DTag | W |0|1|0|1|1|1|0|1|        Tentative SCHC ACK with Original Bitmap
+-----------+-------+---+-+-+-+-+-+-+-+-+
                         C
    next L2 Word boundary -&gt;|&lt;-- L2 Word --&gt;|
    (*)=(FCN values)

+-----------+-------+---+-+-+-+-+-+-+-+-+~~~+
|  Rule ID  |  DTag | W |0|1|0|1|1|1|0|1|Pad|    Actual SCHC ACK that is transmitted
+-----------+-------+---+-+-+-+-+-+-+-+-+~~~+
    next L2 Word boundary -&gt;|&lt;-- L2 Word --&gt;|


</pre>
<p class="figure">Figure 16: Example of a SCHC ACK message, missing tiles</p>
<p><a href="#Fig-Bitmap-lastWin" class="xref">Figure 17</a> shows an example of a SCHC ACK with FCN ranging from 6 down to 0, where integrity check has not been performed or has failed and the Bitmap indicates that there is no missing tile in that window.</p>
<div id="rfc.figure.17"></div>
<div id="Fig-Bitmap-lastWin"></div>
<pre>
|- Fragmentation Header  -|6 5 4 3 2 1 7 (*)
            |-- T --|-M-|
|  Rule ID  |  DTag | W |0|1|1|1|1|1|1|1|      SCHC ACK with Original Bitmap
    next L2 Word boundary -&gt;|&lt;-- L2 Word --&gt;|
                         C
+---- ... --+- ... -+---+-+-+
|  Rule ID  |  DTag | W |0|1|                  transmitted SCHC ACK
+---- ... --+- ... -+---+-+-+
    next L2 Word boundary -&gt;|
   (*) = (FCN values indicating the order)

</pre>
<p class="figure">Figure 17: Example of a SCHC ACK message, no missing tile</p>
<h1 id="rfc.section.8.3.3">
<a href="#rfc.section.8.3.3">8.3.3.</a> <a href="#ACKREQ" id="ACKREQ">SCHC ACK REQ format</a>
</h1>
<p id="rfc.section.8.3.3.p.1">The SCHC ACK REQ is used by a sender to explicitely request a SCHC ACK from the receiver.  Its format is described in <a href="#Fig-ACKREQ" class="xref">Figure 18</a>.  The W field is optional. Its presence is specified by each SCHC F/R mode.</p>
<div id="rfc.figure.18"></div>
<div id="Fig-ACKREQ"></div>
<pre>
|---- SCHC ACK REQ Header ----|
          |-- T --|-M-|-- N --|
+-- ... --+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
| Rule ID | DTag  | W |  0..0 | padding (as needed)      (no payload)
+-- ... --+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~

</pre>
<p class="figure">Figure 18: SCHC ACK REQ detailed format</p>
<p id="rfc.section.8.3.3.p.2">The size of the SCHC ACK REQ header is generally not a multiple of the L2 Word size.  Therefore, a SCHC ACK REQ generally needs padding bits. The padding bits are always less than an L2 Word.</p>
<p id="rfc.section.8.3.3.p.3">Note that the SCHC ACK REQ has the same header as an All-0 SCHC Fragment but it doesn&#8217;t have a payload.  Since an All-0 SCHC Fragment payload is at least the size of an L2 Word, a receiver can distinguish a SCHC ACK REQ from an All-0 SCHC Fragment, even in the presence of padding.</p>
<h1 id="rfc.section.8.3.4">
<a href="#rfc.section.8.3.4">8.3.4.</a> <a href="#Aborts" id="Aborts">SCHC Abort formats</a>
</h1>
<h1 id="rfc.section.8.3.4.1">
<a href="#rfc.section.8.3.4.1">8.3.4.1.</a> <a href="#SenderAbort" id="SenderAbort">SCHC Sender-Abort</a>
</h1>
<p id="rfc.section.8.3.4.1.p.1">When a SCHC Fragment sender needs to abort an on-going fragmented SCHC Packet transmission, it sends a SCHC Sender-Abort.  Its format is described in <a href="#Fig-SenderAbort" class="xref">Figure 19</a>.  The W field is optional. Its presence is specified by each SCHC F/R mode.</p>
<div id="rfc.figure.19"></div>
<div id="Fig-SenderAbort"></div>
<pre>
|------ Fragment Header ------|
          |-- T --|-M-|-- N --|
+-- ... --+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~
| Rule ID | DTag  | W | 11..1 | padding (as needed)
+-- ... --+- ... -+---+- ... -+~~~~~~~~~~~~~~~~~~~~~

</pre>
<p class="figure">Figure 19: SCHC Sender-Abort format</p>
<p id="rfc.section.8.3.4.1.p.2">The size of the SCHC Sender-Abort header is generally not a multiple of the L2 Word size.  Therefore, a SCHC Sender-Abort generally needs padding bits.</p>
<p id="rfc.section.8.3.4.1.p.3">Note that the SCHC Sender-Abort has the same header as an All-1 SCHC Fragment, but that it does not include a MIC nor a payload.  Padding bits are strictly less than a L2 Word size.  Since the total size of the MIC and the payload of an All-1 SCHC Fragment is at least the size of an L2 Word, a receiver can, by looking at the message length, distinguish a SCHC Sender-Abort from an All-1 SCHC Fragment (see <a href="#LastFrag" class="xref">Section 8.3.1.2</a>), even in the presence of padding.</p>
<p id="rfc.section.8.3.4.1.p.4">The Rule ID and DTag values in the SCHC Sender-Abort message MUST be identical to the ones used in the fragments of the SCHC Packet the transmission of which is being aborted.</p>
<p id="rfc.section.8.3.4.1.p.5">The SCHC Sender-Abort MUST NOT be acknowledged.</p>
<h1 id="rfc.section.8.3.4.2">
<a href="#rfc.section.8.3.4.2">8.3.4.2.</a> <a href="#schc-receiver-abort" id="schc-receiver-abort">SCHC Receiver-Abort</a>
</h1>
<p id="rfc.section.8.3.4.2.p.1">When a SCHC Fragment receiver needs to abort an on-going fragmented SCHC Packet transmission, it transmits a SCHC Receiver-Abort.  Its format is described in <a href="#Fig-ReceiverAbort" class="xref">Figure 20</a>.  The W field is optional. Its presence is specified by each SCHC F/R mode.</p>
<div id="rfc.figure.20"></div>
<div id="Fig-ReceiverAbort"></div>
<pre>
|--- Receiver-Abort Header ---|

+---- ... ----+-- ... --+---+-+-+-+-+-+-+-+-+-+-+-+-+
|   Rule ID   |   DTag  | W |1| 1..1|      1..1     |
+---- ... ----+-- ... --+---+-+-+-+-+-+-+-+-+-+-+-+-+
                             C
            next L2 Word boundary -&gt;|&lt;-- L2 Word --&gt;|

</pre>
<p class="figure">Figure 20: SCHC Receiver-Abort format</p>
<p id="rfc.section.8.3.4.2.p.2">Note that the SCHC Receiver-Abort has the same header as a SCHC ACK message.  The bits that follow the SCHC Receiver-Abort header look like a truncated Bitmap set to 1 up to the first L2 Word boundary, followed by an extra L2 Word full of 1&#8217;s.  Such a bit pattern never occurs in a regular SCHC ACK. This is how the SCHC Receiver-Abort message is recognized.</p>
<p id="rfc.section.8.3.4.2.p.3">The Rule ID and DTag values in the SCHC Receiver-Abort message MUST be identical to the ones used in the fragments of the SCHC Packet the transmission of which is being aborted.</p>
<p id="rfc.section.8.3.4.2.p.4">A SCHC Receiver-Abort is aligned to L2 Words, by design. Therefore, padding MUST NOT be appended.</p>
<p id="rfc.section.8.3.4.2.p.5">The SCHC Sender-Abort MUST NOT be acknowledged.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#FragModes" id="FragModes">SCHC F/R modes</a>
</h1>
<h1 id="rfc.section.8.4.1">
<a href="#rfc.section.8.4.1">8.4.1.</a> <a href="#No-ACK-subsection" id="No-ACK-subsection">No-ACK mode</a>
</h1>
<p id="rfc.section.8.4.1.p.1">In No-ACK mode, there is no feedback communication from the fragment receiver to the fragment sender.  The sender just transmits all the SCHC Fragments blindly.</p>
<p id="rfc.section.8.4.1.p.2">SCHC ACK or SCHC ACK REQ MUST NOT be sent.  SCHC Sender-Abort MAY be sent. SCHC Receiver-Abort MUST NOT be sent.</p>
<p id="rfc.section.8.4.1.p.3">Windows are not used. Therefore, the W field MUST NOT be present.  The Retransmission Timer is not used.  The Attempts counter is not used.  At the receiver, one Inactivity Timer MUST be maintained for each pair of Rule ID and optional DTag values.  The Inactivity Timer expiration value is based on the characteristics of the underlying LPWAN technology and MUST be defined in a Profile.</p>
<p id="rfc.section.8.4.1.p.4">The presence and size of the MIC and DTag fields MUST be defined by each Profile.  The size of the FCN field is RECOMMENDED to be 1 bit but it MAY be defined by each Profile.</p>
<h1 id="rfc.section.8.4.1.1">
<a href="#rfc.section.8.4.1.1">8.4.1.1.</a> <a href="#sender-behaviour" id="sender-behaviour">Sender behaviour</a>
</h1>
<p id="rfc.section.8.4.1.1.p.1">The sender MUST use the same Rule ID and optional DTag pair for all the SCHC Fragments for a given SCHC Packet.</p>
<p id="rfc.section.8.4.1.1.p.2">Each SCHC Fragment MUST contain exactly one tile in its payload.  The sender MUST transmit the SCHC Fragments messages in the order that the tiles appear in the SCHC Packet.  Except for the last tile of a SCHC Packet, each tile MUST be of a size that complements the SCHC Fragment Header so that the SCHC Fragment is a multiple of L2 Words without the need for padding bits.  Except for the last one, the SCHC Fragments MUST use the Regular SCHC Fragment format specified in <a href="#NotLastFrag" class="xref">Section 8.3.1.1</a>.  The last SCHC Fragment MUST use the All-1 format specified in <a href="#LastFrag" class="xref">Section 8.3.1.2</a>.</p>
<p id="rfc.section.8.4.1.1.p.3">If the Profile mandates the use of a MIC, the MIC MUST be computed on the reassembled SCHC Packet concatenated with the padding bits of the last SCHC Fragment.  The rationale is that the SCHC Reassembler has no way of knowing where the payload of the last SCHC Fragment ends. Indeed, this requires decompressing the SCHC Packet, which is out of the scope of the reassembler.</p>
<p id="rfc.section.8.4.1.1.p.4">The sender MAY transmit a SCHC Sender-Abort.</p>
<p><a href="#Fig-NoACKModeSnd" class="xref">Figure 35</a> shows an example of a corresponding state machine.</p>
<h1 id="rfc.section.8.4.1.2">
<a href="#rfc.section.8.4.1.2">8.4.1.2.</a> <a href="#receiver-behaviour" id="receiver-behaviour">Receiver behaviour</a>
</h1>
<p id="rfc.section.8.4.1.2.p.1">On receiving regular SCHC Fragments with the same Rule ID and optional DTag,</p>
<p></p>

<ul>
<li>the receiver MUST reset the Inactivity Timer,</li>
<li>the receiver assembles the payloads of the SCHC Fragments</li>
</ul>
<p id="rfc.section.8.4.1.2.p.3">On receiving an All-1 SCHC Fragment with the same Rule ID and optional DTag,</p>
<p></p>

<ul>
<li>the receiver MUST appends the All-1 SCHC Fragment Payload and the padding bits to the previously received SCHC Fragment payloads for this SCHC Packet</li>
<li>if an integrity checking is specified in the Profile, <ul>
<li>the receiver MUST perform the integrity check</li>
<li>if integrity checking fails, the receiver MUST drop the reassembled SCHC Packet and it MUST release all resources associated with this Rule ID and optional DTag.</li>
</ul>
</li>
<li>the reassembly operation concludes.</li>
</ul>
<p id="rfc.section.8.4.1.2.p.5">On expiration of the Inactivity Timer, the receiver MUST drop the SCHC Packet being reassembled and it MUST release all resources associated with this Rule ID and optional DTag.</p>
<p id="rfc.section.8.4.1.2.p.6">On receiving a SCHC Sender-Abort, the receiver MAY release all resources associated with this Rule ID and optional DTag.</p>
<p><a href="#Fig-NoACKModeRcv" class="xref">Figure 36</a> shows an example of a corresponding state machine.</p>
<h1 id="rfc.section.8.4.2">
<a href="#rfc.section.8.4.2">8.4.2.</a> <a href="#ACK-Always-subsection" id="ACK-Always-subsection">ACK-Always</a>
</h1>
<p id="rfc.section.8.4.2.p.1">In ACK-Always mode, windows are used.  An acknowledgement, positive or negative, is fed by the fragment receiver back to the fragment sender at the end of the transmission of each window of SCHC Fragments.</p>
<p id="rfc.section.8.4.2.p.2">In a nutshell, the fragment sender iterates retransmitting the SCHC Fragments that are reported missing until the fragment receiver reports that all the SCHC Fragments belonging to the window have been correctly received, or until too many attempts were made.  The fragment sender only advances to the next window of SCHC Fragments when it has ascertained that all the SCHC Fragments belonging to the current window have been fully and correctly received (lock-step behaviour between the sender and the receiver, at the window granularity).</p>
<p id="rfc.section.8.4.2.p.3">The W field MUST be present and its size MUST be 1 bit.</p>
<p id="rfc.section.8.4.2.p.4">At the sender, one W bit and one FCN counter MUST be instantiated for each pair of Rule ID and optional DTag values.  At the receiver, one W bit, one FCN counter and one Bitmap MUST be instantiated for each pair of Rule ID and optional DTag values.  At the sender, one Attempts counter MUST be instantiated for each pair of Rule ID and optional DTag values.  At the sender, one Retransmission Timer MUST be instantiated for each pair of Rule ID and optional DTag values.  At the receiver, one Inactivity Timer MUST be instantiated for each pair of Rule ID and optional DTag values.  The expiration values of the Retransmission Timer and of the Inactivity Timer are based on the characteristics of the underlying LPWAN technology and MUST be defined in a Profile.</p>
<p id="rfc.section.8.4.2.p.5">The presence and size of the MIC and DTag fields MUST be defined by each Profile.</p>
<p id="rfc.section.8.4.2.p.6">The value of N (size of the FCN field) and the value of MAX_WIND_FCN MUST be defined by each Profile.  WINDOW_SIZE MUST be equal to MAX_WIND_FCN + 1.</p>
<p id="rfc.section.8.4.2.p.7">The value of MAX_ACK_REQUESTS MUST be defined by each Profile.</p>
<h1 id="rfc.section.8.4.2.1">
<a href="#rfc.section.8.4.2.1">8.4.2.1.</a> <a href="#sender-behaviour-1" id="sender-behaviour-1">Sender behaviour</a>
</h1>
<p id="rfc.section.8.4.2.1.p.1">At the beginning of the fragmentation of a new SCHC Packet, the fragment sender MUST select a Rule ID and DTag value pair for this SCHC Packet and it MUST initialize the W bit to 0.  The SCHC Packet is fragmented into pieces that will be carried by SCHC Fragment messages, which are grouped in windows.  The SCHC Fragment that comes first in a window, in fragmentation order, MUST have an FCN value of MAX_WIND_FCN.  Within a window, each successive SCHC Fragment MUST bear an FCN field decremented by 1 (unsigned integer) compared to the fragment preceding it in fragmentation order, except for the last SCHC Fragment of the SCHC Packet.  Except for the last window, a window MUST be composed of exactly one SCHC Fragment bearing each possible value of FCN between MAX_WIND_FCN and 0.  In the last window, the last SCHC Fragment in fragmentation order MUST have the FCN value of All-1 and MUST use the format described in <a href="#LastFrag" class="xref">Section 8.3.1.2</a>.  The other SCHC Fragments MUST use the format described in <a href="#NotLastFrag" class="xref">Section 8.3.1.1</a>.</p>
<p id="rfc.section.8.4.2.1.p.2">The fragment sender MUST start by processing the window that is first in fragmentation order.  With this window, it MUST enter a <strong>first state</strong> in which it MUST transmit all the SCHC Fragments composing the window.  The SCHC Fragment that bears the FCN value of All-0 or All-1 MUST be sent last in that series.</p>
<p id="rfc.section.8.4.2.1.p.3">Then, the fragment sender MUST initialize an Attempts counter to 0 for that Rule ID and DTag value pair and it MUST enter a <strong>second state</strong> where it MUST start a Retransmission Timer for that Rule ID and DTag value pair and where it MUST expect to receive a SCHC ACK.</p>
<p></p>

<ul>
<li>On Retransmission Timer expiration, if Attempts is strictly less that MAX_ACK_REQUESTS, the fragment sender MUST send a SCHC ACK REQ and MUST increment the Attempts counter.</li>
<li>If the Retransmission Timer expires while Attempts is greater or equal to MAX_ACK_REQUESTS, the fragment sender MUST send a SCHC Sender-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit with an error condition.</li>
<li>On receiving a SCHC ACK, <ul>
<li>if the SCHC ACK indicates that some fragments are missing at the receiver, the sender MUST increment Attempts, it MUST stop the Retransmission Timer and MUST enter a <strong>third state</strong>.</li>
<li>If the current window is not the last one (All-0) and the SCHC ACK indicates that all fragments were received correctly, the sender MUST stop the Retransmission Timer, it MUST increment W, it MUST advance to the next fragmentation window and it MUST return to the <strong>first state</strong>.</li>
<li>If the current window is the last one (All-1) and the SCHC ACK indicates that more fragments were received than the sender actually sent, the fragment sender MUST send a SCHC Sender-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit with an error condition.</li>
<li>If the current window is the last one (All-1) and the SCHC ACK indicates that all fragments were received correctly yet integrity checking does not match, the fragment sender MUST send a SCHC Sender-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit with an error condition.</li>
<li>If the current window is the last one (All-1) and the SCHC ACK indicates that all fragments were received correctly and integrity checking does match, the sender exits successfully.</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.2.1.p.5">In the <strong>third state</strong>, the fragment sender MUST transmit all the SCHC Fragments that have been reported missing, then it MUST return to the <strong>second state</strong>.</p>
<p id="rfc.section.8.4.2.1.p.6">At any time in the <strong>second state</strong>, the sender MUST silently discard and ignore any SCHC ACK bearing a W value different from its own W value.</p>
<p id="rfc.section.8.4.2.1.p.7">At any time, on receiving a SCHC Receiver-Abort with the correct Rule ID and DTag value pair, the fragment sender MUST release all resource associated with this SCHC Packet and it MUST exit with an error condition.</p>
<p><a href="#Fig-ACKAlwaysSnd" class="xref">Figure 37</a> shows an example of a corresponding state machine.</p>
<p id="rfc.section.8.4.2.1.p.9">A delay between each SCHC Fragment transmission can be added to respect local regulations or other constraints imposed by the applications.</p>
<h1 id="rfc.section.8.4.2.2">
<a href="#rfc.section.8.4.2.2">8.4.2.2.</a> <a href="#receiver-behaviour-1" id="receiver-behaviour-1">Receiver behaviour</a>
</h1>
<p id="rfc.section.8.4.2.2.p.1">On receiving a SCHC Fragment with a Rule ID and DTag pair not being processed at that time, the receiver MUST start a process to assemble a new SCHC Packet with that Rule ID and DTag value pair.  That process MUST only examine received SCHC F/R messages with that Rule ID and DTag value pair and MUST only transmit SCHC F/R messages with that Rule ID and DTag value pair.  It MUST intialise its current window number to be the first one, it MUST initialise its current W bit to 0 and it MUST enter a <strong>first state</strong> and MUST process the SCHC Fragment that was just received.</p>
<p id="rfc.section.8.4.2.2.p.2">Note: the purpose in the <strong>first state</strong> is to receive the initial transmission of the SCHC Fragments of the current window.</p>
<p id="rfc.section.8.4.2.2.p.3">On entering the <strong>first state</strong>, the receiver MUST start an Inactivity Timer and it MUST initialise an empty Bitmap for the current window.</p>
<p id="rfc.section.8.4.2.2.p.4">In the <strong>first state</strong>:</p>
<p></p>

<ul>
<li>Any received SCHC Fragment bearing a W bit different from the current W bit of the receiver process MUST be silently ignored and discarded.  In the rest of this list of actions, only SCHC Fragments that have the correct W bit are considered.</li>
<li>On reception of each SCHC Fragment, the receiver MUST reset the Inactivity Timer and MUST update the Bitmap.</li>
<li>The receiver MUST assemble the payloads of the received SCHC Fragments, based on their FCN and based on the current window number.</li>
<li>On expiration of the Inactivity Timer, the receiver MUST send a SCHC Receiver-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit the receive process for that SCHC Packet.</li>
<li>On receiving an All-0 SCHC Fragment, the receiver MUST send a SCHC ACK (specified in <a href="#ACK" class="xref">Section 8.3.2</a>).  Reminder: the SCHC ACK reports on the SCHC Fragments that have been correctly received in the current window.  <ul>
<li>If the Bitmap indicates that all the SCHC Fragments of the current window have been correctly received, the receiver MUST increment its current window number, it MUST flip its current W bit and it MUST re-enter the <strong>first state</strong>.</li>
<li>If the Bitmap indicates that at least one SCHC Fragment is missing in the current window, the receiver MUST enter a <strong>second state</strong>.</li>
</ul>
</li>
<li>On receiving an All-1 SCHC Fragment, the receiver MUST send a SCHC ACK (specified in <a href="#ACK" class="xref">Section 8.3.2</a>).  Reminder: the SCHC ACK reports on the integrity check of the whole reassembled SCHC Packet and optionally on the SCHC Fragments that were correctly received in the current window.  <ul>
<li>If the integrity check indicates that the full SCHC Packet has been correctly reassembled, the receiver MUST enter the <strong>fourth state</strong>.</li>
<li>If the integrity check indicates that the full SCHC Packet has not been correctly reassembled, the receiver MUST enter a <strong>third state</strong>.</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.2.2.p.6">Note: the purpose in the <strong>second state</strong> is to receive the retransmitted SCHC Fragments of the current window before advancing to the next window.</p>
<p id="rfc.section.8.4.2.2.p.7">On entering the <strong>second state</strong>, the receiver MUST reset the Inactivity Timer.</p>
<p id="rfc.section.8.4.2.2.p.8">In the <strong>second state</strong>:</p>
<p></p>

<ul>
<li>On reception of each SCHC Fragment or SCHC ACK REQ, the receiver MUST reset the Inactivity Timer.</li>
<li>On reception of a SCHC ACK REQ with a W bit equal to that of the receiving process, the receiver MUST send a SCHC ACK and MUST reset the Inactivity Timer.</li>
<li>On reception of a SCHC Fragment with a W bit equal to that of the receiving process, <ul>
<li>If the Bitmap indicates that the SCHC Fragment had already been received, the receiver MUST silently ignore it and discard it.</li>
<li>Otherwise it MUST update the Bitmap and assemble the payload of the SCHC Fragment received.</li>
</ul>
</li>
<li>On the Bitmap becoming fully populated with 1&#8217;s, the receiver MUST send an All-0 SCHC ACK and MUST reset the Inactivity Timer</li>
<li>On expiration of the Inactivity Timer, the receiver MUST send a SCHC Receiver-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit the receive process for that SCHC Packet.</li>
<li>On reception of a SCHC Fragment with a W bit different from that of the receiving process <ul>
<li>If the Bitmap is fully populated with 1&#8217;s, the receiver MUST increment its current window number, it MUST flip its current W bit, it MUST enter the <strong>first state</strong> and it MUST the SCHC Fragment that was just received.</li>
<li>Otherwise, the receiver MUST silently ignore and discard the SCHC Fragment just received.</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.2.2.p.10">Note: the purpose in the <strong>third state</strong> is to receive the retransmitted SCHC Fragments of the last window.</p>
<p id="rfc.section.8.4.2.2.p.11">On entering the <strong>third state</strong>, the receiver MUST reset the Inactivity Timer.</p>
<p id="rfc.section.8.4.2.2.p.12">In the <strong>third state</strong></p>
<p></p>

<ul>
<li>On reception of each SCHC Fragment or SCHC ACK REQ, the receiver MUST reset the Inactivity Timer.</li>
<li>On reception of a SCHC ACK REQ with a W bit equal to that of the receiving process, the receiver MUST send a SCHC ACK and MUST reset the Inactivity Timer.</li>
<li>On reception of a SCHC Fragment with a W bit equal to that of the receiving process, <ul>
<li>If the Bitmap indicates that the SCHC Fragment had already been received, the receiver MUST silently ignore it and discard it.</li>
<li>Otherwise it MUST update the Bitmap and assemble the payload of the SCHC Fragment received. It MUST compute the integrity check.</li>
</ul>
</li>
<li>On the integrity check becoming True, the receiver MUST send a SCHC ACK and MUST reset the Inactivity Timer</li>
<li>On expiration of the Inactivity Timer, the receiver MUST send a SCHC Receiver-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit the receive process for that SCHC Packet.</li>
<li>On reception of a SCHC Fragment with a W bit different from that of the receiving process, the receiver MUST silently ignore and discard the SCHC Fragment just received.</li>
</ul>
<p id="rfc.section.8.4.2.2.p.14">Note: the purpose in the <strong>fourth state</strong> is to increase the chances that the sender receives a SCHC ACK with positive integrity check for this SCHC Packet.</p>
<p id="rfc.section.8.4.2.2.p.15">On entering the <strong>fourth state</strong>, the receiver MUST reset the Inactivity Timer.</p>
<p id="rfc.section.8.4.2.2.p.16">In the <strong>fourth state</strong></p>
<p></p>

<ul>
<li>Any received SCHC F/R message with a W bit different from the current W bit of the receiver process MUST be silently ignored and discarded.</li>
<li>Any received SCHC F/R message different from an All-1 SCHC Fragment or a SCHC ACK REQ MUST be silently ignored and discarded.</li>
<li>On receiving an All-1 SCHC Fragment or a SCHC ACK REQ, the receiver MUST send a SCHC ACK.</li>
<li>On expiration of the Inactivity Timer, the receive process for that SCHC Packet MUST exit</li>
</ul>
<p id="rfc.section.8.4.2.2.p.18">At any time, when Attempts reaches MAC_ACK_REQUESTS, the receiver MUST send a SCHC Receiver-Abort, it MUST release all resource associated with this SCHC Packet and it MUST exit the receive process for that SCHC Packet.</p>
<p id="rfc.section.8.4.2.2.p.19">At any time, on receiving a SCHC Sender-Abort, the fragment sender MUST release all resource associated with this SCHC Packet and it MUST exit the receive process for that SCHC Packet.</p>
<p><a href="#Fig-ACKAlwaysRcv" class="xref">Figure 38</a> shows an example of a corresponding state machine.</p>
<h1 id="rfc.section.8.4.3">
<a href="#rfc.section.8.4.3">8.4.3.</a> <a href="#ACK-on-Error-subsection" id="ACK-on-Error-subsection">ACK-on-Error</a>
</h1>
<p id="rfc.section.8.4.3.p.1">In ACK-on-Error mode, windows are used.  All tiles MUST be of equal size, except for the last one, which MUST be of the same size or smaller than the preceding ones.  WINDOW_SIZE MUST be equal to MAX_WIND_FCN + 1.</p>
<p id="rfc.section.8.4.3.p.2">A SCHC Fragment message carries one or more tiles, which may span multiple windows.  A SCHC ACK reports on the reception of exactly one window of tiles.</p>
<p id="rfc.section.8.4.3.p.3">See <a href="#Fig-TilesACKonError" class="xref">Figure 21</a> for an example.</p>
<div id="rfc.figure.21"></div>
<div id="Fig-TilesACKonError"></div>
<pre>
         +----------------------------------------------...-------------------+
         |                            SCHC Packet                             |
         +----------------------------------------------...-------------------+

Tile #   | 4 | 3 | 2 | 1 | 0 | 4 | 3 | 2 | 1 | 0 | 4 |      | 2 | 1 | 0 | 4 |3|
Window # |-------- 0 --------|-------- 1 --------|- 2 - ... - 27 -------|- 28-|


SCHC Fragment msg    |-----------|
</pre>
<p class="figure">Figure 21: a SCHC Packet fragmented in tiles, Ack-on-Error mode</p>
<p id="rfc.section.8.4.3.p.4">The W field is wide enough that it unambiguously represents an absolute window number.  The fragment receiver feeds SCHC ACKs back to the fragment sender about windows that it misses tiles of.  No SCHC ACK is fed back for windows that have been fully received by the fragment receiver.</p>
<p id="rfc.section.8.4.3.p.5">The fragment sender retransmits SCHC Fragments for tiles that are reported missing.  It can advance to next windows even before it has ascertained that all tiles belonging to previous windows have been correctly received, and can still later retransmit SCHC Fragments with tiles belonging to previous windows.  Therefore, the sender and the receiver may operate in a fully decoupled fashion.  The fragmented SCHC Packet transmission concludes when</p>
<p></p>

<ul>
<li>integrity checking shows that the fragmented SCHC Packet has been correctly reassembled at the receive end, and this information has been conveyed back to the sender,</li>
<li>or too many retransmission attempts were made,</li>
<li>or the receiver determines that the transmission of this fragmented SCHC Packet has been inactive for too long.</li>
</ul>
<p id="rfc.section.8.4.3.p.7">Each Profile MUST specify which Rule ID value(s) is (are) allocated to this ACK-on-Error mode.  For brevity, the rest of <a href="#ACK-on-Error-subsection" class="xref">Section 8.4.3</a> only refers to Rule ID values that are allocated to this mode.</p>
<p id="rfc.section.8.4.3.p.8">The W field MUST be present in SCHC F/R messages.</p>
<p id="rfc.section.8.4.3.p.9">Each Profile, for each Rule ID value, MUST define</p>
<p></p>

<ul>
<li>the tile size (a tile does not need to be multiple of an L2 Word, but it MUST be at least the size of an L2 Word)</li>
<li>the value of M (size of the W field),</li>
<li>the value of N (size of the FCN field),</li>
<li>the value of MAX_WIND_FCN, which MUST be strictly less than (2^N)-1</li>
<li>the presence or absence of the MIC field in the SCHC F/R messages, as well as its size if it is present,</li>
<li>the presence or absence of the DTag field in the SCHC F/R messages, as well as its size if it is present,</li>
<li>the value of MAX_ACK_REQUESTS,</li>
<li>the expiration time of the Retransmission Timer</li>
<li>the expiration time of the Inactivity Timer</li>
</ul>
<p id="rfc.section.8.4.3.p.11">The sender, for each active pair of Rule ID and optional DTag values, MUST instantiate</p>
<p></p>

<ul>
<li>one Attempts counter</li>
<li>one Retransmission Timer</li>
</ul>
<p id="rfc.section.8.4.3.p.13">The receiver, for each pair of Rule ID and optional DTag values, MUST instantiate</p>
<p></p>

<ul><li>one Inactivity Timer</li></ul>
<h1 id="rfc.section.8.4.3.1">
<a href="#rfc.section.8.4.3.1">8.4.3.1.</a> <a href="#ACK-on-Error-sender" id="ACK-on-Error-sender">Sender behaviour</a>
</h1>
<p id="rfc.section.8.4.3.1.p.1">At the beginning of the fragmentation of a new SCHC Packet, the fragment sender MUST select a Rule ID and DTag value pair for this SCHC Packet.  A Rule MUST NOT be selected if the values of M and MAX_WIND_FCN for that Rule are such that the SCHC Packet cannot be fragmented in (2&#710;M) * (MAX_WIND_FCN+1) tiles or less.</p>
<p id="rfc.section.8.4.3.1.p.2">The fragment sender MUST initialize the Attempts counter to 0 for that Rule ID and DTag value pair.</p>
<p id="rfc.section.8.4.3.1.p.3">A SCHC Fragment message carries in its payload one or more tiles.  If more than one tile is carried in one SCHC Fragment, the tiles MUST be consecutive and MUST be ordered from the start of the SCHC Packet toward its end.</p>
<p id="rfc.section.8.4.3.1.p.4">In a SCHC Fragment message, the sender MUST fill the W field with the window number of the first tile sent in that SCHC Fragment.</p>
<p id="rfc.section.8.4.3.1.p.5">If a SCHC Fragment message carries only the last tile of the fragmented SCHC Packet,</p>
<p></p>

<ul>
<li>it MUST be of the All-1 type specified in <a href="#LastFrag" class="xref">Section 8.3.1.2</a>.</li>
<li>if MIC is used, the MIC that is sent MUST be computed on the SCHC Packet and on the padding bits that are appended to the Payload of the last SCHC Fragment</li>
</ul>
<p id="rfc.section.8.4.3.1.p.7">Otherwise,</p>
<p></p>

<ul>
<li>it MUST be of the regular type specified in <a href="#NotLastFrag" class="xref">Section 8.3.1.1</a>
</li>
<li>the FCN field MUST contain the tile number of the first tile sent in that SCHC Fragment.</li>
<li>padding bits MUST be appended to the tiles as needed to fit the Payload size constraint of regular SCHC Fragments</li>
</ul>
<p id="rfc.section.8.4.3.1.p.9">The fragment sender MUST send SCHC Fragments such that, all together, they contain all the tiles of the fragmented SCHC Packet.</p>
<p id="rfc.section.8.4.3.1.p.10">The fragment sender MUST send</p>
<p></p>

<ul>
<li>at least one All-1 SCHC Fragment</li>
<li>or at least one SCHC ACK REQ with the W field corresponding to the last window.</li>
</ul>
<p id="rfc.section.8.4.3.1.p.12">The fragment sender MUST listen for SCHC ACK messages after having sent</p>
<p></p>

<ul>
<li>an All-1 SCHC Fragment</li>
<li>or a SCHC ACK REQ with the W field corresponding to the last window.</li>
</ul>
<p id="rfc.section.8.4.3.1.p.14">Profiles MAY specify other times at which the fragment sender MUST listen for SCHC ACK messages.</p>
<p id="rfc.section.8.4.3.1.p.15">Each time a fragment sender sends an All-1 SCHC Fragment or a SCHC ACK REQ,</p>
<p></p>

<ul>
<li>it MUST increment the Attempts counter</li>
<li>it MUST reset the Retransmission Timer</li>
</ul>
<p id="rfc.section.8.4.3.1.p.17">On Retransmission Timer expiration</p>
<p></p>

<ul>
<li>if Attempts is strictly less than MAX_ACK_REQUESTS, the fragment sender MUST send a SCHC ACK REQ with the W field corresponding to the last window and it MUST increment the Attempts counter</li>
<li>otherwise the fragment sender MUST send a SCHC Sender-Abort and it MUST release all resource associated with this SCHC Packet.</li>
</ul>
<p id="rfc.section.8.4.3.1.p.19">On receiving a SCHC ACK,</p>
<p></p>

<ul>
<li>if the W field in the SCHC ACK corresponds to the last window of the SCHC Packet,  <ul>
<li>if the C bit is set, the sender MUST release all resource associated with this SCHC Packet and MUST exit successfully</li>
<li>otherwise,      <ul>
<li>the fragment sender MUST send SCHC Fragment messages containing all the tiles that are reported missing in the SCHC ACK.</li>
<li>if the last message in this sequence of SCHC Fragment messages is not an All-1 SCHC Fragment, then a SCHC ACK REQ with the W field corresponding to the last window MUST be sent after the sequence</li>
</ul>
</li>
</ul>
</li>
<li>otherwise, the fragment sender  <ul>
<li>MUST send SCHC Fragment messages containing the tiles that are reported missing in the SCHC ACK</li>
<li>then it MAY send a SCHC ACK REQ with the W field corresponding to the last window</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.3.1.p.21">See <a href="#Fig-ACKonerrorSnd" class="xref">Figure 39</a> for an example of a Finite State Machine implementing the sender behaviour.</p>
<h1 id="rfc.section.8.4.3.2">
<a href="#rfc.section.8.4.3.2">8.4.3.2.</a> <a href="#ACK-on-Error-receiver" id="ACK-on-Error-receiver">Receiver behaviour</a>
</h1>
<p id="rfc.section.8.4.3.2.p.1">On receiving a SCHC Fragment with a Rule ID and DTag pair not being processed at that time, the receiver MUST start a process to assemble a new SCHC Packet with that Rule ID and DTag value pair.  That process MUST only examine received SCHC F/R messages with that Rule ID and DTag value pair and MUST only transmit SCHC F/R messages with that Rule ID and DTag value pair.</p>
<p id="rfc.section.8.4.3.2.p.2">(TODO: DTag filtering to avoid allocating a reassembly process for late-coming SCHC Fragments after an abort condition)</p>
<p id="rfc.section.8.4.3.2.p.3">The receiver MUST start an Inactivity Timer. It MUST initialise an Attempts counter to 0.</p>
<p id="rfc.section.8.4.3.2.p.4">On reception of any SCHC F/R message, the receiver MUST reset the Inactivity Timer.</p>
<p id="rfc.section.8.4.3.2.p.5">On reception of a SCHC Fragment message, the receiver MUST assemble the received tiles based on the W and FCN fields of the SCHC Fragment.</p>
<p></p>

<ul>
<li>if the FCN is All-1, the full SCHC Fragment payload MUST be assembled.  This is because the size of the last tile is not known by the receiver, therefore padding bits are indistinguishable from the tile data bits, at this stage.  They will be removed by the SCHC C/D sublayer.  If the size of the SCHC Fragment Payload exceeds or equals the size of one regular tile plus the size of an L2 Word, this SHOULD raise an error flag.</li>
<li>otherwise, padding bits MUST be discarded. This is possible because  <ul>
<li>the size of the tiles is known a priori,</li>
<li>it is larger than an L2 Word</li>
<li>padding bits are always less than an L2 Word</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.3.2.p.7">On reception of a SCHC ACK REQ or of an All-1 SCHC Fragment, the receiver MUST return a SCHC ACK for the lowest-numbered window that has tiles missing at the receiver.  If the receiver knows of no window that has tiles missing, it MUST return a SCHC ACK for the highest-numbered window it currently has tiles for.</p>
<p id="rfc.section.8.4.3.2.p.8">A Profile MAY specify other times and circumstances at which a receiver MUST send a SCHC ACK and which window(s) the SCHC ACK MUST report about.</p>
<p id="rfc.section.8.4.3.2.p.9">On sending a SCHC ACK, the receiver MUST increase the Attempts counter.</p>
<p id="rfc.section.8.4.3.2.p.10">From reception of an All-1 SCHC Fragment onward, a receiver MUST check the integrity of the reassembled SCHC Packet at least every time it prepares for sending a SCHC ACK for the last window.</p>
<p id="rfc.section.8.4.3.2.p.11">On reception of a SCHC Sender-Abort, the receiver MUST release all resource associated with this SCHC Packet.</p>
<p id="rfc.section.8.4.3.2.p.12">On expiration of the Inactivity Timer, the receiver MUST send a SCHC Receiver-Abort and it MUST release all resource associated with this SCHC Packet.</p>
<p id="rfc.section.8.4.3.2.p.13">On the Attempts counter exceeding MAX_ACK_REQUESTS, the receiver MUST send a SCHC Receiver-Abort and it MUST release all resource associated with this SCHC Packet.</p>
<p id="rfc.section.8.4.3.2.p.14">Reassembly of the SCHC Packet concludes when</p>
<p></p>

<ul>
<li>a Sender-Abort has been received</li>
<li>or the Inactivity Timer has expired</li>
<li>or the Attempts counter has exceed MAX_ACK_REQUESTS</li>
<li>or when at least on All-1 SCHC Fragment has been received and integrity checking of the reassembled SCHC Packet is successful.</li>
</ul>
<p id="rfc.section.8.4.3.2.p.16">If MIC is used for integrity checking, the MIC computed at the receiver MUST be computed over the reassembled SCHC Packet and over the padding bits that were received in the All-1 SCHC Fragment.</p>
<p id="rfc.section.8.4.3.2.p.17">See <a href="#Fig-ACKonerrorRcv" class="xref">Figure 40</a> for one possible example of a Finite State Machine implementing a receiver behaviour.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#supporting-multiple-window-sizes" id="supporting-multiple-window-sizes">Supporting multiple window sizes</a>
</h1>
<p id="rfc.section.8.5.p.1">For ACK-Always or ACK-on-Error, implementers MAY opt to support a single window size or multiple window sizes.  The latter, when feasible, may provide performance optimizations.  For example, a large window size SHOULD be used for packets that need to be carried by a large number of SCHC Fragments. However, when the number of SCHC Fragments required to carry a packet is low, a smaller window size, and thus a shorter Bitmap, MAY be sufficient to provide feedback on all SCHC Fragments. If multiple window sizes are supported, the Rule ID MAY be used to signal the window size in use for a specific packet transmission.</p>
<p id="rfc.section.8.5.p.2">Note that the same window size MUST be used for the transmission of all SCHC Fragments that belong to the same SCHC Packet.</p>
<h1 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> <a href="#downlink-schc-fragment-transmission" id="downlink-schc-fragment-transmission">Downlink SCHC Fragment transmission</a>
</h1>
<p id="rfc.section.8.6.p.1">For downlink transmission of a fragmented SCHC Packet in ACK-Always mode, the SCHC Fragment receiver MAY support timer-based SCHC ACK retransmission. In this mechanism, the SCHC Fragment receiver initializes and starts a timer (the Inactivity Timer is used) after the transmission of a SCHC ACK, except when the SCHC ACK is sent in response to the last SCHC Fragment of a packet (All-1 fragment). In the latter case, the SCHC Fragment receiver does not start a timer after transmission of the SCHC ACK.</p>
<p id="rfc.section.8.6.p.2">If, after transmission of a SCHC ACK that is not an All-1 fragment, and before expiration of the corresponding Inactivity timer, the SCHC Fragment receiver receives a SCHC Fragment that belongs to the current window (e.g. a missing SCHC Fragment from the current window) or to the next window, the Inactivity timer for the SCHC ACK is stopped. However, if the Inactivity timer expires, the SCHC ACK is resent and the Inactivity timer is reinitialized and restarted.</p>
<p id="rfc.section.8.6.p.3">The default initial value for the Inactivity timer, as well as the maximum number of retries for a specific SCHC ACK, denoted MAX_ACK_RETRIES, are not defined in this document, and need to be defined in a Profile. The initial value of the Inactivity timer is expected to be greater than that of the Retransmission timer, in order to make sure that a (buffered) SCHC Fragment to be retransmitted can find an opportunity for that transmission.</p>
<p id="rfc.section.8.6.p.4">When the SCHC Fragment sender transmits the All-1 fragment, it starts its Retransmission Timer with a large timeout value (e.g. several times that of the initial Inactivity timer). If a SCHC ACK is received before expiration of this timer, the SCHC Fragment sender retransmits any lost SCHC Fragments reported by the SCHC ACK, or if the SCHC ACK confirms successful reception of all SCHC Fragments of the last window, the transmission of the fragmented SCHC Packet is considered complete. If the timer expires, and no SCHC ACK has been received since the start of the timer, the SCHC Fragment sender assumes that the All-1 fragment has been successfully received (and possibly, the last SCHC ACK has been lost: this mechanism assumes that the retransmission timer for the All-1 fragment is long enough to allow several SCHC ACK retries if the All-1 fragment has not;been received by the SCHC Fragment receiver, and it also assumes that it is unlikely that several ACKs become all lost).</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Padding" id="Padding">Padding management</a>
</h1>
<p id="rfc.section.9.p.1">SCHC C/D and SCHC F/R operate on bits, not bytes. SCHC itself does not have any alignment prerequisite.  If the L2 below SCHC constrains the payload to align to some boundary, called L2 Words (for example, bytes), SCHC will meet that constraint and produce messages with the correct alignement.  This may entail adding extra bits (called padding bits).</p>
<p id="rfc.section.9.p.2">When padding occurs, the number of appended bits is strictly less than the L2 Word size.</p>
<p id="rfc.section.9.p.3">Padding happens at most once for each Packet during SCHC Compression and optional SCHC Fragmentation (see <a href="#Fig-IntroLayers" class="xref">Figure 2</a>).  If a SCHC Packet is sent unfragmented (see <a href="#Fig-Operations-Pad" class="xref">Figure 22</a>), it is padded as needed.  If a SCHC Packet is fragmented, only the last fragment is padded as needed.</p>
<div id="rfc.figure.22"></div>
<div id="Fig-Operations-Pad"></div>
<pre>
A packet (e.g. an IPv6 packet)
         |                                           ^ (padding bits
         v                                           |       dropped)
+------------------+                      +--------------------+
| SCHC Compression |                      | SCHC Decompression |
+------------------+                      +--------------------+
         |                                           ^
         |   If no fragmentation                     |
         +---- SCHC Packet + padding as needed -----&gt;|
         |                                           | (MIC checked
         v                                           |  and removed)
+--------------------+                       +-----------------+
| SCHC Fragmentation |                       | SCHC Reassembly |
+--------------------+                       +-----------------+
     |       ^                                   |       ^
     |       |                                   |       |
     |       +------------- SCHC ACK ------------+       |
     |                                                   |
     +--------------- SCHC Fragments --------------------+
     +--- last SCHC Frag with MIC + padding as needed ---+

        SENDER                                    RECEIVER


</pre>
<p class="figure">Figure 22: SCHC operations, including padding as needed</p>
<p id="rfc.section.9.p.4">Each Profile MUST specify the size of the L2 Word.  The L2 Word might actually be a single bit, in which case at most zero bits of padding will be appended to any message, i.e. no padding will take place at all.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#schc-compression-for-ipv6-and-udp-headers" id="schc-compression-for-ipv6-and-udp-headers">SCHC Compression for IPv6 and UDP headers</a>
</h1>
<p id="rfc.section.10.p.1">This section lists the different IPv6 and UDP header fields and how they can be compressed.</p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#ipv6-version-field" id="ipv6-version-field">IPv6 version field</a>
</h1>
<p id="rfc.section.10.1.p.1">This field always holds the same value. Therefore, in the Rule, TV is set to 6, MO to &#8220;equal&#8221; and CDA to &#8220;not-sent&#8221;.</p>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#ipv6-traffic-class-field" id="ipv6-traffic-class-field">IPv6 Traffic class field</a>
</h1>
<p id="rfc.section.10.2.p.1">If the DiffServ field does not vary and is known by both sides, the Field Descriptor in the Rule SHOULD contain a TV with this well-known value, an &#8220;equal&#8221; MO and a &#8220;not-sent&#8221; CDA.</p>
<p id="rfc.section.10.2.p.2">Otherwise (e.g. ECN bits are to be transmitted), two possibilities can be considered depending on the variability of the value:</p>
<p></p>

<ul>
<li>One possibility is to not compress the field and send the original value. In the Rule, TV is not set to any particular value, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
<li>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the Rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</li>
</ul>
<h1 id="rfc.section.10.3">
<a href="#rfc.section.10.3">10.3.</a> <a href="#flow-label-field" id="flow-label-field">Flow label field</a>
</h1>
<p id="rfc.section.10.3.p.1">If the Flow Label field does not vary and is known by both sides, the Field Descriptor in the Rule SHOULD contain a TV with this well-known value, an &#8220;equal&#8221; MO and a &#8220;not-sent&#8221; CDA.</p>
<p id="rfc.section.10.3.p.2">Otherwise, two possibilities can be considered:</p>
<p></p>

<ul>
<li>One possibility is to not compress the field and send the original value. In the Rule, TV is not set to any particular value, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
<li>If some upper bits in the field are constant and known, a better option is to only send the LSBs. In the Rule, TV is set to a value with the stable known upper part, MO is set to MSB(x) and CDA to LSB(y).</li>
</ul>
<h1 id="rfc.section.10.4">
<a href="#rfc.section.10.4">10.4.</a> <a href="#payload-length-field" id="payload-length-field">Payload Length field</a>
</h1>
<p id="rfc.section.10.4.p.1">This field can be elided for the transmission on the LPWAN network. The SCHC C/D recomputes the original payload length value. In the Field Descriptor, TV is not set, MO is set to &#8220;ignore&#8221; and CDA is &#8220;compute-IPv6-length&#8221;.</p>
<p id="rfc.section.10.4.p.2">If the payload length needs to be sent and does not need to be coded in 16 bits, the TV can be set to 0x0000, the MO set to MSB(16-s) where &#8216;s&#8217; is the number of bits to code the maximum length, and CDA is set to LSB(s).</p>
<h1 id="rfc.section.10.5">
<a href="#rfc.section.10.5">10.5.</a> <a href="#next-header-field" id="next-header-field">Next Header field</a>
</h1>
<p id="rfc.section.10.5.p.1">If the Next Header field does not vary and is known by both sides, the Field Descriptor in the Rule SHOULD contain a TV with this Next Header value, the MO SHOULD be &#8220;equal&#8221; and the CDA SHOULD be &#8220;not-sent&#8221;.</p>
<p id="rfc.section.10.5.p.2">Otherwise, TV is not set in the Field Descriptor, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;. Alternatively, a matching-list MAY also be used.</p>
<h1 id="rfc.section.10.6">
<a href="#rfc.section.10.6">10.6.</a> <a href="#hop-limit-field" id="hop-limit-field">Hop Limit field</a>
</h1>
<p id="rfc.section.10.6.p.1">The field behavior for this field is different for Uplink and Downlink. In Uplink, since there is no IP forwarding between the Dev and the SCHC C/D, the value is relatively constant. On the other hand, the Downlink value depends of Internet routing and MAY change more frequently. One neat way of processing this field is to use the Direction Indicator (DI) to distinguish both directions:</p>
<p></p>

<ul>
<li>in the Uplink, elide the field: the TV in the Field Descriptor is set to the known constant value, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</li>
<li>in the Downlink, send the value: TV is not set, MO is set to &#8220;ignore&#8221; and CDA is set to &#8220;value-sent&#8221;.</li>
</ul>
<h1 id="rfc.section.10.7">
<a href="#rfc.section.10.7">10.7.</a> <a href="#ipv6-addresses-fields" id="ipv6-addresses-fields">IPv6 addresses fields</a>
</h1>
<p id="rfc.section.10.7.p.1">As in 6LoWPAN <a href="#RFC4944" class="xref">[RFC4944]</a>, IPv6 addresses are split into two 64-bit long fields; one for the prefix and one for the Interface Identifier (IID). These fields SHOULD be compressed. To allow for a single Rule being used for both directions, these values are identified by their role (DEV or APP) and not by their position in the header (source or destination).</p>
<h1 id="rfc.section.10.7.1">
<a href="#rfc.section.10.7.1">10.7.1.</a> <a href="#ipv6-source-and-destination-prefixes" id="ipv6-source-and-destination-prefixes">IPv6 source and destination prefixes</a>
</h1>
<p id="rfc.section.10.7.1.p.1">Both ends MUST be synchronized with the appropriate prefixes. For a specific flow, the source and destination prefixes can be unique and stored in the context. It can be either a link-local prefix or a global prefix. In that case, the TV for the source and destination prefixes contain the values, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.10.7.1.p.2">If the Rule is intended to compress packets with different prefix values, match-mapping SHOULD be used. The different prefixes are listed in the TV, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;. See <a href="#Fig-fields" class="xref">Figure 24</a></p>
<p id="rfc.section.10.7.1.p.3">Otherwise, the TV contains the prefix, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.10.7.2">
<a href="#rfc.section.10.7.2">10.7.2.</a> <a href="#ipv6-source-and-destination-iid" id="ipv6-source-and-destination-iid">IPv6 source and destination IID</a>
</h1>
<p id="rfc.section.10.7.2.p.1">If the DEV or APP IID are based on an LPWAN address, then the IID can be reconstructed with information coming from the LPWAN header. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;DevIID&#8221; or &#8220;AppIID&#8221;. Note that the LPWAN technology generally carries a single identifier corresponding to the DEV. Therefore AppIID cannot be used.</p>
<p id="rfc.section.10.7.2.p.2">For privacy reasons or if the DEV address is changing over time, a static value that is not equal to the DEV address SHOULD be used. In that case, the TV contains the static value, the MO operator is set to &#8220;equal&#8221; and the CDF is set to &#8220;not-sent&#8221;.  <a href="#RFC7217" class="xref">[RFC7217]</a> provides some methods that MAY be used to derive this static identifier.</p>
<p id="rfc.section.10.7.2.p.3">If several IIDs are possible, then the TV contains the list of possible IIDs, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.10.7.2.p.4">It MAY also happen that the IID variability only expresses itself on a few bytes. In that case, the TV is set to the stable part of the IID, the MO is set to &#8220;MSB&#8221; and the CDA is set to &#8220;LSB&#8221;.</p>
<p id="rfc.section.10.7.2.p.5">Finally, the IID can be sent in extenso on the LPWAN. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.10.8">
<a href="#rfc.section.10.8">10.8.</a> <a href="#ipv6-extensions" id="ipv6-extensions">IPv6 extensions</a>
</h1>
<p id="rfc.section.10.8.p.1">No Rule is currently defined that processes IPv6 extensions. If such extensions are needed, their compression/decompression Rules can be based on the MOs and CDAs described above.</p>
<h1 id="rfc.section.10.9">
<a href="#rfc.section.10.9">10.9.</a> <a href="#udp-source-and-destination-port" id="udp-source-and-destination-port">UDP source and destination port</a>
</h1>
<p id="rfc.section.10.9.p.1">To allow for a single Rule being used for both directions, the UDP port values are identified by their role (DEV or APP) and not by their position in the header (source or destination). The SCHC C/D MUST be aware of the traffic direction (Uplink, Downlink) to select the appropriate field. The following Rules apply for DEV and APP port numbers.</p>
<p id="rfc.section.10.9.p.2">If both ends know the port number, it can be elided. The TV contains the port number, the MO is set to &#8220;equal&#8221; and the CDA is set to &#8220;not-sent&#8221;.</p>
<p id="rfc.section.10.9.p.3">If the port variation is on few bits, the TV contains the stable part of the port number, the MO is set to &#8220;MSB&#8221; and the CDA is set to &#8220;LSB&#8221;.</p>
<p id="rfc.section.10.9.p.4">If some well-known values are used,  the TV can contain the list of these values, the MO is set to &#8220;match-mapping&#8221; and the CDA is set to &#8220;mapping-sent&#8221;.</p>
<p id="rfc.section.10.9.p.5">Otherwise the port numbers are sent over the LPWAN. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.10.10">
<a href="#rfc.section.10.10">10.10.</a> <a href="#udp-length-field" id="udp-length-field">UDP length field</a>
</h1>
<p id="rfc.section.10.10.p.1">The UDP length can be computed from the received data. In that case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-length&#8221;.</p>
<p id="rfc.section.10.10.p.2">If the payload is small, the TV can be set to 0x0000, the MO set to &#8220;MSB&#8221; and the CDA to &#8220;LSB&#8221;.</p>
<p id="rfc.section.10.10.p.3">In other cases, the length SHOULD be sent and the CDA is replaced by &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.10.11">
<a href="#rfc.section.10.11">10.11.</a> <a href="#UDPchecksum" id="UDPchecksum">UDP Checksum field</a>
</h1>
<p id="rfc.section.10.11.p.1">The UDP checksum operation is mandatory with IPv6 <a href="#RFC8200" class="xref">[RFC8200]</a> for most packets but recognizes that there are exceptions to that default behavior.</p>
<p id="rfc.section.10.11.p.2">For instance, protocols that use UDP as a tunnel encapsulation may enable zero-checksum mode for a specific port (or set of ports) for sending and/or receiving. <a href="#RFC8200" class="xref">[RFC8200]</a> also stipulates that any node implementing zero-checksum mode must follow the requirements specified in &#8220;Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums&#8221; <a href="#RFC6936" class="xref">[RFC6936]</a>.</p>
<p id="rfc.section.10.11.p.3">6LoWPAN Header Compression <a href="#RFC6282" class="xref">[RFC6282]</a> also authorizes to send UDP datagram that are deprived of the checksum protection when an upper layer guarantees the integrity of the UDP payload and pseudo-header all the way between the compressor that elides the UDP checksum and the decompressor that computes again it. A specific example of this is when a Message Integrity Check (MIC) protects the compressed message all along that path with a strength that is identical or better to the UDP checksum.</p>
<p id="rfc.section.10.11.p.4">In a similar fashion, this specification allows a SCHC compressor to elide the UDP checks when another layer guarantees an identical or better integrity protection for the UDP payload and the pseudo-header.  In this case, the TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;compute-checksum&#8221;.</p>
<p id="rfc.section.10.11.p.5">In particular, when SCHC fragmentation is used, a fragmentation MIC of 2 bytes or more provides equal or better protection than the UDP checksum; in that case, if the compressor is collocated with the fragmentation point and the decompressor is collocated with the packet reassembly point, then compressor MAY elide the UDP checksum.  Whether and when the UDP Checksum is elided is to be specified in the Profile.</p>
<p id="rfc.section.10.11.p.6">Since the compression happens before the fragmentation, implementors should understand the risks when dealing with unprotected data below the transport layer and take special care when manipulating that data.</p>
<p id="rfc.section.10.11.p.7">In other cases, the checksum SHOULD be explicitly sent. The TV is not set, the MO is set to &#8220;ignore&#8221; and the CDA is set to &#8220;value-sent&#8221;.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">This document has no request to IANA.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#security-considerations" id="security-considerations">Security considerations</a>
</h1>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#security-considerations-for-schc-compressiondecompression" id="security-considerations-for-schc-compressiondecompression">Security considerations for SCHC Compression/Decompression</a>
</h1>
<p id="rfc.section.12.1.p.1">A malicious header compression could cause the reconstruction of a wrong packet that does not match with the original one. Such a corruption MAY be detected with end-to-end authentication and integrity mechanisms. Header Compression does not add more security problem than what is already needed in a transmission. For instance, to avoid an attack, never re-construct a packet bigger than some configured size (with 1500 bytes as generic default).</p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#security-considerations-for-schc-fragmentationreassembly" id="security-considerations-for-schc-fragmentationreassembly">Security considerations for SCHC Fragmentation/Reassembly</a>
</h1>
<p id="rfc.section.12.2.p.1">This subsection describes potential attacks to LPWAN SCHC F/R and suggests possible countermeasures.</p>
<p id="rfc.section.12.2.p.2">A node can perform a buffer reservation attack by sending a first SCHC Fragment to a target.  Then, the receiver will reserve buffer space for the IPv6 packet.  Other incoming fragmented SCHC Packets will be dropped while the reassembly buffer is occupied during the reassembly timeout.  Once that timeout expires, the attacker can repeat the same procedure, and iterate, thus creating a denial of service attack.  The (low) cost to mount this attack is linear with the number of buffers at the target node.  However, the cost for an attacker can be increased if individual SCHC Fragments of multiple packets can be stored in the reassembly buffer.  To further increase the attack cost, the reassembly buffer can be split into SCHC Fragment-sized buffer slots. Once a packet is complete, it is processed normally.  If buffer overload occurs, a receiver can discard packets based on the sender behavior, which MAY help identify which SCHC Fragments have been sent by an attacker.</p>
<p id="rfc.section.12.2.p.3">In another type of attack, the malicious node is required to have overhearing capabilities.  If an attacker can overhear a SCHC Fragment, it can send a spoofed duplicate (e.g. with random payload) to the destination. If the LPWAN technology does not support suitable protection (e.g. source authentication and frame counters to prevent replay attacks), a receiver cannot distinguish legitimate from spoofed SCHC Fragments.  Therefore, the original IPv6 packet will be considered corrupt and will be dropped. To protect resource-constrained nodes from this attack, it has been proposed to establish a binding among the SCHC Fragments to be transmitted by a node, by applying content-chaining to the different SCHC Fragments, based on cryptographic hash functionality.  The aim of this technique is to allow a receiver to identify illegitimate SCHC Fragments.</p>
<p id="rfc.section.12.2.p.4">Further attacks MAY involve sending overlapped fragments (i.e. comprising some overlapping parts of the original IPv6 datagram). Implementers SHOULD make sure that the correct operation is not affected by such event.</p>
<p id="rfc.section.12.2.p.5">In ACK-on-Error, a malicious node MAY force a SCHC Fragment sender to resend a SCHC Fragment a number of times, with the aim to increase consumption of the SCHC Fragment sender&#8217;s resources. To this end, the malicious node MAY repeatedly send a fake ACK to the SCHC Fragment sender, with a Bitmap that reports that one or more SCHC Fragments have been lost. In order to mitigate this possible attack, MAX_ACK_RETRIES MAY be set to a safe value which allows to limit the maximum damage of the attack to an acceptable extent. However, note that a high setting for MAX_ACK_RETRIES benefits SCHC Fragment reliability modes, therefore the trade-off needs to be carefully considered.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.13.p.1">Thanks to Carsten Bormann, Philippe Clavier, Diego Dujovne, Eduardo Ingles Sanchez, Arunprabhu Kandasamy, Rahul Jadhav, Sergio Lopez Bernal, Antony Markovski, Alexander Pelov, Charles Perkins, Edgar Ramos, Shoichi Sakane, Pascal Thubert and Juan Carlos Zuniga for useful design consideration and comments.</p>
<h1 id="rfc.references">
<a href="#rfc.references">14.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">14.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7217">[RFC7217]</b></td>
<td class="top">
<a>Gont, F.</a>, "<a href="https://tools.ietf.org/html/rfc7217">A Method for Generating Semantically Opaque Interface Identifiers with IPv6 Stateless Address Autoconfiguration (SLAAC)</a>", RFC 7217, DOI 10.17487/RFC7217, April 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">14.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC3385">[RFC3385]</b></td>
<td class="top">
<a>Sheinwald, D.</a>, <a>Satran, J.</a>, <a>Thaler, P.</a> and <a>V. Cavanna</a>, "<a href="https://tools.ietf.org/html/rfc3385">Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations</a>", RFC 3385, DOI 10.17487/RFC3385, September 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4944">[RFC4944]</b></td>
<td class="top">
<a>Montenegro, G.</a>, <a>Kushalnagar, N.</a>, <a>Hui, J.</a> and <a>D. Culler</a>, "<a href="https://tools.ietf.org/html/rfc4944">Transmission of IPv6 Packets over IEEE 802.15.4 Networks</a>", RFC 4944, DOI 10.17487/RFC4944, September 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5795">[RFC5795]</b></td>
<td class="top">
<a>Sandlund, K.</a>, <a>Pelletier, G.</a> and <a>L-E. Jonsson</a>, "<a href="https://tools.ietf.org/html/rfc5795">The RObust Header Compression (ROHC) Framework</a>", RFC 5795, DOI 10.17487/RFC5795, March 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6282">[RFC6282]</b></td>
<td class="top">
<a>Hui, J.</a> and <a>P. Thubert</a>, "<a href="https://tools.ietf.org/html/rfc6282">Compression Format for IPv6 Datagrams over IEEE 802.15.4-Based Networks</a>", RFC 6282, DOI 10.17487/RFC6282, September 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6936">[RFC6936]</b></td>
<td class="top">
<a>Fairhurst, G.</a> and <a>M. Westerlund</a>, "<a href="https://tools.ietf.org/html/rfc6936">Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums</a>", RFC 6936, DOI 10.17487/RFC6936, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7136">[RFC7136]</b></td>
<td class="top">
<a>Carpenter, B.</a> and <a>S. Jiang</a>, "<a href="https://tools.ietf.org/html/rfc7136">Significance of IPv6 Interface Identifiers</a>", RFC 7136, DOI 10.17487/RFC7136, February 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8200">[RFC8200]</b></td>
<td class="top">
<a>Deering, S.</a> and <a>R. Hinden</a>, "<a href="https://tools.ietf.org/html/rfc8200">Internet Protocol, Version 6 (IPv6) Specification</a>", STD 86, RFC 8200, DOI 10.17487/RFC8200, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8376">[RFC8376]</b></td>
<td class="top">
<a>Farrell, S.</a>, "<a href="https://tools.ietf.org/html/rfc8376">Low-Power Wide Area Network (LPWAN) Overview</a>", RFC 8376, DOI 10.17487/RFC8376, May 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#compressIPv6" id="compressIPv6">SCHC Compression Examples</a>
</h1>
<p id="rfc.section.A.p.1">This section gives some scenarios of the compression mechanism for IPv6/UDP. The goal is to illustrate the behavior of SCHC.</p>
<p id="rfc.section.A.p.2">The most common case using the mechanisms defined in this document will be a LPWAN Dev that embeds some applications running over CoAP. In this example, three flows are considered. The first flow is for the device management based on CoAP using Link Local IPv6 addresses and UDP ports 123 and 124 for Dev and App, respectively.  The second flow will be a CoAP server for measurements done by the Device (using ports 5683) and Global IPv6 Address prefixes alpha::IID/64 to beta::1/64.  The last flow is for legacy applications using different ports numbers, the destination IPv6 address prefix is gamma::1/64.</p>
<p><a href="#FigStack" class="xref">Figure 23</a> presents the protocol stack for this Device. IPv6 and UDP are represented with dotted lines since these protocols are compressed on the radio link.</p>
<div id="rfc.figure.23"></div>
<div id="FigStack"></div>
<pre>
 Management   Data
+----------+---------+---------+
|   CoAP   |  CoAP   | legacy  |
+----||----+---||----+---||----+
.   UDP    .  UDP    |   UDP   |
................................
.   IPv6   .  IPv6   .  IPv6   .
+------------------------------+
|    SCHC Header compression   |
|      and fragmentation       |
+------------------------------+
|      LPWAN L2 technologies   |
+------------------------------+
         DEV or NGW

</pre>
<p class="figure">Figure 23: Simplified Protocol Stack for LP-WAN</p>
<p id="rfc.section.A.p.4">Note that in some LPWAN technologies, only the Devs have a device ID.  Therefore, when such technologies are used, it is necessary to statically define an IID for the Link Local address for the SCHC C/D.</p>
<div id="rfc.figure.24"></div>
<div id="Fig-fields"></div>
<pre>
Rule 0
 +----------------+--+--+--+---------+--------+------------++------+
 | Field &#160; &#160; &#160; &#160;  |FL|FP|DI| Value &#160; | Match  | Comp Decomp|| Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+---------------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 APPprefix  |64|1 |Bi|FE80::/64| equal  | not-sent   ||      |
 |IPv6 AppIID     |64|1 |Bi|::1      | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|123      | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|124      | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+

 Rule 1
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Bi|255      | ignore | not-sent   ||      |
 |IPv6 DEVprefix  |64|1 |Bi|[alpha/64, match- |mapping-sent||  [1] |
 |                |  |  |  |fe80::/64] mapping|            ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 APPprefix  |64|1 |Bi|[beta/64,| match- |mapping-sent||  [2] |
 |                |  |  |  |alpha/64,| mapping|            ||      |
 |                |  |  |  |fe80::64]|        |            ||      |
 |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP APPport     |16|1 |Bi|5683     | equal  | not-sent   ||      |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+

 Rule 2
 +----------------+--+--+--+---------+--------+------------++------+
 | Field          |FL|FP|DI| Value   | Match  | Action     || Sent |
 |                |  |  |  |         | Opera. | Action     ||[bits]|
 +----------------+--+--+--+---------+--------+------------++------+
 |IPv6 version    |4 |1 |Bi|6        | equal  | not-sent   ||      |
 |IPv6 DiffServ   |8 |1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Flow Label |20|1 |Bi|0        | equal  | not-sent   ||      |
 |IPv6 Length     |16|1 |Bi|         | ignore | comp-length||      |
 |IPv6 Next Header|8 |1 |Bi|17       | equal  | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Up|255      | ignore | not-sent   ||      |
 |IPv6 Hop Limit  |8 |1 |Dw|         | ignore | value-sent ||  [8] |
 |IPv6 DEVprefix  |64|1 |Bi|alpha/64 | equal  | not-sent   ||      |
 |IPv6 DevIID     |64|1 |Bi|         | ignore | DevIID     ||      |
 |IPv6 APPprefix  |64|1 |Bi|gamma/64 | equal  | not-sent   ||      |
 |IPv6 AppIID     |64|1 |Bi|::1000   | equal  | not-sent   ||      |
 +================+==+==+==+=========+========+============++======+
 |UDP DEVport     |16|1 |Bi|8720     | MSB(12)| LSB        || [4]  |
 |UDP APPport     |16|1 |Bi|8720     | MSB(12)| LSB        || [4]  |
 |UDP Length      |16|1 |Bi|         | ignore | comp-length||      |
 |UDP checksum    |16|1 |Bi|         | ignore | comp-chk   ||      |
 +================+==+==+==+=========+========+============++======+


</pre>
<p class="figure">Figure 24: Context Rules</p>
<p id="rfc.section.A.p.5">All the fields described in the three Rules depicted on <a href="#Fig-fields" class="xref">Figure 24</a> are present in the IPv6 and UDP headers.  The DevIID-DID value is found in the L2 header.</p>
<p id="rfc.section.A.p.6">The second and third Rules use global addresses. The way the Dev learns the prefix is not in the scope of the document.</p>
<p id="rfc.section.A.p.7">The third Rule compresses port numbers to 4 bits.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#fragmentation-examples" id="fragmentation-examples">Fragmentation Examples</a>
</h1>
<p id="rfc.section.B.p.1">This section provides examples for the different fragment reliability modes specified in this document.</p>
<p><a href="#Fig-Example-Unreliable" class="xref">Figure 25</a> illustrates the transmission in No-ACK mode of an IPv6 packet that needs 11 fragments. FCN is 1 bit wide.</p>
<div id="rfc.figure.25"></div>
<div id="Fig-Example-Unreliable"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-------FCN=0--------&gt;|
          |-----FCN=1 + MIC ---&gt;|MIC checked: success =&gt;
 &#160; &#160; &#160; &#160;
</pre>
<p class="figure">Figure 25: Transmission in No-ACK mode of an IPv6 packet carried by 11 fragments</p>
<p id="rfc.section.B.p.3">In the following examples, N (i.e. the size if the FCN field) is 3 bits. Therefore, the All-1 FCN value is 7.</p>
<p><a href="#Fig-Example-Win-NoLoss-NACK" class="xref">Figure 26</a> illustrates the transmission in ACK-on-Error of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no fragment loss.</p>
<div id="rfc.figure.26"></div>
<div id="Fig-Example-Win-NoLoss-NACK"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2-----&gt;|
          |-----W=0, FCN=1-----&gt;|
          |-----W=0, FCN=0-----&gt;|
      (no ACK)
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4-----&gt;|
          |--W=1, FCN=7 + MIC--&gt;|MIC checked: success =&gt;
          |&lt;---- ACK, W=1 ------|

</pre>
<p class="figure">Figure 26: Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no loss.</p>
<p><a href="#Fig-Example-Rel-Window-NACK-Loss" class="xref">Figure 27</a> illustrates the transmission in ACK-on-Error mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<div id="rfc.figure.27"></div>
<div id="Fig-Example-Rel-Window-NACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160; Sender &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4--X--&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2--X--&gt;|             7
          |-----W=0, FCN=1-----&gt;|             /
          |-----W=0, FCN=0-----&gt;|       6543210
          |&lt;-----ACK, W=0-------|Bitmap:1101011
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=2-----&gt;|   
      (no ACK)     
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4--X--&gt;|
          |- W=1, FCN=7 + MIC -&gt;|MIC checked: failed
          |&lt;-----ACK, W=1-------|C=0 Bitmap:1100001
          |-----W=1, FCN=4-----&gt;|MIC checked: success =&gt;
          |&lt;---- ACK, W=1 ------|C=1, no Bitmap

</pre>
<p class="figure">Figure 27: Transmission in ACK-on-Error mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<p><a href="#Figure-Example-ACK-on-Error-VarMTU" class="xref">Figure 28</a> shows an example of a transmission in ACK-on-Error mode of a SCHC Packet broken into 73 tiles, with N=5, MAX_WIND_FCN=27, M=2 and 3 lost SCHC Fragments.</p>
<div id="rfc.figure.28"></div>
<div id="Figure-Example-ACK-on-Error-VarMTU"></div>
<pre>
      Sender               Receiver
        |-----W=0, FCN=27-----&gt;| 4 tiles sent
        |-----W=0, FCN=23-----&gt;| 4 tiles sent
        |-----W=0, FCN=19-----&gt;| 4 tiles sent
        |-----W=0, FCN=15--X--&gt;| 4 tiles sent (not received)
        |-----W=0, FCN=11-----&gt;| 4 tiles sent
        |-----W=0, FCN=7 -----&gt;| 4 tiles sent
        |-----W=0, FCN=3 -----&gt;| 4 tiles sent
        |-----W=1, FCN=27-----&gt;| 4 tiles sent
        |-----W=1, FCN=23-----&gt;| 4 tiles sent
        |-----W=1, FCN=19-----&gt;| 4 tiles sent
        |-----W=1, FCN=15-----&gt;| 4 tiles sent
        |-----W=1, FCN=11-----&gt;| 4 tiles sent
        |-----W=1, FCN=7 -----&gt;| 4 tiles sent
        |-----W=1, FCN=3 --X--&gt;| 4 tiles sent (not received)
        |-----W=2, FCN=27-----&gt;| 4 tiles sent
        |-----W=2, FCN=23-----&gt;| 4 tiles sent
    ^   |-----W=2, FCN=19-----&gt;| 1 tile sent
    |   |-----W=2, FCN=18-----&gt;| 1 tile sent
    |   |-----W=2, FCN=17-----&gt;| 1 tile sent
        |-----W=2, FCN=16-----&gt;| 1 tile sent
    s   |-----W=2, FCN=15-----&gt;| 1 tile sent
    m   |-----W=2, FCN=14-----&gt;| 1 tile sent
    a   |-----W=2, FCN=13--X--&gt;| 1 tile sent (not received)
    l   |-----W=2, FCN=12-----&gt;| 1 tile sent
    l   |---W=2, FCN=31 + MIC-&gt;| Integrity check: failure
    e   |&lt;------ACK, W=0-------| Bitmap:1111111111110000111111111111
    r   |-----W=0, FCN=15-----&gt;| 1 tile sent
        |-----W=0, FCN=14-----&gt;| 1 tile sent
    L   |-----W=0, FCN=13-----&gt;| 1 tile sent
    2   |-----W=0, FCN=12-----&gt;| 1 tile sent
        |&lt;------ACK, W=1-------| Bitmap:1111111111111111111111110000
    M   |-----W=1, FCN=3 -----&gt;| 1 tile sent
    T   |-----W=1, FCN=2 -----&gt;| 1 tile sent
    U   |-----W=1, FCN=1 -----&gt;| 1 tile sent
        |-----W=1, FCN=0 -----&gt;| 1 tile sent
    |   |&lt;------ACK, W=2-------| Bitmap:1111111111111101100000000000
    |   |-----W=2, FCN=13-----&gt;| Integrity check: success
    V   |&lt;-----ACK, W=2, C=1 --| C=1
      (End)

</pre>
<p class="figure">Figure 28: ACK-on-Error mode with variable MTU.</p>
<p id="rfc.section.B.p.7">In this example, the L2 MTU becomes reduced just before sending the &#8220;W=2, FCN=19&#8221; fragment, leaving space for only 1 tile in each forthcoming SCHC Fragment.  Before retransmissions, the 73 tiles are carried by a total of 25 SCHC Fragments, the last 9 being of smaller size.</p>
<p id="rfc.section.B.p.8">Note 1: Bitmaps are shown prior to truncation for transmission Note 2: other behaviors (e.g. regarding when ACKs are sent by the Receiver) are also allowed in ACK-on-Error.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-NoLoss" class="xref">Figure 29</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and no loss.</p>
<div id="rfc.figure.29"></div>
<div id="Fig-Example-Rel-Window-ACK-NoLoss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|
          |-----W=0, FCN=4-----&gt;|
          |-----W=0, FCN=3-----&gt;|
          |-----W=0, FCN=2-----&gt;|
          |-----W=0, FCN=1-----&gt;|
          |-----W=0, FCN=0-----&gt;|
          |&lt;-----ACK, W=0-------| Bitmap:1111111
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|   
          |-----W=1, FCN=4-----&gt;|
          |--W=1, FCN=7 + MIC--&gt;|MIC checked: success =&gt;
          |&lt;-----ACK, W=1-------| C=1 no Bitmap
        (End)    

</pre>
<p class="figure">Figure 29: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and no lost fragment.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss" class="xref">Figure 30</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<div id="rfc.figure.30"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss"></div>
<pre>
 &#160; &#160; &#160; &#160;Sender &#160; &#160; &#160; &#160; &#160; &#160; &#160; Receiver
          |-----W=1, FCN=6-----&gt;|
          |-----W=1, FCN=5-----&gt;|
          |-----W=1, FCN=4--X--&gt;|
          |-----W=1, FCN=3-----&gt;|
          |-----W=1, FCN=2--X--&gt;|             7
          |-----W=1, FCN=1-----&gt;|             /
          |-----W=1, FCN=0-----&gt;|       6543210
          |&lt;-----ACK, W=1-------|Bitmap:1101011
          |-----W=1, FCN=4-----&gt;|
          |-----W=1, FCN=2-----&gt;|
          |&lt;-----ACK, W=1-------|Bitmap:
          |-----W=0, FCN=6-----&gt;|
          |-----W=0, FCN=5-----&gt;|   
          |-----W=0, FCN=4--X--&gt;|
          |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
          |&lt;-----ACK, W=0-------| C= 0 Bitmap:11000001
          |-----W=0, FCN=4-----&gt;|MIC checked: success =&gt;
          |&lt;-----ACK, W=0-------| C= 1 no Bitmap
        (End)    

</pre>
<p class="figure">Figure 30: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6 and three lost fragments.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-A" class="xref">Figure 31</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments and only one retry needed to recover each lost fragment.</p>
<div id="rfc.figure.31"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-A"></div>
<pre>
          Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C= 0 Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |&lt;-----ACK, W=0-------|C=1 no Bitmap
           (End)
</pre>
<p class="figure">Figure 31: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, three lost fragments and only one retry needed for each lost fragment.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-B" class="xref">Figure 32</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost.</p>
<div id="rfc.figure.32"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-B"></div>
<pre>
          Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C=0  Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |  X---ACK, W=0-------|C= 1 no Bitmap
    timeout  |                     |
             |--W=0, FCN=7 + MIC--&gt;|
             |&lt;-----ACK, W=0-------|C= 1 no Bitmap  

           (End)
</pre>
<p class="figure">Figure 32: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, three lost fragments, and the second ACK lost.</p>
<p><a href="#Fig-Example-Rel-Window-ACK-Loss-Last-C" class="xref">Figure 33</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 6 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again.</p>
<div id="rfc.figure.33"></div>
<div id="Fig-Example-Rel-Window-ACK-Loss-Last-C"></div>
<pre>
           Sender                Receiver
             |-----W=0, FCN=6-----&gt;|
             |-----W=0, FCN=5-----&gt;|
             |-----W=0, FCN=4--X--&gt;|
             |-----W=0, FCN=3--X--&gt;|
             |-----W=0, FCN=2--X--&gt;|
             |--W=0, FCN=7 + MIC--&gt;|MIC checked: failed
             |&lt;-----ACK, W=0-------|C=0 Bitmap:1100001
             |-----W=0, FCN=4-----&gt;|MIC checked: failed
             |-----W=0, FCN=3-----&gt;|MIC checked: failed
             |-----W=0, FCN=2--X--&gt;|
      timeout|                     |
             |--W=0, FCN=7 + MIC--&gt;|All-0 empty
             |&lt;-----ACK, W=0-------|C=0 Bitmap: 1111101
             |-----W=0, FCN=2-----&gt;|MIC checked: success
             |&lt;-----ACK, W=0-------|C=1 no Bitmap
           (End)
</pre>
<p class="figure">Figure 33: Transmission in ACK-Always mode of an IPv6 packet carried by 11 fragments, with MAX_WIND_FCN=6, with three lost fragments, and one retransmitted fragment lost again.</p>
<p><a href="#Fig-Example-MaxWindFCN" class="xref">Figure 34</a> illustrates the transmission in ACK-Always mode of an IPv6 packet that needs 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments. Note that MAX_WIND_FCN=23 may be useful when the maximum possible Bitmap size, considering the maximum lower layer technology payload size and the value of R, is 3 bytes. Note also that the FCN of the last fragment of the packet is the one with FCN=31 (i.e. FCN=(2^N)-1 for N=5, or equivalently, all FCN bits set to 1).</p>
<div id="rfc.figure.34"></div>
<div id="Fig-Example-MaxWindFCN"></div>
<pre>
      Sender               Receiver
        |-----W=0, FCN=23-----&gt;|
        |-----W=0, FCN=22-----&gt;|
        |-----W=0, FCN=21--X--&gt;|
        |-----W=0, FCN=20-----&gt;|
        |-----W=0, FCN=19-----&gt;|
        |-----W=0, FCN=18-----&gt;|
        |-----W=0, FCN=17-----&gt;|
        |-----W=0, FCN=16-----&gt;|
        |-----W=0, FCN=15-----&gt;|
        |-----W=0, FCN=14-----&gt;|
        |-----W=0, FCN=13-----&gt;|
        |-----W=0, FCN=12-----&gt;|
        |-----W=0, FCN=11-----&gt;|
        |-----W=0, FCN=10--X--&gt;|
        |-----W=0, FCN=9 -----&gt;|
        |-----W=0, FCN=8 -----&gt;|
        |-----W=0, FCN=7 -----&gt;|
        |-----W=0, FCN=6 -----&gt;|
        |-----W=0, FCN=5 -----&gt;|
        |-----W=0, FCN=4 -----&gt;|
        |-----W=0, FCN=3 -----&gt;|
        |-----W=0, FCN=2 -----&gt;|
        |-----W=0, FCN=1 -----&gt;|
        |-----W=0, FCN=0 -----&gt;|
        |                      |lcl-Bitmap:110111111111101111111111
        |&lt;------ACK, W=0-------|truncated Bitmap:1101111111111011
        |-----W=0, FCN=21-----&gt;|
        |-----W=0, FCN=10-----&gt;|
        |&lt;------ACK, W=0-------|no Bitmap
        |-----W=1, FCN=23-----&gt;|
        |-----W=1, FCN=22-----&gt;|
        |-----W=1, FCN=21-----&gt;|
        |--W=1, FCN=31 + MIC--&gt;|MIC checked: sucess =&gt;
        |&lt;------ACK, W=1-------|no Bitmap
      (End)
</pre>
<p class="figure">Figure 34: Transmission in ACK-Always mode of an IPv6 packet carried by 28 fragments, with N=5, MAX_WIND_FCN=23 and two lost fragments.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#FSM" id="FSM">Fragmentation State Machines</a>
</h1>
<p id="rfc.section.C.p.1">The fragmentation state machines of the sender and the receiver, one for each of the different reliability modes, are described in the following figures:</p>
<div id="rfc.figure.35"></div>
<div id="Fig-NoACKModeSnd"></div>
<pre>
             +===========+
+------------+  Init     |                                      
|  FCN=0     +===========+                                      
|  No Window                                       
|  No Bitmap                                                      
|                   +-------+           
|          +========+==+    | More Fragments                 
|          |           | &lt;--+ ~~~~~~~~~~~~~~~~~~~~                          
+--------&gt; |   Send    |      send Fragment (FCN=0)                            
           +===+=======+                                                                      
               |  last fragment
               |  ~~~~~~~~~~~~                               
               |  FCN = 1                               
               v  send fragment+MIC
           +============+                                             
           |    END     |                                             
           +============+                       
</pre>
<p class="figure">Figure 35: Sender State Machine for the No-ACK Mode</p>
<div id="rfc.figure.36"></div>
<div id="Fig-NoACKModeRcv"></div>
<pre>
                      +------+ Not All-1
           +==========+=+    | ~~~~~~~~~~~~~~~~~~~
           |            + &lt;--+ set Inactivity Timer
           |  RCV Frag  +-------+
           +=+===+======+       |All-1 &amp;
   All-1 &amp;   |   |              |MIC correct
 MIC wrong   |   |Inactivity    |
             |   |Timer Exp.    |
             v   |              |
  +==========++  |              v
  |   Error   |&lt;-+     +========+==+
  +===========+        |    END    |
                       +===========+

</pre>
<p class="figure">Figure 36: Receiver State Machine for the No-ACK Mode</p>
<div id="rfc.figure.37"></div>
<div id="Fig-ACKAlwaysSnd"></div>
<pre>
              +=======+  
              | INIT  |       FCN!=0 &amp; more frags
              |       |       ~~~~~~~~~~~~~~~~~~~~~~
              +======++  +--+ send Window + frag(FCN)
                 W=0 |   |  | FCN-
  Clear lcl_bm       |   |  v set lcl_bm
       FCN=max value |  ++==+========+
                     +&gt; |            |
+---------------------&gt; |    SEND    |
|                       +==+===+=====+
|      FCN==0 &amp; more frags |   | last frag
|    ~~~~~~~~~~~~~~~~~~~~~ |   | ~~~~~~~~~~~~~~~
|               set lcl_bm |   | set lcl_bm
|   send wnd + frag(all-0) |   | send wnd+frag(all-1)+MIC
|       set Retrans_Timer  |   | set Retrans_Timer
|                          |   |
|Recv_wnd == wnd &amp;         |   |  
|lcl_bm==recv_bm &amp;         |   |  +-----------------------+
|more frag                 |   |  | lcl_bm!=rcv-bm        |
|~~~~~~~~~~~~~~~~~~~~~~    |   |  | ~~~~~~~~~             |
|Stop Retrans_Timer        |   |  | Attempt++             v
|clear lcl_bm              v   v  |                +=====+=+
|window=next_window   +====+===+==+===+            |Resend |
+---------------------+               |            |Missing|
                 +----+     Wait      |            |Frag   |
not expected wnd |    |    Bitmap     |            +=======+
~~~~~~~~~~~~~~~~ +---&gt;+               ++Retrans_Timer Exp  |          
    discard frag      +==+=+===+=+==+=+| ~~~~~~~~~~~~~~~~~ |
                         | |   | ^  ^  |reSend(empty)All-* |   
                         | |   | |  |  |Set Retrans_Timer  |
                         | |   | |  +--+Attempt++          |
MIC_bit==1 &amp;             | |   | +-------------------------+
Recv_window==window &amp;    | |   |   all missing frags sent
             no more frag| |   |   ~~~~~~~~~~~~~~~~~~~~~~
 ~~~~~~~~~~~~~~~~~~~~~~~~| |&#160;  | &#160; Set Retrans_Timer &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;
       Stop Retrans_Timer| |   |    
 +=============+         | |   |
 |     END     +&lt;--------+ |   |
 +=============+           |   | Attempt &gt; MAX_ACK_REQUESTS
            All-1 Window &amp; |   | ~~~~~~~~~~~~~~~~~~
             MIC_bit ==0 &amp; |   v Send Abort
          lcl_bm==recv_bm  | +=+===========+
 &#160; &#160; &#160; &#160; &#160; &#160;  ~~~~~~~~~~~~ +&gt;|    ERROR    |
                Send Abort   +=============+


</pre>
<p class="figure">Figure 37: Sender State Machine for the ACK-Always Mode</p>
<div id="rfc.figure.38"></div>
<div id="Fig-ACKAlwaysRcv"></div>
<pre>
 Not All- &amp; w=expected +---+   +---+w = Not expected
 ~~~~~~~~~~~~~~~~~~~~~ |   |   |   |~~~~~~~~~~~~~~~~
 Set lcl_bm(FCN)       |   v   v   |discard
                      ++===+===+===+=+      
+---------------------+ &#160; &#160; Rcv &#160; &#160;  +---&gt;* ABORT
|  +------------------+ &#160; Window &#160; &#160; |
|  | &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;  +=====+==+=====+  
|  | &#160; &#160; &#160; All-0 &amp; w=expect | &#160;^ w =next &amp; not-All
|  |     ~~~~~~~~~~~~~~~~~~ |  |~~~~~~~~~~~~~~~~~~~~~
|  |    set lcl_bm(FCN)     |  |expected = next window
|  |      send lcl_bm       |  |Clear lcl_bm
|  |                        |  |    
|  | w=expected &amp; not-All   |  |
|  | ~~~~~~~~~~~~~~~~~~     |  |
|  |     set lcl_bm(FCN)+-+ |  | +--+ w=next &amp; All-0
|  |     if lcl_bm full | | |  | |  | ~~~~~~~~~~~~~~~
|  |     send lcl_bm    | | |  | |  | expected = nxt wnd
|  |                    v | v  | |  | Clear lcl_bm
|  |w=expected&amp; All-1 +=+=+=+==+=++ | set lcl_bm(FCN)
|  |  ~~~~~~~~~~~  +-&gt;+    Wait   +&lt;+ send lcl_bm
|  |    discard    +--|    Next   |   
|  | All-0  +---------+  Window   +---&gt;* ABORT  
|  | ~~~~~  +--------&gt;+========+=++        
|  | snd lcl_bm  All-1 &amp; w=next| |  All-1 &amp; w=nxt
|  |                &amp; MIC wrong| |  &amp; MIC right      
|  |          ~~~~~~~~~~~~~~~~~| | ~~~~~~~~~~~~~~~~~~
|  |            set lcl_bm(FCN)| |set lcl_bm(FCN)
|  |                send lcl_bm| |send lcl_bm
|  |                           | +----------------------+
|  |All-1 &amp; w=expected         |                        |
|  |&amp; MIC wrong                v   +---+ w=expected &amp;   |
|  |~~~~~~~~~~~~~~~~~~~~  +====+=====+ | MIC wrong      |
|  |set lcl_bm(FCN)       |          +&lt;+ ~~~~~~~~~~~~~~ |
|  |send lcl_bm           | Wait End |   set lcl_bm(FCN)|
|  +---------------------&gt;+          +---&gt;* ABORT       |
|                         +===+====+=+-+ All-1&amp;MIC wrong|
|                             |    ^   | ~~~~~~~~~~~~~~~|
|      w=expected &amp; MIC right |    +---+   send lcl_bm  |
|      ~~~~~~~~~~~~~~~~~~~~~~ |                         |
|       set lcl_bm(FCN)       | +-+ Not All-1           |
|        send lcl_bm          | | | ~~~~~~~~~           |
|                             | | |  discard            |
|All-1&amp;w=expected &amp; MIC right | | |                     |
|~~~~~~~~~~~~~~~~~~~~~~~~~~~~ v | v +----+All-1         |
|set lcl_bm(FCN)            +=+=+=+=+==+ |~~~~~~~~~     |
|send lcl_bm                |          +&lt;+Send lcl_bm   |
+--------------------------&gt;+    END   |                |
                            +==========+&lt;---------------+

       ---&gt;* ABORT
 &#160; &#160; &#160; &#160; &#160; &#160;~~~~~~~
            Inactivity_Timer = expires
        When DWL
          IF Inactivity_Timer expires
             Send DWL Request
             Attempt++
 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;
</pre>
<p class="figure">Figure 38: Receiver State Machine for the ACK-Always Mode</p>
<div id="rfc.figure.39"></div>
<div id="Fig-ACKonerrorSnd"></div>
<pre>
                      +=======+
                      |       |
                      | INIT  |
                      |       |       FCN!=0 &amp; more frags
                      +======++       ~~~~~~~~~~~~~~~~~~~~~~
         Frag RuleID trigger |   +--+ Send cur_W + frag(FCN);
         ~~~~~~~~~~~~~~~~~~~ |   |  | FCN--;
      cur_W=0; FCN=max_value;|   |  | set [cur_W, cur_Bmp]
        clear [cur_W, Bmp_n];|   |  v
              clear rcv_Bmp  |  ++==+==========+         **BACK_TO_SEND
                             +-&gt;+              |     cur_W==rcv_W &amp;
          **BACK_TO_SEND        |     SEND     |     [cur_W,Bmp_n]==rcv_Bmp
    +--------------------------&gt;+              |     &amp; more frags
    |  +-----------------------&gt;+              |     ~~~~~~~~~~~~
    |  |                        ++===+=========+     cur_W++;
    |  |      FCN==0 &amp; more frags|   |last frag      clear [cur_W, Bmp_n]
    |  |  ~~~~~~~~~~~~~~~~~~~~~~~|   |~~~~~~~~~
    |  |        set cur_Bmp;     |   |set [cur_W, Bmp_n];
    |  |send cur_W + frag(All-0);|   |send cur_W + frag(All-1)+MIC;
    |  |        set Retrans_Timer|   |set Retrans_Timer
    |  |                         |   | +-----------------------------------+
    |  |Retrans_Timer expires &amp;  |   | |cur_W==rcv_W&amp;[cur_W,Bmp_n]!=rcv_Bmp|
    |  |more Frags               |   | |  ~~~~~~~~~~~~~~~~~~~              |
    |  |~~~~~~~~~~~~~~~~~~~~     |   | |  Attempts++; W=cur_W              |
    |  |stop Retrans_Timer;      |   | | +--------+             rcv_W==Wn &amp;|
    |  |[cur_W,Bmp_n]==cur_Bmp;  v   v | |        v     [Wn,Bmp_n]!=rcv_Bmp|
    |  |cur_W++            +=====+===+=+=+==+   +=+=========+   ~~~~~~~~~~~|
    |  +-------------------+                |   | Resend    |   Attempts++;|
    +----------------------+   Wait x ACK   |   | Missing   |         W=Wn |
    +---------------------&gt;+                |   | Frags(W)  +&lt;-------------+
    |         rcv_W==Wn &amp;+-+                |   +======+====+
    | [Wn,Bmp_n]!=rcv_Bmp| ++=+===+===+==+==+          |
    |      ~~~~~~~~~~~~~~|  ^ |   |   |  ^             |
    |        send (cur_W,+--+ |   |   |  +-------------+
    |        ALL-0-empty)     |   |   |     all missing frag sent(W)
    |                         |   |   |     ~~~~~~~~~~~~~~~~~
    |  Retrans_Timer expires &amp;|   |   |     set Retrans_Timer
    |            No more Frags|   |   |
    |           ~~~~~~~~~~~~~~|   |   |
    |      stop Retrans_Timer;|   |   |
    |(re)send frag(All-1)+MIC |   |   |
    +-------------------------+   |   |
                     cur_W==rcv_W&amp;|   |
           [cur_W,Bmp_n]==rcv_Bmp&amp;|   | Attempts &gt; MAX_ACK_REQUESTS
      No more Frags &amp; MIC flag==OK|   | ~~~~~~~~~~
                ~~~~~~~~~~~~~~~~~~|   | send Abort
     +=========+stop Retrans_Timer|   |  +===========+
     |   END   +&lt;-----------------+   +-&gt;+   ERROR   |
     +=========+                         +===========+
</pre>
<p class="figure">Figure 39: Sender State Machine for the ACK-on-Error Mode</p>
<p id="rfc.section.C.p.2">This is an example only. The specification in <a href="#ACK-on-Error-sender" class="xref">Section 8.4.3.1</a> is open to very different sequencing of operations.</p>
<pre>
                 +=======+        New frag RuleID received
                 |       |        ~~~~~~~~~~~~~
                 | INIT  +-------+cur_W=0;clear([cur_W,Bmp_n]);
                 +=======+       |sync=0
                                 |
    Not All* &amp; rcv_W==cur_W+---+ | +---+
      ~~~~~~~~~~~~~~~~~~~~ |   | | |  (E)
      set[cur_W,Bmp_n(FCN)]|   v v v   |
                          ++===+=+=+===+=+
   +----------------------+              +--+ All-0&amp;Full[cur_W,Bmp_n]
   |           ABORT *&lt;---+  Rcv Window  |  | ~~~~~~~~~~
   |  +-------------------+              +&lt;-+ cur_W++;set Inact_timer;
   |  |                +-&gt;+=+=+=+=+=+====+    clear [cur_W,Bmp_n]
   |  | All-0 empty(Wn)|    | | | ^ ^
   |  | ~~~~~~~~~~~~~~ +----+ | | | |rcv_W==cur_W &amp; sync==0;
   |  | sendACK([Wn,Bmp_n])   | | | |&amp; Full([cur_W,Bmp_n])
   |  |                       | | | |&amp; All* || last_miss_frag
   |  |                       | | | |~~~~~~~~~~~~~~~~~~~~~~
   |  |    All* &amp; rcv_W==cur_W|(C)| |sendACK([cur_W,Bmp_n]);
   |  |              &amp; sync==0| | | |cur_W++; clear([cur_W,Bmp_n])
   |  |&amp;no_full([cur_W,Bmp_n])| |(E)|
   |  |      ~~~~~~~~~~~~~~~~ | | | |              +========+
   |  | sendACK([cur_W,Bmp_n])| | | |              | Error/ |
   |  |                       | | | |   +----+     | Abort  |
   |  |                       v v | |   |    |     +===+====+
   |  |                   +===+=+=+=+===+=+ (D)        ^
   |  |                +--+    Wait x     |  |         |
   |  | All-0 empty(Wn)+-&gt;| Missing Frags |&lt;-+         |
   |  | ~~~~~~~~~~~~~~    +=============+=+            |
   |  | sendACK([Wn,Bmp_n])             +--------------+
   |  |                                       *ABORT
   v  v
  (A)(B)
                                    (D) All* || last_miss_frag
    (C) All* &amp; sync&gt;0                   &amp; rcv_W!=cur_W &amp; sync&gt;0
        ~~~~~~~~~~~~                    &amp; Full([rcv_W,Bmp_n])
        Wn=oldest[not full(W)];         ~~~~~~~~~~~~~~~~~~~~
        sendACK([Wn,Bmp_n])             Wn=oldest[not full(W)];
                                        sendACK([Wn,Bmp_n]);sync--

                              ABORT--&gt;* Uplink Only &amp;
                                        Inact_Timer expires
    (E) Not All* &amp; rcv_W!=cur_W         || Attempts &gt; MAX_ACK_REQUESTS
        ~~~~~~~~~~~~~~~~~~~~            ~~~~~~~~~~~~~~~~~~~~~
        sync++; cur_W=rcv_W;            send Abort
        set[cur_W,Bmp_n(FCN)]

</pre>
<div id="rfc.figure.40"></div>
<div id="Fig-ACKonerrorRcv"></div>
<pre>
  (A)(B)
   |  |
   |  | All-1 &amp; rcv_W==cur_W &amp; MIC!=OK        All-0 empty(Wn)
   |  | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~     +-+  ~~~~~~~~~~
   |  | sendACK([cur_W,Bmp_n],MIC=0)     | v  sendACK([Wn,Bmp_n])
   |  |                      +===========+=++
   |  +---------------------&gt;+   Wait End   +-+
   |                         +=====+=+====+=+ | All-1
   |     rcv_W==cur_W &amp; MIC==OK    | |    ^   | &amp; rcv_W==cur_W
   |     ~~~~~~~~~~~~~~~~~~~~~~    | |    +---+ &amp; MIC!=OK
   |  sendACK([cur_W,Bmp_n],MIC=1) | |          ~~~~~~~~~~~~~~~~~~~
   |                               | | sendACK([cur_W,Bmp_n],MIC=0);
   |                               | |          Attempts++
   |All-1 &amp; Full([cur_W,Bmp_n])    | |
   |&amp; MIC==OK &amp; sync==0            | +--&gt;* ABORT
   |~~~~~~~~~~~~~~~~~~~            v
   |sendACK([cur_W,Bmp_n],MIC=1) +=+=========+
   +----------------------------&gt;+    END    |
                                 +===========+


         ABORT --&gt;* Uplink Only &amp;
                    Inact_Timer = expires
                    || Attempts &gt; MAX_ACK_REQUESTS
                    ~~~~~~~~~~~~~~~~~~~~~
                    send Abort

</pre>
<p class="figure">Figure 40: Receiver State Machine for the ACK-on-Error Mode</p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#SCHCParams" id="SCHCParams">SCHC Parameters</a>
</h1>
<p id="rfc.section.D.p.1">This section lists the information that need to be provided in the LPWAN technology-specific documents.</p>
<p></p>

<ul>
<li>Most common uses cases, deployment scenarios</li>
<li>Mapping of the SCHC architectural elements onto the LPWAN architecture</li>
<li>Assessment of LPWAN integrity checking</li>
<li>Various potential channel conditions for the technology and the corresponding recommended use of SCHC C/D and F/R</li>
</ul>
<p id="rfc.section.D.p.3">This section lists the parameters that need to be defined in theProfile.</p>
<p></p>

<ul>
<li>Rule ID numbering scheme, fixed-sized or variable-sized Rule IDs, number of Rules, the way the Rule ID is transmitted</li>
<li>Padding: size of the L2 Word (for most LPWAN technologies, this would be a byte; for some technologies, a bit)</li>
<li>Decision to use SCHC fragmentation mechanism or not. If yes:  <ul>
<li>reliability mode(s) used, in which cases (e.g. based on link channel condition)</li>
<li>number of bits for FCN (N), for W (M) and for DTag (T)</li>
<li>support for interleaved packet transmission, to what extent</li>
<li>size of MIC and algorithm for its computation, if different from the default CRC32. Byte fill-up with zeroes or other mechanism, to be specified.</li>
<li>Retransmission Timer duration</li>
<li>Inactivity Timer duration</li>
<li>MAX_ACK_REQUEST value</li>
</ul>
</li>
<li>if L2 Word is wider than a bit and SCHC fragmentation is used, value of the padding bits (0 or 1). This is needed because the padding bits of the last fragment are included in the MIC computation.</li>
<li>Note on the &#8220;C-bit bump&#8221;: When fragmenting in ACK-on-Error or ACK-Always mode, it is expected that the last window (called All-1 window) will not be fully utilised, i.e. there won&#8217;t be fragments with all FCN values from MAX_WIND_FCN downto 1 and finally All-1.  It is worth noting that this document does not mandate that other windows (called All-0 windows) are fully utilised either.  This document purposely does not specify that All-1 windows use Bitmaps with the same number of bits as All-0 windows do.  By default, Bitmaps for All-0 and All-1 windows are of the same size MAX_WIND_FCN + 1. But a Profile MAY revert that decision. The rationale for reverting the decision could be the following: Note that the SCHC ACK sent as a response to an All-1 fragment includes a C bit that SCHC ACK for other windows don&#8217;t have. Therefore, the SCHC ACK for the All-1 window is one bit bigger. An LPWAN technology with a severely constrained payload size might decide that this &#8220;bump&#8221; in the SCHC ACK for the last fragment is a bad resource usage. It could thus mandate that the All-1 window is not allowed to use the FCN value 1 and that the SCHC ACK Bitmap size is reduced by 1 bit. This provides room for the C bit without creating a bump in the SCHC ACK.</li>
<li>Note on soliciting downlink transmissions: In some LPWAN technologies, as part of energy-saving techniques, downlink transmission is only possible immediately after an uplink transmission.  In order to avoid potentially high delay in the downlink transmission of a fragmented SCHC Packet, the SCHC Fragment receiver may want to perform an uplink transmission as soon as possible after reception of a SCHC Fragment that is not the last one.  Such uplink transmission may be triggered by the L2 (e.g. an L2 ACK sent in response to a SCHC Fragment encapsulated in a L2 PDU that requires an L2 ACK) or it may be triggered from an upper layer.</li>
<li>the following parameters need to be addressed in documents other than this one but not forcely in the LPWAN technology-specific documents:  <ul>
<li>The way the contexts are provisioned</li>
<li>The way the Rules as generated</li>
</ul>
</li>
</ul>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#note" id="note">Note</a>
</h1>
<p id="rfc.section.E.p.1">Carles Gomez has been funded in part by the Spanish Government (Ministerio de Educacion, Cultura y Deporte) through the Jose Castillejo grant CAS15/00336, and by the ERDF and the Spanish Government through project TEC2016-79988-P.  Part of his contribution to this work has been carried out during his stay as a visiting scholar at the Computer Laboratory of the University of Cambridge.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ana Minaburo</span> 
	  <span class="n hidden">
		<span class="family-name">Minaburo</span>
	  </span>
	</span>
	<span class="org vcardline">Acklio</span>
	<span class="adr">
	  <span class="vcardline">1137A avenue des Champs Blancs</span>

	  <span class="vcardline">
		<span class="locality">35510 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ana@ackl.io">ana@ackl.io</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Laurent Toutain</span> 
	  <span class="n hidden">
		<span class="family-name">Toutain</span>
	  </span>
	</span>
	<span class="org vcardline">IMT-Atlantique</span>
	<span class="adr">
	  <span class="vcardline">2 rue de la Chataigneraie</span>
<span class="vcardline">CS 17607</span>

	  <span class="vcardline">
		<span class="locality">35576 Cesson-Sevigne Cedex</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Laurent.Toutain@imt-atlantique.fr">Laurent.Toutain@imt-atlantique.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carles Gomez</span> 
	  <span class="n hidden">
		<span class="family-name">Gomez</span>
	  </span>
	</span>
	<span class="org vcardline">Universitat Polit&#232;cnica de Catalunya</span>
	<span class="adr">
	  <span class="vcardline">C/Esteve Terradas, 7</span>
<span class="vcardline">08860 Castelldefels</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Spain</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:carlesgo@entel.upc.edu">carlesgo@entel.upc.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Dominique Barthel</span> 
	  <span class="n hidden">
		<span class="family-name">Barthel</span>
	  </span>
	</span>
	<span class="org vcardline">Orange Labs</span>
	<span class="adr">
	  <span class="vcardline">28 chemin du Vieux Ch&#234;ne</span>
<span class="vcardline">38243 Meylan</span>

	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:dominique.barthel@orange.com">dominique.barthel@orange.com</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/lp-wan/ip-compression">Fork me on GitHub</a></div></div>
</body>
</html>
